<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA数据结构与算法"><a href="#JAVA数据结构与算法" class="headerlink" title="JAVA数据结构与算法"></a>JAVA数据结构与算法</h1><p>该博客是根据<a href="https://www.bilibili.com/video/BV1B4411H76f?from=search&seid=14863448557523728830" target="_blank" rel="noopener">Java -韩顺平 图解Java 数据结构 和 算法-尚硅谷</a>学习时，所做的笔记</p><h1 id="一、稀疏数组和队列"><a href="#一、稀疏数组和队列" class="headerlink" title="一、稀疏数组和队列"></a>一、稀疏数组和队列</h1><h2 id="1、稀疏数组"><a href="#1、稀疏数组" class="headerlink" title="1、稀疏数组"></a>1、稀疏数组</h2><h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用<strong>稀疏数组</strong>来保存该数组。</p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><ul><li>记录数组<strong>一共有几行几列</strong>，有多少个<strong>不同的值</strong></li><li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而<strong>缩小程序</strong>的规模</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200610224442.png" srcset="/img/loading.gif" alt=""></p><p>如图，把一个6X7的二维数组变为了一个9X3的稀疏数组。其中</p><ul><li>第一行保存的是原二维数组的行、列以及非0值的个数</li><li>第二到九行保存的是每个非0值所在的位置及其数值</li></ul><h3 id="转换思路"><a href="#转换思路" class="headerlink" title="转换思路"></a>转换思路</h3><p>二维数组转稀疏数组</p><ul><li>遍历二维数组，得到二维数组中有效值的个数sum</li><li>创建稀疏数组，有sum+1行，3列（固定）</li><li>将二维数组中的有效值存入稀疏数组中</li></ul><p>稀疏数组转二维数组</p><ul><li>先读取稀疏数组的第一行（保存二维数组的行列信息），还原二维数组</li><li>读取稀疏数组的其他行，将值赋给二维数组的对应位置上的数</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建一个二维数组</span>      <span class="hljs-keyword">int</span>[][] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];      <span class="hljs-comment">//向二维数组里放值</span>      arr1[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;      arr1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;      arr1[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">3</span>;      <span class="hljs-comment">//打印二维数组</span>      System.out.println(<span class="hljs-string">"遍历二维数组"</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr1[<span class="hljs-number">0</span>].length; j++) &#123;            System.out.print(arr1[i][j] + <span class="hljs-string">"   "</span>);         &#125;         System.out.println();      &#125;      <span class="hljs-comment">//二位数组-----&gt;稀疏数组</span>      <span class="hljs-comment">//遍历二维数组中有效值的个数,用sum来记录</span>      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr1[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-keyword">if</span> (arr1[i][j] != <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//二维数组中元素不为0即为有效值</span>               sum++;            &#125;         &#125;      &#125;      <span class="hljs-comment">//创建稀疏数组</span>      <span class="hljs-comment">//行数为sum+1，第一行用于保存二维数组的行列及有效值个数，列数固定为3</span>      <span class="hljs-keyword">int</span>[][] sparseArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum + <span class="hljs-number">1</span>][<span class="hljs-number">3</span>];      <span class="hljs-comment">//存入二维数组的行列及有效值个数</span>      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = arr1.length;      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = arr1[<span class="hljs-number">0</span>].length;      sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = sum;      <span class="hljs-comment">//再次遍历二维数组，将有效值存入稀疏数组</span>      <span class="hljs-comment">//用于保存稀疏数组的行数</span>      <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr1.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr1[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-keyword">if</span> (arr1[i][j] != <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//将值存入稀疏数组</span>               sparseArr[count][<span class="hljs-number">0</span>] = i;               sparseArr[count][<span class="hljs-number">1</span>] = j;               sparseArr[count][<span class="hljs-number">2</span>] = arr1[i][j];               count++;            &#125;         &#125;      &#125;      <span class="hljs-comment">//打印稀疏数组</span>      System.out.println(<span class="hljs-string">"遍历稀疏数组"</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sparseArr.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; sparseArr[<span class="hljs-number">0</span>].length; j++) &#123;            System.out.print(sparseArr[i][j] + <span class="hljs-string">"   "</span>);         &#125;         System.out.println();      &#125;      <span class="hljs-comment">//稀疏数组------&gt;二维数组</span>      <span class="hljs-comment">//先得到二位数组的行列数</span>      <span class="hljs-keyword">int</span> row = sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];      <span class="hljs-keyword">int</span> col = sparseArr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];      <span class="hljs-keyword">int</span>[][] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[row][col];      <span class="hljs-comment">//遍历稀疏数组，同时给二维数组赋值</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; sparseArr.length; i++) &#123;         row = sparseArr[i][<span class="hljs-number">0</span>];         col = sparseArr[i][<span class="hljs-number">1</span>];         <span class="hljs-comment">//该位置上对应的值</span>         <span class="hljs-keyword">int</span> val = sparseArr[i][<span class="hljs-number">2</span>];         arr2[row][col] = val;      &#125;      <span class="hljs-comment">//打印二维数组</span>      System.out.println(<span class="hljs-string">"遍历还原后的二维数组"</span>);      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr2.length; i++) &#123;         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; arr2[<span class="hljs-number">0</span>].length; j++) &#123;            System.out.print(arr2[i][j] + <span class="hljs-string">"   "</span>);         &#125;         System.out.println();      &#125;   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">遍历二维数组<span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">2</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   遍历稀疏数组<span class="hljs-number">11</span>   <span class="hljs-number">11</span>   <span class="hljs-number">3</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span>   <span class="hljs-number">4</span>   <span class="hljs-number">3</span>   遍历还原后的二维数组<span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">2</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">3</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span>   <span class="hljs-number">0</span></code></pre><h2 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>队列是一个<strong>有序列表</strong>，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li><li>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li></ul><h3 id="模拟思路"><a href="#模拟思路" class="headerlink" title="模拟思路"></a>模拟思路</h3><ul><li><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量</p></li><li><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变，如图所示</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614170043.png" srcset="/img/loading.gif" alt=""></p><h4 id="入队出队操作模拟"><a href="#入队出队操作模拟" class="headerlink" title="入队出队操作模拟"></a>入队出队操作模拟</h4><p>当我们将数据存入队列时称为”addQueue”，addQueue 的处理需要有两个步骤：</p><ul><li><p>将尾指针往后移：rear+1 , 当 <strong>front == rear</strong> 时，队列为空</p></li><li><p>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。<strong>rear == maxSize - 1</strong>时，队列满</p></li></ul><p><strong>注意</strong>：front指向的是队列首元素的<strong>前一个位置</strong></p><p><strong>实现代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ArrayQueue queue = <span class="hljs-keyword">new</span> ArrayQueue(<span class="hljs-number">5</span>);      queue.addNum(<span class="hljs-number">1</span>);      queue.addNum(<span class="hljs-number">2</span>);      queue.addNum(<span class="hljs-number">3</span>);      queue.addNum(<span class="hljs-number">4</span>);      queue.addNum(<span class="hljs-number">5</span>);      System.out.println(queue.getNum());      queue.showQueue();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span> </span>&#123;   <span class="hljs-comment">//队列的大小</span>   <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-comment">//用数组来实现队列</span>   <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-comment">//指向队列首元素的前一个位置</span>   <span class="hljs-keyword">int</span> front;   <span class="hljs-comment">//指向队列的尾元素</span>   <span class="hljs-keyword">int</span> rear;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;      <span class="hljs-keyword">this</span>.maxSize = maxSize;      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];      <span class="hljs-comment">//front指向队列首元素的前一个位置</span>      front = -<span class="hljs-number">1</span>;      rear = -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> rear == maxSize - <span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> front == rear;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isFull()) &#123;         System.out.println(<span class="hljs-string">"队列已满，无法在进行入队操作"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//队尾标记后移，指向要放入的元素的位置</span>      rear++;      arr[rear] = num;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法出队"</span>);      &#125;      <span class="hljs-comment">//队首标记后移，指向队首元素</span>      System.out.print(<span class="hljs-string">"出队元素是："</span>);      front++;      <span class="hljs-keyword">return</span> arr[front];   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQueue</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法遍历"</span>);      &#125;      System.out.println(<span class="hljs-string">"遍历队列"</span>);      <span class="hljs-comment">//从front+1开始读取元素</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> start = front+<span class="hljs-number">1</span>; start&lt;=rear; start++) &#123;         System.out.println(arr[start]);      &#125;   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">出队元素是：<span class="hljs-number">1</span>遍历队列<span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span></code></pre><h3 id="环形队列"><a href="#环形队列" class="headerlink" title="环形队列"></a>环形队列</h3><p>思路：</p><ul><li>front变量指向<strong>队首元素</strong>，初值为0</li><li>rear变量指向队尾元素的<strong>下一个元素</strong>，初值为0。规定空出一个位置</li><li>队列为空的判定条件：front == rear</li><li>队列为满的判定条件：(rear + 1) % maxSize == front</li><li>队列中有效元素的个数：(rear - front + maxSize) % maxSize</li><li>入队和出队时，都需要让标记<strong>对maxSize取模</strong></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ArrayAroundQueue aroundQueue = <span class="hljs-keyword">new</span> ArrayAroundQueue(<span class="hljs-number">5</span>);      aroundQueue.addNum(<span class="hljs-number">1</span>);      aroundQueue.addNum(<span class="hljs-number">2</span>);      aroundQueue.addNum(<span class="hljs-number">3</span>);      aroundQueue.addNum(<span class="hljs-number">4</span>);      aroundQueue.showQueue();      System.out.println(aroundQueue.getNum());      System.out.println(aroundQueue.getNum());      aroundQueue.addNum(<span class="hljs-number">5</span>);      aroundQueue.addNum(<span class="hljs-number">6</span>);      aroundQueue.showQueue();      aroundQueue.getHead();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayAroundQueue</span> </span>&#123;   <span class="hljs-comment">//队列的大小</span>   <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-comment">//用数组来实现队列</span>   <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-comment">//指向队列首元素的前一个位置</span>   <span class="hljs-keyword">int</span> front;   <span class="hljs-comment">//指向队列的尾元素</span>   <span class="hljs-keyword">int</span> rear;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayAroundQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;      <span class="hljs-keyword">this</span>.maxSize = maxSize;      arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];      <span class="hljs-comment">//front指向队列首元素的前一个位置</span>      front = <span class="hljs-number">0</span>;      rear = <span class="hljs-number">0</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> (rear+<span class="hljs-number">1</span>)%maxSize == front;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> front == rear;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isFull()) &#123;         System.out.println(<span class="hljs-string">"队列已满，无法在进行入队操作"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//先放入元素，在后移队尾标记</span>      arr[rear] = num;      rear = (rear+<span class="hljs-number">1</span>)%maxSize;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法出队"</span>);      &#125;      <span class="hljs-comment">//队首标记后移，指向队首元素</span>      System.out.print(<span class="hljs-string">"出队元素是："</span>);      <span class="hljs-keyword">int</span> num = arr[front];      front = (front+<span class="hljs-number">1</span>)%maxSize;      <span class="hljs-keyword">return</span> num;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showQueue</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空，无法遍历"</span>);      &#125;      System.out.println(<span class="hljs-string">"遍历队列"</span>);      <span class="hljs-comment">//当front + 1 == rear时停止遍历</span>      <span class="hljs-keyword">int</span> start = front;      <span class="hljs-keyword">while</span>(start != rear) &#123;         System.out.println(arr[start]);         <span class="hljs-comment">//移动到下一个元素</span>         start = (start+<span class="hljs-number">1</span>)%maxSize;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getHead</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"队列为空"</span>);      &#125;      System.out.println(<span class="hljs-string">"队首元素为："</span>+arr[front]);   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs java">遍历队列<span class="hljs-number">1</span><span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">4</span>出队元素是：<span class="hljs-number">1</span>出队元素是：<span class="hljs-number">2</span>遍历队列<span class="hljs-number">3</span><span class="hljs-number">4</span><span class="hljs-number">5</span><span class="hljs-number">6</span>队首元素为：<span class="hljs-number">3</span></code></pre><h1 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h1><h2 id="1、单向链表"><a href="#1、单向链表" class="headerlink" title="1、单向链表"></a>1、单向链表</h2><h3 id="链表的介绍"><a href="#链表的介绍" class="headerlink" title="链表的介绍"></a>链表的介绍</h3><p>链表在内存中的存储</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617221622.png" srcset="/img/loading.gif" alt=""></p><p><strong>特点</strong></p><ul><li>链表是以节点的方式来存储,<strong>是链式存储</strong></li><li>每个节点包含 data 域 和 next 域。next域用来指向下一个节点</li><li>链表的各个节点不一定是连续存储的</li><li>链表分<strong>带头节点的链表</strong>和<strong>没有头节点的链表</strong>，根据实际的需求来确定</li></ul><p>带头结点的<strong>逻辑示意图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617221632.png" srcset="/img/loading.gif" alt=""></p><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>创建（添加）</strong></p><ul><li>先创建一个Head头节点，表示单链表的头</li><li>后面我们每添加一个节点，就放在链表的最后</li></ul><p><strong>遍历</strong></p><ul><li>通过一个辅助变量，来遍历整个链表</li></ul><p><strong>有序插入</strong></p><ul><li>先遍历链表，找到应该插入的位置</li><li>要插入的节点的next指向插入位置的后一个节点</li><li>插入位置的前一个节点的next指向要插入节点<ul><li>插入前要判断是否在队尾插入</li></ul></li></ul><p><strong>根据某个属性节点修改值</strong></p><ul><li>先遍历节点，找到修改的位置<ul><li>如果未找到修改节点，则不修改</li></ul></li></ul><p><strong>删除某个节点</strong></p><ul><li>先遍历节点，找到要删除节点的前一个节点</li><li>进行删除操作</li></ul><p><strong>求倒数第n个节点的信息</strong></p><ul><li>遍历链表，求出链表的<strong>有效长度</strong>length（不算头结点）</li><li>遍历链表到第length-n的节点</li></ul><p><strong>翻转链表</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616112143.png" srcset="/img/loading.gif" alt=""></p><ul><li>创建一个新的头结点，作为新链表的头</li><li>从头遍历旧链表，将遍历到的节点插入新链表的头结点之后</li><li>注意需要用到<strong>两个暂存节点</strong><ul><li>一个用来保存正在遍历的节点</li><li>一个用来保存正在遍历节点的下一个节点</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142843.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142931.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142248.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616142415.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617221646.png" srcset="/img/loading.gif" alt=""></p><p><strong>逆序打印</strong></p><ul><li>遍历链表，将遍历到的节点入栈</li><li>遍历完后，进行出栈操作，同时打印出栈元素</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;LinkedList linkedList = <span class="hljs-keyword">new</span> LinkedList();linkedList.traverseNode();System.out.println();<span class="hljs-comment">//创建学生节点，并插入链表</span>StudentNode student1 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>);StudentNode student3 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">3</span>, <span class="hljs-string">"Lulu"</span>);linkedList.addNode(student1);linkedList.addNode(student3);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//按id大小插入</span>System.out.println(<span class="hljs-string">"有序插入"</span>);StudentNode student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">0</span>, <span class="hljs-string">"Wenwen"</span>);linkedList.addByOrder(student2);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//按id修改学生信息</span>System.out.println(<span class="hljs-string">"修改学生信息"</span>);student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Hulu"</span>);linkedList.changeNode(student2);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//根据id删除学生信息</span>System.out.println(<span class="hljs-string">"删除学生信息"</span>);student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Hulu"</span>);linkedList.deleteNode(student2);linkedList.traverseNode();System.out.println();<span class="hljs-comment">//获得倒数第几个节点</span>System.out.println(<span class="hljs-string">"获得倒数节点"</span>);System.out.println(linkedList.getStuByRec(<span class="hljs-number">2</span>));System.out.println();<span class="hljs-comment">//翻转链表</span>System.out.println(<span class="hljs-string">"翻转链表"</span>);LinkedList newLinkedList = linkedList.reverseList();newLinkedList.traverseNode();System.out.println();<span class="hljs-comment">//倒叙遍历链表</span>System.out.println(<span class="hljs-string">"倒序遍历链表"</span>);newLinkedList.reverseTraverse();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 创建链表</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>&#123;<span class="hljs-comment">//头节点，防止被修改，设置为私有的</span><span class="hljs-keyword">private</span> StudentNode head = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">0</span>, <span class="hljs-string">""</span>);<span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 要添加的节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(StudentNode node)</span> </span>&#123;<span class="hljs-comment">//因为头节点不能被修改，所以创建一个辅助节点</span>StudentNode temp = head;<span class="hljs-comment">//找到最后一个节点</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//temp是尾节点就停止循环</span><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-comment">//不是尾结点就向后移动</span>temp = temp.next;&#125;<span class="hljs-comment">//现在temp是尾节点了，再次插入</span>temp.next = node;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 遍历链表</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverseNode</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"开始遍历链表"</span>);<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);&#125;<span class="hljs-comment">//创建辅助节点</span>StudentNode temp = head.next;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//遍历完成就停止循环</span><span class="hljs-keyword">if</span>(temp == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">break</span>;&#125;System.out.println(temp);temp = temp.next;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 按id顺序插入节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addByOrder</span><span class="hljs-params">(StudentNode node)</span> </span>&#123;<span class="hljs-comment">//如果没有首节点，就直接插入</span><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;head.next = node;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//辅助节点，用于找到插入位置和插入操作</span>StudentNode temp = head;<span class="hljs-comment">//节点的下一个节点存在，且它的id小于要插入节点的id，就继续下移</span><span class="hljs-keyword">while</span> (temp.next!=<span class="hljs-keyword">null</span> &amp;&amp; temp.next.id &lt; node.id) &#123;temp = temp.next;&#125;<span class="hljs-comment">//如果temp的下一个节点存在，则执行该操作</span><span class="hljs-comment">//且插入操作，顺序不能换</span><span class="hljs-keyword">if</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;node.next = temp.next;&#125;temp.next = node; &#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据id来修改节点信息</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 修改信息的节点</span><span class="hljs-comment"> */</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeNode</span><span class="hljs-params">(StudentNode node)</span> </span>&#123;<span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空，请先加入该学生信息"</span>);<span class="hljs-keyword">return</span>;&#125;StudentNode temp = head;<span class="hljs-comment">//遍历链表，找到要修改的节点</span><span class="hljs-keyword">while</span> (temp.next!= <span class="hljs-keyword">null</span> &amp;&amp; temp.id != node.id) &#123;temp = temp.next;&#125;<span class="hljs-comment">//如果temp已经是最后一个节点，判断id是否相等</span><span class="hljs-keyword">if</span>(temp.id != node.id) &#123;System.out.println(<span class="hljs-string">"未找到该学生的信息，请先创建该学生的信息"</span>);<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//修改学生信息</span>temp.name = node.name;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 根据id删除节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 要删除的节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(StudentNode node)</span> </span>&#123; <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);<span class="hljs-keyword">return</span>;&#125; StudentNode temp = head.next; <span class="hljs-comment">//遍历链表，找到要删除的节点</span> <span class="hljs-keyword">if</span>(temp.next!=<span class="hljs-keyword">null</span> &amp;&amp; temp.next.id!=node.id) &#123; temp = temp.next;&#125; <span class="hljs-comment">//判断最后一个节点的是否要删除的节点</span> <span class="hljs-keyword">if</span>(temp.next.id != node.id) &#123;System.out.println(<span class="hljs-string">"请先插入该学生信息"</span>);<span class="hljs-keyword">return</span>;&#125; <span class="hljs-comment">//删除该节点</span> temp.next = temp.next.next;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 得到倒数的节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index 倒数第几个数</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> StudentNode <span class="hljs-title">getStuByRec</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空!"</span>);&#125;StudentNode temp = head.next;<span class="hljs-comment">//用户记录链表长度，因为head.next不为空，此时已经有一个节点了</span><span class="hljs-comment">//所以length初始化为1</span><span class="hljs-keyword">int</span> length = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;temp = temp.next;length++;&#125;<span class="hljs-keyword">if</span>(length &lt; index) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"链表越界"</span>);&#125;temp = head.next;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;length-index; i++) &#123;temp = temp.next;&#125;<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 翻转链表</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 反转后的链表</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> LinkedList <span class="hljs-title">reverseList</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//链表为空或者只有一个节点，无需翻转</span><span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"无需翻转"</span>);&#125;LinkedList newLinkedList = <span class="hljs-keyword">new</span> LinkedList();<span class="hljs-comment">//给新链表创建新的头结点</span>newLinkedList.head = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">0</span>, <span class="hljs-string">""</span>);<span class="hljs-comment">//用于保存正在遍历的节点</span>StudentNode temp = head.next;<span class="hljs-comment">//用于保存正在遍历节点的下一个节点</span>StudentNode nextNode = temp.next;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//插入新链表</span>temp.next = newLinkedList.head.next;newLinkedList.head.next = temp;<span class="hljs-comment">//移动到下一个节点</span>temp = nextNode;nextNode = nextNode.next;<span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//插入最后一个节点</span>temp.next = newLinkedList.head.next;newLinkedList.head.next = temp;head.next = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">return</span> newLinkedList;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reverseTraverse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);&#125;StudentNode temp = head.next;<span class="hljs-comment">//创建栈，用于存放遍历到的节点</span>Stack&lt;StudentNode&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>) &#123;stack.push(temp);temp = temp.next;&#125;<span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;System.out.println(stack.pop());&#125;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 定义节点</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentNode</span> </span>&#123;<span class="hljs-keyword">int</span> id;String name;<span class="hljs-comment">//用于保存下一个节点的地址</span>StudentNode next;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"StudentNode&#123;"</span> +<span class="hljs-string">"id="</span> + id +<span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p>结果</p><pre><code class="hljs java">开始遍历链表链表为空开始遍历链表StudentNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">'Nyima'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;有序插入开始遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">'Nyima'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;修改学生信息开始遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">1</span>, name=<span class="hljs-string">'Hulu'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;删除学生信息开始遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;获得倒数节点StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;翻转链表开始遍历链表StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;倒序遍历链表StudentNode&#123;id=<span class="hljs-number">0</span>, name=<span class="hljs-string">'Wenwen'</span>&#125;StudentNode&#123;id=<span class="hljs-number">3</span>, name=<span class="hljs-string">'Lulu'</span>&#125;</code></pre><h2 id="2、双向链表"><a href="#2、双向链表" class="headerlink" title="2、双向链表"></a>2、双向链表</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616170404.png" srcset="/img/loading.gif" alt=""></p><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><p><strong>遍历</strong></p><ul><li>和单向链表的遍历相同，需要一个辅助节点来保存当前正在遍历的节点</li></ul><p><strong>添加</strong></p><ul><li>双向链表多出了一个frnot，所以在添加时，要让新增节点的front指向链表尾节点</li></ul><p><strong>修改</strong></p><ul><li>和单向链表的修改相同</li></ul><p><strong>删除</strong></p><ul><li>使用temp来保存要删除的节点</li><li>temp.pre.next指向temp.next</li><li>temp.next指向temp.pre</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      BidirectionalList bidirectionalList = <span class="hljs-keyword">new</span> BidirectionalList();      bidirectionalList.addNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>));      bidirectionalList.addNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">2</span>, <span class="hljs-string">"Lulu"</span>));      bidirectionalList.traverseNode();      System.out.println();      System.out.println(<span class="hljs-string">"修改节点信息"</span>);      bidirectionalList.changeNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">2</span>, <span class="hljs-string">"Wenwen"</span>));      bidirectionalList.traverseNode();      System.out.println();      <span class="hljs-comment">//删除节点</span>      System.out.println(<span class="hljs-string">"删除节点"</span>);      bidirectionalList.deleteNode(<span class="hljs-keyword">new</span> PersonNode(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>));      bidirectionalList.traverseNode();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirectionalList</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PersonNode head = <span class="hljs-keyword">new</span> PersonNode(-<span class="hljs-number">1</span>, <span class="hljs-string">""</span>);   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断双向链表是否为空</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 判空结果</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> head.next == <span class="hljs-keyword">null</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 添加将诶点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 要被添加的节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(PersonNode node)</span> </span>&#123;      PersonNode temp = head;      <span class="hljs-keyword">if</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;      &#125;      <span class="hljs-comment">//插入在最后一个节点的后面</span>      temp.next = node;      node.front = temp;   &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverseNode</span><span class="hljs-params">()</span> </span>&#123;       System.out.println(<span class="hljs-string">"遍历链表"</span>);      <span class="hljs-keyword">if</span> (isEmpty()) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      PersonNode temp = head.next;      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>) &#123;         System.out.println(temp);         temp = temp.next;      &#125;    &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 修改节点信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 要修改的节点</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeNode</span><span class="hljs-params">(PersonNode node)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      PersonNode temp = head.next;      <span class="hljs-comment">//用于判定是否做了修改</span>      <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">while</span> (temp != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span>(temp.id == node.id) &#123;            <span class="hljs-comment">//匹配到节点，替换节点</span>            temp.front.next = node;            node.next = temp.next;            flag = <span class="hljs-keyword">true</span>;         &#125;         temp = temp.next;      &#125;      <span class="hljs-keyword">if</span>(!flag) &#123;         System.out.println(<span class="hljs-string">"未匹配到改人信息"</span>);      &#125;    &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 要删除的节点</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(PersonNode node)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty())&#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      PersonNode temp = head.next;      <span class="hljs-comment">//查看是否删除成功</span>       <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span>(temp.id == node.id) &#123;            temp.front.next = temp.next;            temp.next = <span class="hljs-keyword">null</span>;            flag = <span class="hljs-keyword">true</span>;         &#125;         temp = temp.next;      &#125;      <span class="hljs-keyword">if</span>(!flag) &#123;         System.out.println(<span class="hljs-string">"未找到该节点"</span>);      &#125;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonNode</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   <span class="hljs-comment">//指向下一个节点</span>   PersonNode next;   <span class="hljs-comment">//指向前一个节点</span>   PersonNode front;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"PersonNode&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;</code></pre><p><strong>输出</strong></p><pre><code class="hljs routeros">遍历链表PersonNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Nyima'</span>&#125;PersonNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Lulu'</span>&#125;修改节点信息遍历链表PersonNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Nyima'</span>&#125;PersonNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Wenwen'</span>&#125;删除节点遍历链表PersonNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'Wenwen'</span>&#125;</code></pre><h2 id="3、循环链表"><a href="#3、循环链表" class="headerlink" title="3、循环链表"></a>3、循环链表</h2><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>单链表的尾节点指向首节点，即可构成循环链表</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200616190405.png" srcset="/img/loading.gif" alt=""></p><h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><p>N个人围成一圈，从第S个开始报数，第M个将被杀掉，最后剩下一个，其余人都将被杀掉，求出被杀顺序</p><ul><li>例如N=6，M=5，S=1，被杀掉的顺序是：6，4，5，2，1，3</li></ul><p><strong>大致思路</strong></p><ul><li><p>遍历链表找到指定位置的节点</p></li><li><p>用一个front保存指定节点的前一个节点，方便删除</p></li><li><p>当count==time时，删除此时正在遍历的节点，放入数组中，<strong>并将count的值初始化</strong></p></li><li><p>用一个变量loopTime记录已经出圈了几个人，<strong>当其等于length时则是最后一个节点</strong>，直接放入数组并返回数即可</p></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;CircularList circularList = <span class="hljs-keyword">new</span> CircularList();AttenderNode node1 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">1</span>);AttenderNode node2 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">2</span>);AttenderNode node3 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">3</span>);AttenderNode node4 = <span class="hljs-keyword">new</span> AttenderNode(<span class="hljs-number">4</span>);circularList.addNode(node1);circularList.addNode(node2);circularList.addNode(node3);circularList.addNode(node4);System.out.println(<span class="hljs-string">"约瑟夫环"</span>);AttenderNode[] arr = circularList.killAttender(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<span class="hljs-keyword">for</span>(AttenderNode node : arr) &#123;System.out.println(node);&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircularList</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AttenderNode head = <span class="hljs-keyword">new</span> AttenderNode(-<span class="hljs-number">1</span>);AttenderNode temp;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(AttenderNode node)</span> </span>&#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;head.next = node;<span class="hljs-keyword">return</span>;&#125;temp = head.next;<span class="hljs-comment">//只有一个节点，还没成环</span><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;temp.next = node;node.next = head.next;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">while</span> (temp.next != head.next) &#123;temp = temp.next;&#125;<span class="hljs-comment">//temp现在为尾节点</span>temp.next = node;<span class="hljs-comment">//node现在为尾节点，将其next指向首节点</span>node.next = head.next;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getListLength</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">//判断是否只有一个节点</span><span class="hljs-keyword">if</span>(head.next.next == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">//节点个数初始为2</span><span class="hljs-keyword">int</span> length = <span class="hljs-number">2</span>;AttenderNode first = head.next;AttenderNode temp = first.next;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//循环了一轮</span><span class="hljs-keyword">if</span>(temp.next.id == first.id) &#123;<span class="hljs-keyword">return</span> length;&#125;temp = temp.next;length++;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 删除指定位置节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> time 次数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> start 开始节点</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> AttenderNode[] killAttender(<span class="hljs-keyword">int</span> time, <span class="hljs-keyword">int</span> start) &#123;<span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"链表为空"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;temp = head.next;<span class="hljs-keyword">int</span> length = getListLength();<span class="hljs-comment">//存放退出队列的节点</span>AttenderNode[] arr = <span class="hljs-keyword">new</span> AttenderNode[length];<span class="hljs-comment">//从start开始计数</span><span class="hljs-keyword">if</span>(start &gt; length) &#123;System.out.println(<span class="hljs-string">"超出链表范围"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;AttenderNode startNode = temp;<span class="hljs-keyword">int</span> count;<span class="hljs-comment">//如果只有一个节点，直接返回</span><span class="hljs-keyword">if</span>(temp.next == <span class="hljs-keyword">null</span>) &#123;arr[<span class="hljs-number">0</span>] = temp;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-comment">//找到开始节点位置</span><span class="hljs-keyword">for</span>(count = <span class="hljs-number">1</span>; count&lt;start; count++) &#123;startNode = startNode.next;&#125;<span class="hljs-comment">//找到start的前一个节点，方便删除操作</span>AttenderNode front = startNode.next;<span class="hljs-keyword">while</span>(front.next != startNode) &#123;front = front.next;&#125;<span class="hljs-comment">//开始选出节点出链表</span>temp = startNode;<span class="hljs-comment">//记录循环次数</span><span class="hljs-keyword">int</span> loopTime = <span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span>(count=<span class="hljs-number">1</span>; count&lt;=time; count++) &#123;<span class="hljs-keyword">if</span>(loopTime == length) &#123;<span class="hljs-comment">//放入最后一个节点</span>arr[index] = temp;<span class="hljs-keyword">return</span> arr;&#125;<span class="hljs-keyword">if</span>(count == time) &#123;arr[index] = temp;front.next = temp.next;index++;loopTime++;<span class="hljs-comment">//初始化，因为在循环开始时还会+1，所以这里初始化为0</span>count = <span class="hljs-number">0</span>;&#125;temp =front.next;&#125;<span class="hljs-keyword">return</span> arr;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AttenderNode</span> </span>&#123;<span class="hljs-keyword">int</span> id;AttenderNode next;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"KillerNode&#123;"</span> +<span class="hljs-string">"id="</span> + id +<span class="hljs-string">'&#125;'</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AttenderNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">约瑟夫环KillerNode&#123;<span class="hljs-attribute">id</span>=4&#125;KillerNode&#123;<span class="hljs-attribute">id</span>=1&#125;KillerNode&#123;<span class="hljs-attribute">id</span>=2&#125;KillerNode&#123;<span class="hljs-attribute">id</span>=3&#125;</code></pre><h1 id="三、栈"><a href="#三、栈" class="headerlink" title="三、栈"></a>三、栈</h1><h2 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h2><ul><li>栈是一个<strong>先入后出</strong>的有序列表</li><li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的<strong>同一端进行</strong>的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶，另一端为固定的一端，称为栈底</li><li>最先放入的元素在栈底，且最后出栈。最后放入的元素在栈顶，且最先出栈</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617090532.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、应用场景"><a href="#2、应用场景" class="headerlink" title="2、应用场景"></a>2、应用场景</h2><ul><li>子程序递归调用。如JVM中的虚拟机栈</li><li>表达式转换（中缀转后缀）与求值</li><li>二叉树的遍历</li><li>图的深度优先遍历</li></ul><h2 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h2><h3 id="用数组实现"><a href="#用数组实现" class="headerlink" title="用数组实现"></a>用数组实现</h3><p><strong>思路</strong></p><ul><li>定义top表示栈顶，初始值为-1</li><li>入栈的操作，先让top++，再放入数组</li><li>出栈操作，先取出元素，在让top–</li><li>top == -1时，栈空</li><li>top == maxSize-1时，栈满</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      ArrayStack stack = <span class="hljs-keyword">new</span> ArrayStack(<span class="hljs-number">5</span>);      <span class="hljs-comment">//压栈</span>      stack.push(<span class="hljs-number">1</span>);      stack.push(<span class="hljs-number">2</span>);      stack.push(<span class="hljs-number">3</span>);      stack.push(<span class="hljs-number">4</span>);      stack.push(<span class="hljs-number">5</span>);      <span class="hljs-comment">//出栈</span>      System.out.println(stack.pop());   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxSize;   <span class="hljs-keyword">int</span>[] stack;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;      <span class="hljs-keyword">this</span>.maxSize = maxSize;      stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-keyword">this</span>.maxSize];      top = -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> top == maxSize-<span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;      <span class="hljs-keyword">if</span>(isFull()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StackOverflowError(<span class="hljs-string">"栈满"</span>);      &#125;      <span class="hljs-comment">//压栈</span>      top++;      stack[top] = i;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(isEmpty()) &#123;         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();      &#125;      <span class="hljs-keyword">int</span> retNum = stack[top];      top--;      <span class="hljs-keyword">return</span> retNum;   &#125;&#125;</code></pre><h2 id="4、应用"><a href="#4、应用" class="headerlink" title="4、应用"></a>4、应用</h2><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><p><strong>思路</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200617103635.png" srcset="/img/loading.gif" alt=""></p><ul><li>准备一个索引index来帮助我们遍历表达式</li><li>如果index位置上的元素是一个数字，就直接入栈</li><li>如果index位置上的元素是一个符号<ul><li>如果符号栈为空，直接入栈</li><li>如果符号栈不为空<ul><li>index位置上的符号的优先级小于或等于栈顶符号的优先级，则弹出两个数栈中的元素和符号栈中的一个符号，并且进行计算。将运算结果放入数栈中，并将index位置上的符号压入符号栈</li><li>index位置上的符号的优先级大于符号栈栈顶符号的优先级，则将该符号压入符号栈</li></ul></li></ul></li><li>当表达式遍历完毕后，就弹出数栈中的2个数字和符号栈中的1个符号进行运算，并将运行结果入栈</li><li>最终数栈中只有一个值，这个值便是运算结果</li><li>注意：<ul><li>读取的是字符，所以存入数字前需要减去0的ASCII码</li><li>如果数字是多位数，需要一直读，读到下一位不是数字为止，然后将读到的字符进行拼接，然后一起压入数栈</li></ul></li></ul><p><strong>代码</strong></p><p>存在的问题：因为栈是用的整型数组，所以计算除法的时候，无法转化成double</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String formula = <span class="hljs-string">"12+3*15+3/3"</span>;<span class="hljs-comment">//索引，用来读取字符串中的元素</span><span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-comment">//保存读取到的数字和符号</span><span class="hljs-keyword">int</span> number1 = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> number2 = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> thisChar = <span class="hljs-string">' '</span>;<span class="hljs-comment">//用于拼接数字</span>StringBuilder spliceNumber = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-comment">//数栈和符号栈</span>ArrayStack2 numberStack = <span class="hljs-keyword">new</span> ArrayStack2(<span class="hljs-number">10</span>);ArrayStack2 operationStack = <span class="hljs-keyword">new</span> ArrayStack2(<span class="hljs-number">10</span>);<span class="hljs-comment">//保存运算结果</span><span class="hljs-keyword">int</span> result;<span class="hljs-comment">//开始读取字符串中的元素</span><span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; formula.length(); index++) &#123;thisChar = formula.charAt(index);<span class="hljs-keyword">if</span> (operationStack.isOperation(thisChar)) &#123;<span class="hljs-keyword">if</span>(operationStack.comparePriority(thisChar)) &#123;operationStack.push(thisChar);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">int</span> popChar = operationStack.pop();number2 = numberStack.pop();number1 = numberStack.pop();<span class="hljs-comment">//获得运算结果</span>result = operationStack.calculation(number1, number2, popChar);operationStack.push(thisChar);numberStack.push(result);&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//如果是数字，就一直读取</span><span class="hljs-keyword">while</span>(thisChar&gt;=<span class="hljs-string">'0'</span> &amp;&amp; thisChar&lt;=<span class="hljs-string">'9'</span>) &#123;<span class="hljs-comment">//可能该数字为多位数，所以不能只存入一位数字</span>spliceNumber.append(thisChar - <span class="hljs-string">'0'</span>);System.out.println(<span class="hljs-string">"拼接字符换 "</span> + spliceNumber);index++;<span class="hljs-comment">//如果已经读了最后一个数字了，就停下来</span><span class="hljs-keyword">if</span>(index &gt;= formula.length()) &#123;<span class="hljs-keyword">break</span>;&#125;thisChar = formula.charAt(index);&#125;<span class="hljs-keyword">int</span> number = Integer.parseInt(spliceNumber.toString());numberStack.push(number);<span class="hljs-comment">//初始化spliceNumber</span>spliceNumber = <span class="hljs-keyword">new</span> StringBuilder();index--;&#125;&#125;<span class="hljs-keyword">while</span>(!operationStack.isEmpty()) &#123;<span class="hljs-keyword">int</span> popChar = operationStack.pop();number2 = numberStack.pop();number1 = numberStack.pop();<span class="hljs-comment">//获得运算结果</span>result = operationStack.calculation(number1, number2, popChar);numberStack.push(result);&#125;System.out.println(numberStack.pop());&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack2</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxSize;<span class="hljs-keyword">int</span>[] stack;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> top;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;<span class="hljs-keyword">this</span>.maxSize = maxSize;stack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-keyword">this</span>.maxSize];top = -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> top == -<span class="hljs-number">1</span>;&#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> top == maxSize - <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<span class="hljs-keyword">if</span> (isFull()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StackOverflowError(<span class="hljs-string">"栈满"</span>);&#125;<span class="hljs-comment">//压栈</span>top++;stack[top] = i;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (isEmpty()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EmptyStackException();&#125;<span class="hljs-keyword">int</span> retNum = stack[top];top--;<span class="hljs-keyword">return</span> retNum;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">traverse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> thiChar : stack) &#123;System.out.println(thiChar);&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断符号的优先级</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 传入运算符</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 返回优先级</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">if</span> (operation == <span class="hljs-string">'*'</span> || operation == <span class="hljs-string">'/'</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operation == <span class="hljs-string">'+'</span> || operation == <span class="hljs-string">'-'</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (operation &gt;= <span class="hljs-string">'0'</span> &amp;&amp; operation &lt;= <span class="hljs-string">'9'</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 比较栈顶元素和传入字符的优先级大小</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 传入字符</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true则是传入字符优先级大于栈顶字符，false反之</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">comparePriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">if</span> (isEmpty()) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-keyword">int</span> priority1 = getPriority(operation);  <span class="hljs-keyword">int</span> priority2 = getPriority(stack[top]);<span class="hljs-keyword">return</span> priority1 &gt; priority2;&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 判断该位置是不是一个符号</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 该位置的符号</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 判断结果</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isOperation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">return</span> operation == <span class="hljs-string">'*'</span> || operation == <span class="hljs-string">'/'</span> || operation == <span class="hljs-string">'-'</span> || operation == <span class="hljs-string">'+'</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number1   第一个运算的数字</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> number2   第二个运算的数字</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operation 运算符</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> number1, <span class="hljs-keyword">int</span> number2, <span class="hljs-keyword">int</span> operation)</span> </span>&#123;<span class="hljs-keyword">switch</span> (operation) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:<span class="hljs-keyword">return</span> number1+number2;<span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:<span class="hljs-keyword">return</span> number1-number2;<span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:<span class="hljs-keyword">return</span> number1*number2;<span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:<span class="hljs-keyword">return</span> number1/number2;<span class="hljs-keyword">default</span>:System.out.println(operation);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"符号读取错误！"</span>);&#125;&#125;&#125;</code></pre><p>结果</p><pre><code class="hljs angelscript"><span class="hljs-number">58</span></code></pre><h2 id="5、中缀转后缀"><a href="#5、中缀转后缀" class="headerlink" title="5、中缀转后缀"></a>5、中缀转后缀</h2><p><strong>后缀表达式</strong>运算方法</p><ul><li><p>从左向右读取表达式</p><ul><li>遇到数字就压入栈中</li><li>遇到运算符就弹出栈顶和次顶元素。用<strong>次顶元素 运算符 栈顶元素</strong>，并将运算结果压入栈中，直到栈为空，最终结果就是运算结果</li></ul></li></ul><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a><strong>设计</strong></h3><p><strong>中缀表达式转后缀表达式</strong></p><ul><li><strong>从左向右</strong>读取中缀表达式，并且创建<strong>栈s</strong>和<strong>队列q</strong></li><li>如果读到的元素的数字，就直接入队放入q中</li><li>如果读到的是<strong>运算符</strong>（运算符判定）<ul><li>如果s为空，则将该运算符压入s</li><li>如果s不为空<ul><li>如果该运算符为<strong>左括号</strong>，则直接压入s</li><li>如果该运算符为<strong>右括号</strong>，则将s中的元素依次出栈并入队到q中，<strong>直到遇见左括号为止</strong>（括号不放入q中）</li><li>如果该运算符的优先级<strong>高于</strong>s栈顶的运算符，则将该元素压入s</li><li>如果该运算符的优先级<strong>小于等于</strong>s栈顶的运算符，则弹出s栈顶的元素，并将其放入q中，该运算符重<strong>新判定</strong>入栈操作（运算符判定步骤）</li></ul></li></ul></li><li>如果中缀表达式已经读取完毕，则将s中的元素依次出栈，放入q中</li><li>q中的元素依次出队，该顺序即为后缀表达式</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/6/17 21:07</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-keyword">static</span> Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-keyword">static</span> Stack&lt;String&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//中缀表达式，加上空格，方便取出</span>      String infixExpression = <span class="hljs-string">"1 + ( ( 2 + 3 ) * 4 ) - 5"</span>;      String[] expressionArr = infixExpression.split(<span class="hljs-string">" "</span>);      <span class="hljs-comment">//用来保存该运算符的类型</span>      <span class="hljs-keyword">int</span> type;      <span class="hljs-comment">//取出的字符串</span>      String element;      <span class="hljs-comment">//弹出栈的字符串</span>      String stackEle;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;expressionArr.length; i++) &#123;         element = expressionArr[i];         type = judgeOperator(element);         <span class="hljs-keyword">if</span>(type == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//数字，直接入队</span>            queue.add(element);         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">1</span>) &#123;            <span class="hljs-comment">//左括号，直接压栈</span>            stack.push(element);         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">3</span>) &#123;            <span class="hljs-comment">//如果右括号，弹出栈顶元素，直到遇见左括号位置再停下来</span>            <span class="hljs-keyword">do</span> &#123;               stackEle = stack.pop();               <span class="hljs-keyword">if</span>(stackEle.equals(<span class="hljs-string">"("</span>)) &#123;                  <span class="hljs-keyword">break</span>;               &#125;               queue.add(stackEle);               <span class="hljs-comment">//弹出栈中的左括号</span>            &#125;<span class="hljs-keyword">while</span> (!stackEle.equals(<span class="hljs-string">"("</span>));         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">if</span>(stack.isEmpty()) &#123;               <span class="hljs-comment">//如果栈为空，直接入栈</span>               stack.push(element);               <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">int</span> priority1 = getPriority(element);            <span class="hljs-comment">//获得栈顶元素，并判断其优先级</span>            stackEle = stack.peek();            <span class="hljs-keyword">int</span> priority2 = getPriority(stackEle);            <span class="hljs-keyword">if</span>(priority2 == <span class="hljs-number">0</span>) &#123;               <span class="hljs-comment">//为左括号，运算符直接入栈</span>               stack.push(element);            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(priority1 &gt; priority2) &#123;               <span class="hljs-comment">//该运算符优先级高于栈顶元素优先级，则入栈</span>               stack.push(element);            &#125;<span class="hljs-keyword">else</span> &#123;               stackEle = stack.pop();               queue.add(stackEle);               <span class="hljs-comment">//重新判断该运算符</span>               i--;            &#125;         &#125;      &#125;      <span class="hljs-comment">//把最后一个元素出栈并入队</span>      stackEle = stack.pop();      queue.add(stackEle);      <span class="hljs-comment">//保存队列长度，因为出队过程中队列的长度会被改变</span>      <span class="hljs-keyword">int</span> length = queue.size();      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         element = queue.remove();         System.out.print(element);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断该运算符是不是加减乘除</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> operation 运算符</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> true则该运算符为加减乘除</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">firstJudge</span><span class="hljs-params">(String operation)</span> </span>&#123;      <span class="hljs-keyword">return</span> operation.equals(<span class="hljs-string">"*"</span>) || operation.equals(<span class="hljs-string">"/"</span>) || operation.equals(<span class="hljs-string">"+"</span>) || operation.equals(<span class="hljs-string">"-"</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断该字符串的类型</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> operation 要判断的字符串</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 3-&gt;右括号 2-&gt;加减乘除运算符 1-&gt;左括号</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">judgeOperator</span><span class="hljs-params">(String operation)</span> </span>&#123;      <span class="hljs-keyword">if</span>(operation.equals(<span class="hljs-string">")"</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;      &#125;      <span class="hljs-keyword">if</span>(firstJudge(operation)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;      &#125;      <span class="hljs-keyword">if</span>(operation.equals(<span class="hljs-string">"("</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断运算符优先级</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> operator 要判断的运算符</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 2代表乘除，1代表加减，0代表左括号</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">(String operator)</span> </span>&#123;      <span class="hljs-keyword">if</span>(operator.equals(<span class="hljs-string">"*"</span>) || operator.equals(<span class="hljs-string">"/"</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;      &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operator.equals(<span class="hljs-string">"+"</span>) || operator.equals(<span class="hljs-string">"-"</span>)) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125;   &#125;&#125;</code></pre><p>结果</p><pre><code class="hljs angelscript"><span class="hljs-number">123</span>+<span class="hljs-number">4</span>*+<span class="hljs-number">5</span>-</code></pre><h1 id="四、递归"><a href="#四、递归" class="headerlink" title="四、递归"></a>四、递归</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p> <strong>递归就是方法自己调用自己</strong>,每次调用时<strong>传入不同的变量</strong>.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。并且递归用到了<strong>虚拟机栈</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618210040.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、能解决的问题"><a href="#2、能解决的问题" class="headerlink" title="2、能解决的问题"></a>2、能解决的问题</h2><p><strong>数学问题</strong></p><ul><li>八皇后问题</li><li>汉诺塔</li><li>求阶乘</li><li>迷宫问题</li><li>球和篮子</li></ul><p><strong>各种排序算法</strong></p><h2 id="3、规则"><a href="#3、规则" class="headerlink" title="3、规则"></a>3、规则</h2><ul><li><p>方法的变量是独立的，不会相互影响的</p></li><li><p>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据</p></li><li><p>递归<strong>必须向退出递归的条件逼近</strong>，否则就是无限递归，出现 StackOverflowError</p></li><li><p>当一个方法执行完毕，或者遇到 return，就会返回，<strong>遵守谁调用，就将结果返回给谁</strong>，同时当方法执行完毕或</p><p> 者返回时，该方法也就执行完毕</p></li></ul><h2 id="4、迷宫问题"><a href="#4、迷宫问题" class="headerlink" title="4、迷宫问题"></a>4、迷宫问题</h2><p><strong>思路</strong></p><ul><li>用一个二维矩阵代表地图<ul><li>1代表边界</li><li>0代表未做过该地点</li><li>2代表走过且能走得通</li><li>3代表走过但走不通</li></ul></li><li>设置起点和终点以及每个地点的<strong>行走策略</strong><ul><li>行走策略指<strong>在该点所走的方向的顺序</strong>，如 右-&gt;下-&gt;左-&gt;上（调用寻找路径的方法，使用递归）</li></ul></li><li>每次行走时假设该点能够走通，然后按照策略去判断，如果所有策略判断后都走不通，则<strong>该点走不通</strong></li></ul><p><strong>图解</strong></p><p>初始地图</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618223850.png" srcset="/img/loading.gif" alt=""></p><p><strong>行走路径</strong></p><p>策略：右下左上</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200618224021.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//得到地图</span>      <span class="hljs-keyword">int</span> length = <span class="hljs-number">7</span>;      <span class="hljs-keyword">int</span> width = <span class="hljs-number">6</span>;      <span class="hljs-keyword">int</span>[][] map = getMap(length, width);      <span class="hljs-comment">//设置一些障碍</span>      map[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;      map[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;      <span class="hljs-comment">//打印地图</span>      System.out.println(<span class="hljs-string">"地图如下"</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;width; j++) &#123;            System.out.print(map[i][j]+<span class="hljs-string">" "</span>);         &#125;         System.out.println();      &#125;      <span class="hljs-comment">//走迷宫</span>      getWay(map, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">//行走路径</span>      System.out.println(<span class="hljs-string">"行走路径"</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;width; j++) &#123;            System.out.print(map[i][j]+<span class="hljs-string">" "</span>);         &#125;         System.out.println();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 创建地图</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> length 地图的长</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> width 地图的宽</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 创建好的地图</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] getMap(<span class="hljs-keyword">int</span> length, <span class="hljs-keyword">int</span> width) &#123;      <span class="hljs-keyword">int</span>[][] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length][width];      <span class="hljs-comment">//先将第一行和最后一行设置为1（边界）</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;width; i++) &#123;         map[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;         map[length-<span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;      &#125;      <span class="hljs-comment">//再将第一列和最后一列设置为1</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;length; i++) &#123;         map[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;         map[i][width-<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;      &#125;      <span class="hljs-keyword">return</span> map;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 开始走迷宫</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> map 地图</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> i 起点横坐标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> j 七点纵坐标</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 能否走通，true能走通，false反之</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">getWay</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] map, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;      <span class="hljs-keyword">int</span> length= map.length;      <span class="hljs-keyword">int</span> width = map[<span class="hljs-number">0</span>].length;      <span class="hljs-comment">//假设右下角为终点</span>      <span class="hljs-keyword">if</span>(map[length-<span class="hljs-number">2</span>][width-<span class="hljs-number">2</span>] == <span class="hljs-number">2</span>) &#123;         <span class="hljs-comment">//走通了，返回true</span>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span>(map[i][j] == <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">//假设改路能走通</span>            map[i][j] = <span class="hljs-number">2</span>;            <span class="hljs-comment">//行走策略 右-&gt;下-&gt;左-&gt;上</span>            <span class="hljs-keyword">if</span>(getWay(map, i, j+<span class="hljs-number">1</span>)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getWay(map, i+<span class="hljs-number">1</span>, j)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getWay(map, i-<span class="hljs-number">1</span>, j)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(getWay(map, i, j-<span class="hljs-number">1</span>)) &#123;               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            &#125;            <span class="hljs-comment">//右下左上都走不通</span>            map[i][j] = <span class="hljs-number">3</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//改路已经被标记过了，不用再走了，直接返回false</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;         &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;&#125;</code></pre><p>运行结果</p><pre><code class="hljs angelscript">地图如下<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> 行走路径<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span></code></pre><h2 id="5、八皇后问题"><a href="#5、八皇后问题" class="headerlink" title="5、八皇后问题"></a>5、八皇后问题</h2><p>八皇后问题，是一个古老而著名的问题，是<strong>回溯算法</strong>的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在 8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都<strong>不能处于同一行、同一列或同一斜线上</strong>，问有多少种摆法(92)。</p><p><strong>思路</strong></p><ul><li><p>将第一个皇后放在第一行第一列</p></li><li><p>将第二个皇后放在第二行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止</p></li><li><p>将第三个皇后放在第三行第一列，判断是否会和其他皇后相互攻击，若会相互攻击，则将其放到第三列、第四列…知道不会相互攻击为止，并<strong>以此类推</strong>，<strong>在摆放的过程中，有可能会改动前面所放的皇后的位置</strong></p></li><li><p>当得到一个正确的解时，就会回溯到上一行，由此来找出第一个皇后在第一行第一列的所有解</p></li><li><p>再将第一个皇后放到第一行第二列，并重复以上四个步骤</p></li><li><p><strong>注意</strong>：</p><ul><li>棋盘本身应该是用二维数组表示，但是应为皇后所在的行数是固定的，所以可以简化为用一个一维数组来表示。其中的值代表皇后所在的列</li><li>数组下标代表皇后所在行数，所以判断是否在同一行列斜线上时，只需要判断是否在同一列和同一斜线上即可</li><li>是否同列判断：值是否相同<ul><li>是否同一斜线：行号-行号是否等于列号-列号，且<strong>列号相减要取绝对值</strong></li></ul></li></ul></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 创建皇后所放位置的数组，数组的下标代表行号，数组中的值代表所在的列号</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;   <span class="hljs-keyword">int</span>  max = <span class="hljs-number">8</span>;   <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[max];   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Demo3 demo = <span class="hljs-keyword">new</span> Demo3();      <span class="hljs-comment">//放入第一个皇后，开始求后面的皇后</span>      demo.check(<span class="hljs-number">0</span>);      System.out.println(<span class="hljs-string">"一共有"</span>+sum+<span class="hljs-string">"种放法"</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 打印数组元素</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length; i++) &#123;         System.out.print(arr[i] + <span class="hljs-string">" "</span>);      &#125;      sum++;      System.out.println();   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 判断该位置的皇后与前面几个是否冲突</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> position 需要判断的皇后的位置</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> true代表冲突，false代表不冲突</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;position; i++) &#123;         <span class="hljs-comment">//如果两个皇后在同一列或者同一斜线，就冲突</span>         <span class="hljs-comment">//因为数组下标代表行数，所以不会存在皇后在同一行</span>         <span class="hljs-comment">//所在行数-所在行数 如果等于 所在列数-所在列数，则两个皇后在同一斜线上</span>         <span class="hljs-keyword">if</span>(arr[i] == arr[position] || (position-i) == Math.abs(arr[position]-arr[i])) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;         &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 检查该皇后应放的位置</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> queen 要检查的皇后</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> queen)</span> </span>&#123;      <span class="hljs-keyword">if</span>(queen == max) &#123;         <span class="hljs-comment">//所有的皇后都放好了，打印并返回</span>         print();         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//把皇后放在每一列上，看哪些不会和之前的冲突</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;max; i++) &#123;         <span class="hljs-comment">//把第queen+1个皇后放在第i列</span>         arr[queen] = i;         <span class="hljs-keyword">if</span>(!judge(queen)) &#123;            <span class="hljs-comment">//不冲突，就去放下一个皇后</span>            check(queen+<span class="hljs-number">1</span>);         &#125;      &#125;   &#125;&#125;</code></pre><p>一共有92种放法，就不一一展示了</p><h1 id="五、排序"><a href="#五、排序" class="headerlink" title="五、排序"></a>五、排序</h1><h2 id="1、常见的排序算法"><a href="#1、常见的排序算法" class="headerlink" title="1、常见的排序算法"></a>1、常见的排序算法</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200619194904.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、算法的时间复杂度"><a href="#2、算法的时间复杂度" class="headerlink" title="2、算法的时间复杂度"></a>2、算法的时间复杂度</h2><h3 id="时间频度和时间复杂度"><a href="#时间频度和时间复杂度" class="headerlink" title="时间频度和时间复杂度"></a>时间频度和时间复杂度</h3><p><strong>时间频度T(n)</strong></p><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中<strong>语句的执行次数成正比例</strong>，哪个算法中语句执行次数多，它花费时间就多。<strong>一个算法中的语句执行次数称为语句频度或时间频度</strong>。记为T(n)。</p><p><strong>时间复杂度O(n)</strong></p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)),称O(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p><p>在T(n)=4n²-2n+2中，就有f(n)=n²，使得T（n)/f(n)的极限值为4，那么O(f(n))，也就是时间复杂度为O(n²)</p><ul><li><p>对于不是只有常数的时间复杂度<strong>忽略时间频度的系数、低次项常数</strong></p></li><li><p>对于只有常数的时间复杂度，将常数看为1</p></li></ul><h3 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h3><h4 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 O(1)"></a>常数阶 O(1)</h4><pre><code class="hljs java"><span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i++;</code></pre><p>无论代码执行了多少行，只要没有循环等复杂的结构，时间复杂度都是O(1)</p><h4 id="对数阶O-log2n"><a href="#对数阶O-log2n" class="headerlink" title="对数阶O(log2n)"></a>对数阶O(log<sub>2</sub>n)</h4><pre><code class="hljs java"><span class="hljs-keyword">while</span>(i&lt;n) &#123;    i = i*<span class="hljs-number">2</span>;&#125;</code></pre><p>此处i并不是依次递增到n，而是每次都以倍数增长。假设循环了x次后i大于n。则2<sup>x</sup> = n，x=log<sub>2</sub>n</p><h4 id="线性阶O-n"><a href="#线性阶O-n" class="headerlink" title="线性阶O(n)"></a>线性阶O(n)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;i++;&#125;</code></pre><p>这其中，循环体中的代码会执行n+1次，时间复杂度为O(n)</p><h4 id="线性对数阶O-nlog2n"><a href="#线性对数阶O-nlog2n" class="headerlink" title="线性对数阶O(nlog2n)"></a>线性对数阶O(nlog<sub>2</sub>n)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;    j = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(j&lt;n) &#123;j = j*<span class="hljs-number">2</span>;&#125;&#125;</code></pre><p>此处外部为一个循环，循环了n次。内部也是一个循环，但内部f循环的时间复杂度是log<sub>2</sub>n</p><p>所以总体的时间复杂度为线性对数阶O(nlog<sub>2</sub>n)</p><h4 id="平方阶O-n2"><a href="#平方阶O-n2" class="headerlink" title="平方阶O(n2)"></a>平方阶O(n<sup>2</sup>)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++) &#123;<span class="hljs-comment">//循环体</span>&#125;&#125;</code></pre><h4 id="立方阶O-n3"><a href="#立方阶O-n3" class="headerlink" title="立方阶O(n3)"></a>立方阶O(n<sup>3</sup>)</h4><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;n; j++) &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k&lt;n; k++) &#123;<span class="hljs-comment">//循环体</span>&#125;&#125;&#125;</code></pre><p>可以看出平方阶、立方阶的复杂度主要是否循环嵌套了几层来决定的</p><h2 id="3、排序算法的时间复杂度"><a href="#3、排序算法的时间复杂度" class="headerlink" title="3、排序算法的时间复杂度"></a>3、排序算法的时间复杂度</h2><table><thead><tr><th>排序算法</th><th>平均时间</th><th>最差时间</th><th>稳定性</th><th>空间复杂度</th><th>备注</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>稳定</td><td>O(1)</td><td>n较小时好</td></tr><tr><td>交换排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(1)</td><td>n较小时好</td></tr><tr><td>选择排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(1)</td><td>n较小时好</td></tr><tr><td>插入排序</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>稳定</td><td>O(1)</td><td>大部分已有序时好</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>稳定</td><td>O(n)</td><td>二维数组（桶）、一维数组（桶中首元素的位置）</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(n<sup>s</sup>)(1&lt;s&lt;2)</td><td>不稳定</td><td>O(1)</td><td>s是所选分组</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(n<sup>2</sup>)</td><td>不稳定</td><td>O(logn)</td><td>n较大时好</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(1)</td><td>n较大时好</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>不稳定</td><td>O(1)</td><td>n较大时好</td></tr></tbody></table><h2 id="4、冒泡排序"><a href="#4、冒泡排序" class="headerlink" title="4、冒泡排序"></a>4、冒泡排序</h2><p><strong>算法步骤</strong></p><ul><li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p></li><li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，<strong>最后的元素会是最大的数</strong>。</p></li><li><p>针对所有的元素重复以上的步骤，<strong>除了最后一个</strong>。</p></li><li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p></li><li><p>一共进行了<strong>数组元素个数-1</strong>次大循环，且每次大循环中需要比较的元素越来越少。</p></li><li><p>优化：如果在某次大循环，发现没有发生交换，则证明已经有序。</p></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>&#125;;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-comment">//定义一个标识，来记录这趟大循环是否发生了交换</span>         <span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">true</span>;         <span class="hljs-comment">//只需要比较前length-i个数</span>         <span class="hljs-comment">//每次排序会确定一个最大的元素</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;arr.length-i; j++) &#123;            <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j+<span class="hljs-number">1</span>]) &#123;               <span class="hljs-keyword">int</span> temp = arr[j];               arr[j] = arr[j+<span class="hljs-number">1</span>];               arr[j+<span class="hljs-number">1</span>] = temp;               <span class="hljs-comment">//发生了交换，标识改为false</span>               flag = <span class="hljs-keyword">false</span>;            &#125;         &#125;         <span class="hljs-comment">//如果这次循环没发生交换，直接停止循环</span>         <span class="hljs-keyword">if</span>(flag) &#123;            <span class="hljs-keyword">break</span>;         &#125;      &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;</code></pre><h2 id="5、选择排序"><a href="#5、选择排序" class="headerlink" title="5、选择排序"></a>5、选择排序</h2><p><strong>算法步骤</strong></p><ul><li><p>遍历整个数组，找到最小（大）的元素，放到数组的起始位置。</p></li><li><p>再遍历剩下的数组，找到剩下元素中的最小（大）元素，放到数组的第二个位置。</p></li><li><p>重复以上步骤，直到排序完成。</p></li><li><p>一共需要遍历数组元素个数-1次，当找到第二大（小）的元素时，可以停止。这时最后一个元素必是最大（小）元素。</p></li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-comment">//从第0个元素开始比较，一共循环length-1次，最后一个无须进行排序</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length-<span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//保存最小元素的下标</span><span class="hljs-keyword">int</span> min = i;<span class="hljs-comment">//将该元素与剩下的元素比较，找出最小元素的下标</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j&lt;arr.length; j++) &#123;<span class="hljs-comment">//保存最小元素的下标</span><span class="hljs-keyword">if</span>(arr[j] &lt; arr[min]) &#123;min = j;&#125;&#125;<span class="hljs-comment">//交换元素</span><span class="hljs-comment">//如果不是arr[i]不是最小的元素，就交换</span><span class="hljs-keyword">if</span>(min != i) &#123;<span class="hljs-keyword">int</span> temp;temp = arr[i];arr[i] = arr[min];arr[min] = temp;&#125;&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;System.out.println(i);&#125;&#125;&#125;</code></pre><h2 id="6、插入排序"><a href="#6、插入排序" class="headerlink" title="6、插入排序"></a>6、插入排序</h2><p><strong>算法步骤</strong></p><ul><li>将待排序序列第一个元素看做一个<strong>有序序列</strong>，把第二个元素到最后一个元素当成是<strong>未排序序列</strong>。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;;      <span class="hljs-comment">//从数组的第二个元素开始选择位置插入</span>      <span class="hljs-comment">//因为第一个元素已经放入了有序数组中</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-comment">//保存该位置上元素的值,后面移动元素可能会覆盖该位置上元素的值</span>         <span class="hljs-keyword">int</span> temp = arr[i];         <span class="hljs-comment">//变量j用于遍历前面的有序数组</span>         <span class="hljs-keyword">int</span> j = i;         <span class="hljs-keyword">while</span> (j&gt;<span class="hljs-number">0</span> &amp;&amp; temp&lt;arr[j-<span class="hljs-number">1</span>]) &#123;            <span class="hljs-comment">//如果有序数组中的元素大于temp，则后移一个位置</span>            arr[j] = arr[j-<span class="hljs-number">1</span>];            j--;         &#125;         <span class="hljs-comment">//j选择所指位置就是待插入的位置</span>         <span class="hljs-keyword">if</span>(j != i) &#123;            arr[j] = temp;         &#125;      &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;</code></pre><h2 id="7、希尔排序"><a href="#7、希尔排序" class="headerlink" title="7、希尔排序"></a>7、希尔排序</h2><p><strong>回顾：插入排序存在的问题</strong></p><p>当最后一个元素为整个数组的最小元素时，需要将前面的有序数组中的每个元素都向后移一位，这样是非常花时间的。</p><p>所以有了希尔排序来帮我们将数组从无序变为整体有序再变为有序。</p><p><strong>算法步骤</strong></p><ul><li><p>选择一个增量序列t1（一般是数组长度/2），t2（一般是一个分组长度/2），……，tk，<strong>其中 ti &gt; tj</strong>, tk = 1；</p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序；</p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ul><p><strong>示意图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621122846.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;      <span class="hljs-keyword">int</span> temp;      <span class="hljs-comment">//将数组分为gap组,每个组内部进行插入排序</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> gap = arr.length/<span class="hljs-number">2</span>; gap&gt;<span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;         <span class="hljs-comment">//i用来指向未排序数组的首个元素</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = gap; i&lt;arr.length; i++) &#123;            temp = arr[i];            <span class="hljs-keyword">int</span> j = i;            <span class="hljs-comment">//找到temp应该插入的位置,需要先判断数组是否越界</span>            <span class="hljs-keyword">while</span> (j-gap&gt;=<span class="hljs-number">0</span> &amp;&amp; temp&lt;arr[j-gap]) &#123;               arr[j] = arr[j-gap];               j -= gap;            &#125;            <span class="hljs-keyword">if</span>(j != i) &#123;               arr[j] = temp;            &#125;         &#125;      &#125;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;</code></pre><h2 id="8、快速排序"><a href="#8、快速排序" class="headerlink" title="8、快速排序"></a>8、快速排序</h2><p><strong>算法步骤</strong></p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ul><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">8</span>, <span class="hljs-number">12</span>, <span class="hljs-number">19</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">45</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">4</span>, <span class="hljs-number">11</span>&#125;;      QuickSort sort = <span class="hljs-keyword">new</span> QuickSort();      sort.quickSort(arr);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : arr) &#123;         System.out.println(i);      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuickSort</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 快速排序</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length&lt;=<span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      quickSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> left 左侧开始下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> right 右侧开始下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-comment">//如果分区元素小于等于一个，就返回</span>      <span class="hljs-keyword">if</span>(right-left &lt;= <span class="hljs-number">1</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//得到基数下标</span>      <span class="hljs-keyword">int</span> partition = partition(arr, left, right);      <span class="hljs-comment">//递归左右两个分区,因为每次是以左边的第一个数为基数，所以右边分区递归需要在partition的右侧开始</span>      quickSort(arr, left, partition);      quickSort(arr, partition+<span class="hljs-number">1</span>, right);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 返回基准下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> left 左侧开始下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> right 右侧开始下标</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 中间值的下标</span><span class="hljs-comment">    */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-comment">//以该分区最左边的数为基数</span>      <span class="hljs-keyword">int</span> pivot = arr[left];      <span class="hljs-keyword">while</span>(left &lt; right) &#123;         <span class="hljs-comment">//右边下标开始向左移动，找到小于基数的值时停止</span>         <span class="hljs-keyword">while</span>(right&gt;left &amp;&amp; arr[right] &gt;= pivot) &#123;            right--;         &#125;         <span class="hljs-comment">//交换数值，此时pivot保存了arr[left]的值，所以不会丢失</span>         arr[left] = arr[right];         <span class="hljs-comment">//左边下标开始移动，找到大于基数的值时停止</span>         <span class="hljs-keyword">while</span>(left&lt;right &amp;&amp; arr[left] &lt;= pivot) &#123;            left++;         &#125;         <span class="hljs-comment">//交换数值</span>         arr[right] = arr[left];         <span class="hljs-comment">//基数插入到合适的位置</span>         arr[left] = pivot;      &#125;      <span class="hljs-comment">//返回基数下标</span>      <span class="hljs-keyword">return</span> left;   &#125;&#125;</code></pre><h2 id="9、归并排序"><a href="#9、归并排序" class="headerlink" title="9、归并排序"></a>9、归并排序</h2><p><strong>算法步骤</strong></p><p>归并排序用到了<strong>分而治之</strong>的思想，其难点是<strong>治</strong></p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li>重复上一步 直到<strong>某一指针达到序列尾</strong></li><li>将另一序列剩下的所有元素直接复制到合并序列尾</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621201843.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621201859.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621201925.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621202006.png" srcset="/img/loading.gif" alt=""></p><p><strong>此时第二个序列的指针已经到达末尾，则将第一个序列中剩下的元素全部放入和合并序列末尾</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621202124.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>&#125;;      MergeSort mergeSort = <span class="hljs-keyword">new</span> MergeSort(arr.length);      mergeSort.mergeSort(arr, <span class="hljs-number">0</span>, arr.length-<span class="hljs-number">1</span>);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr) &#123;         System.out.println(a);      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MergeSort</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 临时数组，用于合并时用于存放元素</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">int</span>[] temp;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">()</span> </span>&#123;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span> </span>&#123;      temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 将分解的序列进行合并，合并的同时完成排序</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待合并的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> left 数组左边界</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> right 数组右边界</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-comment">//两个序列的分界点</span>      <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;      <span class="hljs-comment">//temp数组中插入的位置</span>      <span class="hljs-keyword">int</span> tempLeft = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> arrLeft = left;      <span class="hljs-comment">//第二个序列的首元素下标</span>      <span class="hljs-keyword">int</span> arrRight = mid+<span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span>(arrLeft&lt;=mid &amp;&amp; arrRight&lt;=right) &#123;         <span class="hljs-comment">//如果第一个序列的元素小于第二序列的元素，就将其放入temp中</span>         <span class="hljs-keyword">if</span>(arr[arrLeft] &lt;= arr[arrRight]) &#123;            temp[tempLeft] = arr[arrLeft];            arrLeft++;         &#125;<span class="hljs-keyword">else</span> &#123;            temp[tempLeft] = arr[arrRight];            arrRight++;         &#125;         tempLeft++;      &#125;      <span class="hljs-comment">//将不为空的序列中的元素依次放入temp中</span>      <span class="hljs-keyword">while</span> (arrLeft &lt;= mid) &#123;         temp[tempLeft] = arr[arrLeft];         tempLeft++;         arrLeft++;      &#125;      <span class="hljs-keyword">while</span> (arrRight &lt;= right) &#123;         temp[tempLeft] = arr[arrRight];         tempLeft++;         arrRight++;      &#125;      <span class="hljs-comment">//将临时数组中的元素放回数组arr中</span>      tempLeft = <span class="hljs-number">0</span>;      arrLeft = left;      <span class="hljs-keyword">while</span> (arrLeft &lt;= right) &#123;         arr[arrLeft] = temp[tempLeft];         arrLeft++;         tempLeft++;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;      <span class="hljs-keyword">int</span> mid = (left+right)/<span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span>(left &lt; right) &#123;         mergeSort(arr, left, mid);         mergeSort(arr, mid+<span class="hljs-number">1</span>, right);         merge(arr, left, right);      &#125;   &#125;&#125;</code></pre><h2 id="10、基数排序"><a href="#10、基数排序" class="headerlink" title="10、基数排序"></a>10、基数排序</h2><p><strong>算法步骤</strong></p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，<strong>数位较短的数前面补零</strong></li><li>从最低位开始，依次进行一次排序</li><li>从最低位排序一直到最高位（个位-&gt;十位-&gt;百位-&gt;…-&gt;最高位）排序完成以后, 数列就变成一个有序序列</li><li>需要我们获得最大数的位数<ul><li>可以通过将<strong>最大数变为String类型</strong>，再求得它的长度即可</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225309.png" srcset="/img/loading.gif" alt=""></p><p><strong>按照个位，放到对应的桶中</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225354.png" srcset="/img/loading.gif" alt=""></p><p><strong>依次取出，同一个桶中有多个元素的，先放入的先取出</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225456.png" srcset="/img/loading.gif" alt=""></p><p><strong>再按照十位，放到对应的桶中，个位数前面补0</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225609.png" srcset="/img/loading.gif" alt=""></p><p><strong>再依次取出桶中元素</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225802.png" srcset="/img/loading.gif" alt=""></p><p><strong>再按照百位，放到对应的桶中，个位数和十位数前面补0</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225742.png" srcset="/img/loading.gif" alt=""></p><p><strong>再依次取出桶中元素</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225802.png" srcset="/img/loading.gif" alt=""><strong>再按照千位，放到对应的桶中，个位数、十位数和百位数前面补0</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225900.png" srcset="/img/loading.gif" alt=""><strong>当所有的数都在0号桶时，依次取出元素，这时顺序即为排好后的顺序</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200621225954.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">43</span>, <span class="hljs-number">52</span>, <span class="hljs-number">1</span>, <span class="hljs-number">89</span>, <span class="hljs-number">190</span>&#125;;      CardinalitySort cardinalitySort = <span class="hljs-keyword">new</span> CardinalitySort();      cardinalitySort.sort(arr);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a : arr) &#123;         System.out.println(a);      &#125;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CardinalitySort</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 进行基数排序</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序的数组</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-comment">//创建一个二维数组，用于表示桶</span>      <span class="hljs-comment">//桶的个数固定为10个（个位是0~9），最大容量由数组的长度决定</span>      <span class="hljs-keyword">int</span> maxSize = arr.length;      <span class="hljs-keyword">int</span>[][] bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>][maxSize];      <span class="hljs-comment">//用于记录每个桶中有多少个元素</span>      <span class="hljs-keyword">int</span>[] elementCounts = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];      <span class="hljs-comment">//获得该数组中最大元素的位数</span>      <span class="hljs-keyword">int</span> maxDigits = getMaxDigits(arr);      <span class="hljs-comment">//将数组中的元素放入桶中, step是在求数组位数时，需要除以的倍数</span>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> time = <span class="hljs-number">1</span>, step = <span class="hljs-number">1</span>; time&lt;=maxDigits; time++, step *= <span class="hljs-number">10</span>) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length; i++) &#123;            <span class="hljs-comment">//取出所需的位数</span>            <span class="hljs-keyword">int</span> digits = arr[i] / step % <span class="hljs-number">10</span>;            <span class="hljs-comment">//放入到对应的桶中 [digits]代表桶的编号</span>            <span class="hljs-comment">//[elementCounts[digits]]代表放入该桶的位置</span>            bucket[digits][elementCounts[digits]] = arr[i];            <span class="hljs-comment">//桶中元素个数+1</span>            elementCounts[digits]++;         &#125;         <span class="hljs-comment">//将桶中的元素重新放回到数组中</span>         <span class="hljs-comment">//用于记录应该放入原数组的哪个位置</span>         <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;            <span class="hljs-comment">//从桶中按放入顺序依次取出元素，放入原数组</span>            <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;            <span class="hljs-comment">//桶中有元素才取出</span>            <span class="hljs-keyword">while</span> (elementCounts[i] &gt; <span class="hljs-number">0</span>) &#123;               arr[index] = bucket[i][position];               position++;               elementCounts[i]--;               index++;            &#125;         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 得到该数组中最大元素的位数</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待求数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 最大元素的位数</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMaxDigits</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">int</span> max = arr[<span class="hljs-number">0</span>];      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-keyword">if</span>(arr[i] &gt; max) &#123;            max = arr[i];         &#125;      &#125;      <span class="hljs-comment">//将最大值转为字符串，它的长度就是它的位数</span>      <span class="hljs-keyword">int</span> digits = (max + <span class="hljs-string">""</span>).length();      <span class="hljs-keyword">return</span> digits;   &#125;&#125;</code></pre><h2 id="11、堆排序"><a href="#11、堆排序" class="headerlink" title="11、堆排序"></a>11、堆排序</h2><p><strong>基本介绍</strong></p><ul><li><p>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为 <strong>O(nlogn)</strong>，它也是不稳定排序</p></li><li><p>堆是具有以下性质的<strong>完全二叉树</strong>：</p><ul><li>每个结点的值都大于或等于其左右孩子结点的值，称为<strong>大顶堆</strong><ul><li>注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系</li></ul></li><li>每个结点的值都小于或等于其左右孩子结点的值，称为<strong>小顶堆</strong></li></ul></li><li><p>一般升序排序采用大顶堆，降序排列使用小顶堆</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200727191935.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200727191922.png" srcset="/img/loading.gif" alt=""></p><p><strong>排序思路</strong></p><ul><li>堆是一种树结构，但是排序中会将堆进行<strong>顺序存储</strong>（变为数组结构）</li><li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</li><li>将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端</li><li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序</li></ul><p><strong>实现代码</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/7/27 16:19</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>&#125;;      <span class="hljs-comment">//堆排序</span>      heapSort(arr);      System.out.println(<span class="hljs-string">"堆排序后结果"</span>);      System.out.println(Arrays.toString(arr));   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 堆排序（升序排序）</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待排序数组</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--) &#123;         <span class="hljs-comment">//将数组调整为大顶堆，长度为未排序数组的长度</span>         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=arr.length/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>; j&gt;=<span class="hljs-number">0</span>; j--) &#123;            adjustHeap(arr, j, i+<span class="hljs-number">1</span>);         &#125;         <span class="hljs-comment">//调整后，数组首元素就为最大值，与为元素交换</span>         <span class="hljs-keyword">int</span> temp = arr[i];         arr[i] = arr[<span class="hljs-number">0</span>];         arr[<span class="hljs-number">0</span>] = temp;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 将无序数组进行调整，将其调整为大顶堆</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 待调整的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> index 非叶子节点的索引</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> length 待调整数组的长度</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjustHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> length)</span> </span>&#123;      <span class="hljs-comment">//保存非叶子节点的值，最后需要进行交换操作</span>      <span class="hljs-keyword">int</span> temp = arr[index];      <span class="hljs-comment">//进行调整操作</span>      <span class="hljs-comment">//index*2+1代表其左子树</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>; i&lt;length; i = i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//如果存在右子树，且右子树的值大于左子树，就让索引指向其右子树</span>         <span class="hljs-keyword">if</span>(i+<span class="hljs-number">1</span>&lt;length &amp;&amp; arr[i] &lt; arr[i+<span class="hljs-number">1</span>]) &#123;            i++;         &#125;         <span class="hljs-comment">//如果右子树的值大于该节点的值就交换，同时改变索引index的值</span>         <span class="hljs-keyword">if</span>(arr[i] &gt; arr[index]) &#123;            arr[index] = arr[i];            index = i;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">break</span>;         &#125;         <span class="hljs-comment">//调整完成后，将temp放到最终调整后的位置</span>         arr[index] = temp;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">堆排序后结果[<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]</code></pre><h1 id="六、查找"><a href="#六、查找" class="headerlink" title="六、查找"></a>六、查找</h1><h2 id="1、线性查找"><a href="#1、线性查找" class="headerlink" title="1、线性查找"></a>1、线性查找</h2><p>线性查找是一种非常简单的查找方式。查找思路是：从数组的一个元素出发，一个个地和要查找的值进行比较，如果发现有相同的元素就返回该元素的下标。反之返回-1（未找到）</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">55</span>&#125;;      <span class="hljs-keyword">int</span> result = seqSearch(arr, <span class="hljs-number">1</span>);      <span class="hljs-keyword">if</span>(result == -<span class="hljs-number">1</span>) &#123;         System.out.println(<span class="hljs-string">"数组中没有该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"该元素在数组的下标是："</span> + result);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 线性查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 查找的数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 待查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 数字的索引</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">seqSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;arr.length; i++) &#123;         <span class="hljs-keyword">if</span>(arr[i] == num) &#123;            <span class="hljs-keyword">return</span> i;         &#125;      &#125;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;&#125;</code></pre><h2 id="2、二分查找"><a href="#2、二分查找" class="headerlink" title="2、二分查找"></a>2、二分查找</h2><p>进行二分查找的数组必须为<strong>有序数组</strong></p><ul><li>设置一个指向中间元素下标的变量mid，mid=(left + right)/2</li><li>让要查找的元素和数组mid下标的元素进行比较<ul><li>如果查找的元素大于arr[mid]，则left变为mid后面一个元素的下标</li><li>如果查找的元素小于arr[mid]，则right变为mid前一个元素的下标</li><li>如果查找的元素等于arr[mid]，则mid就是要查找元素所在的位置</li></ul></li><li>当left &gt; rigth时，说明元素不在该数组中</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//进行二分查找的数组必须是有序</span>      <span class="hljs-keyword">int</span>[] arr = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>&#125;;      <span class="hljs-keyword">int</span> result = binarySearch(arr, <span class="hljs-number">11</span>);      <span class="hljs-keyword">if</span>(result == -<span class="hljs-number">1</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"该元素的下标是："</span> + result);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 二分查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 要查找的有序数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 要查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 对应数字的下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = arr.length-<span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span>(left &lt;= right) &#123;         <span class="hljs-keyword">int</span> mid = (left + right)/<span class="hljs-number">2</span>;         <span class="hljs-comment">//如果要查找的值大于中间位置的值，说明要查找的值在右边部分</span>         <span class="hljs-keyword">if</span>(arr[mid] &lt; num) &#123;            left = mid + <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; num) &#123;            <span class="hljs-comment">//如果要查找的值小于中间位置的值</span>            <span class="hljs-comment">//说明要查找的值在左边部分</span>            right = mid - <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//找到了该元素</span>            <span class="hljs-keyword">return</span> mid;         &#125;      &#125;      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;   &#125;&#125;</code></pre><p><strong>但是有可能要查找的元素有多个</strong>。这时就需要在找到一个元素后，不要立即返回，而是<strong>扫描其左边和右边的元素</strong>，将所有相同元素的下标保存到一个数组中，然后一起返回</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>&#125;;      <span class="hljs-comment">//进行二分查找的数组必须是有序</span>      Arrays.sort(arr);      List&lt;Integer&gt; result = binarySearch(arr, <span class="hljs-number">11</span>);      <span class="hljs-keyword">if</span>(result.size() == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">for</span>(Integer index : result) &#123;            System.out.println(index);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 二分查找（可以查找重复元素的下标）</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 要查找的有序数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 要查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 保存了所有该值元素所在的位置</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = arr.length-<span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> mid;      <span class="hljs-comment">//用户保存查找值下标</span>      List&lt;Integer&gt; positionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">while</span>(left &lt;= right) &#123;         mid = (left + right)/<span class="hljs-number">2</span>;         <span class="hljs-comment">//如果要查找的值大于中间位置的值，说明要查找的值在右边部分</span>         <span class="hljs-keyword">if</span>(arr[mid] &lt; num) &#123;            left = mid + <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; num) &#123;            <span class="hljs-comment">//如果要查找的值小于中间位置的值</span>            <span class="hljs-comment">//说明要查找的值在左边部分</span>            right = mid - <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//将下标存入到集合中</span>            positionList.add(mid);            <span class="hljs-comment">//用于遍历mid左边的相同元素</span>            <span class="hljs-keyword">int</span> leftIndex = mid - <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(leftIndex &gt; <span class="hljs-number">0</span> &amp;&amp; arr[leftIndex] == num) &#123;               positionList.add(leftIndex);               leftIndex--;            &#125;            <span class="hljs-keyword">int</span> rightIndex = mid + <span class="hljs-number">1</span>;            <span class="hljs-keyword">while</span>(rightIndex &lt; right &amp;&amp; arr[rightIndex] == num) &#123;               positionList.add(rightIndex);               rightIndex++;            &#125;            <span class="hljs-keyword">return</span> positionList;         &#125;      &#125;      <span class="hljs-keyword">return</span> positionList;   &#125;&#125;</code></pre><h2 id="3、插值查找"><a href="#3、插值查找" class="headerlink" title="3、插值查找"></a>3、插值查找</h2><p>在二分查找中，如果我们 要找的元素位于数组的最前端或者最后段，这时的查找效率是很低的。所以在二分查找至上，引入了插值查找，也是一种<strong>基于有序数组</strong>的查找方式</p><p>插值查找与二分查找的区别是：插值查找使用了一种<strong>自适应</strong>算法，用这种算法来计算mid。</p><p>mid的值在两种查找算法中的求法：</p><ul><li>二分查找：mid = (left + right)/2</li><li>插值查找：<strong>mid = left + (right - left) * (num - arr[left]) / (arr[right] - arr[left])</strong><ul><li>其中num为要查找的那个值</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">11</span>, <span class="hljs-number">30</span>&#125;;      <span class="hljs-comment">//进行二分查找的数组必须是有序</span>      Arrays.sort(arr);      List&lt;Integer&gt; result = insertSearch(arr, <span class="hljs-number">30</span>);      <span class="hljs-keyword">if</span>(result.size() == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);      &#125;<span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">for</span>(Integer index : result) &#123;            System.out.println(index);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 插值查找查找（可以查找重复元素的下标）</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> arr 要查找的有序数组</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 要查找的数字</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 保存了所有该值元素所在的位置</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">insertSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> num)</span> </span>&#123;      List&lt;Integer&gt; positionList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> right = arr.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> mid;      <span class="hljs-keyword">while</span>(left&lt;=right) &#123;         <span class="hljs-comment">//插值查找的自适应算法</span>         mid = left+(right-left)*(num-arr[left])/(arr[right]-arr[left]);         <span class="hljs-keyword">if</span>(arr[mid] &gt; num) &#123;            right = mid - <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &lt; num) &#123;            left = mid + <span class="hljs-number">1</span>;         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//找到了该元素的位置</span>            positionList.add(mid);         &#125;         <span class="hljs-comment">//继续查找mid附近值相同的元素</span>         <span class="hljs-keyword">int</span> leftIndex = mid - <span class="hljs-number">1</span>;         <span class="hljs-keyword">while</span>(leftIndex &gt;=<span class="hljs-number">0</span> &amp;&amp; arr[leftIndex] == num) &#123;            positionList.add(leftIndex);            leftIndex++;         &#125;         <span class="hljs-keyword">int</span> rightIndex = mid + <span class="hljs-number">1</span>;         <span class="hljs-keyword">while</span> (rightIndex &lt;= right &amp;&amp; arr[rightIndex] == num) &#123;            positionList.add(rightIndex);            rightIndex++;         &#125;         <span class="hljs-keyword">return</span> positionList;      &#125;      <span class="hljs-keyword">return</span> positionList;   &#125;&#125;</code></pre><h1 id="七、哈希表"><a href="#七、哈希表" class="headerlink" title="七、哈希表"></a>七、哈希表</h1><h2 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h2><p>散列表（Hash table，也叫哈希表），是根据<strong>关键码值</strong>(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715134934.png" srcset="/img/loading.gif" alt=""></p><p>哈希表是一种将<strong>数组与链表相结合</strong>的数据结构</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建学生</span>      Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima"</span>);      Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"Lulu"</span>);      Student student6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-string">"WenWen"</span>);      HashTab hashTab = <span class="hljs-keyword">new</span> HashTab(<span class="hljs-number">5</span>);      hashTab.add(student1);      hashTab.add(student2);      hashTab.add(student6);      hashTab.traverse();      <span class="hljs-comment">//通过id查找学生信息</span>      hashTab.findStuById(<span class="hljs-number">6</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-keyword">int</span> id;    String name;   Student next;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>&#123;   <span class="hljs-keyword">private</span> Student head = <span class="hljs-keyword">new</span> Student(-<span class="hljs-number">1</span>, <span class="hljs-string">""</span>);   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 插入学生信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> student 插入学生的信息</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Student student)</span> </span>&#123;      <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;         head.next = student;         <span class="hljs-keyword">return</span>;      &#125;      Student temp = head.next;      <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;      &#125;      temp.next = student;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 遍历链表</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student temp = head;      <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;         System.out.print(temp + <span class="hljs-string">" "</span>);      &#125;      <span class="hljs-comment">//换行</span>      System.out.println();   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 通过id查找学生信息</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 学生id</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findStuById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">if</span>(head.next == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"链表为空"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student temp = head;      <span class="hljs-keyword">while</span>(temp.next != <span class="hljs-keyword">null</span>) &#123;         temp = temp.next;         <span class="hljs-keyword">if</span>(temp.id == id) &#123;            <span class="hljs-comment">//找到学生，打印学生信息</span>            System.out.println(<span class="hljs-string">"该学生信息："</span> + temp);            <span class="hljs-keyword">return</span>;         &#125;      &#125;      System.out.println(<span class="hljs-string">"未找到该学生信息"</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTab</span> </span>&#123;   <span class="hljs-keyword">private</span> LinkedList[] linkedLists;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashTab</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;      <span class="hljs-keyword">this</span>.size = size;      <span class="hljs-comment">//初始化散列表</span>      linkedLists = <span class="hljs-keyword">new</span> LinkedList[size];      <span class="hljs-comment">//初始化每个链表，不然会抛出空指针异常</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">this</span>.size; i++) &#123;         <span class="hljs-comment">//对每个链表进行初始化操作</span>         linkedLists[i] = <span class="hljs-keyword">new</span> LinkedList();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Student student)</span> </span>&#123;      <span class="hljs-keyword">int</span> hashId = getHash(student.id);      linkedLists[hashId].add(student);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span> ; i&lt;size; i++) &#123;         linkedLists[i].traverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findStuById</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">int</span> hashId = getHash(id);      linkedLists[hashId].findStuById(id);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 散列函数，获得散列值</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 学生的id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 对应的散列值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">return</span> id % size;   &#125;&#125;</code></pre><h1 id="八、树结构"><a href="#八、树结构" class="headerlink" title="八、树结构"></a>八、树结构</h1><h2 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h2><h3 id="为什么需要树"><a href="#为什么需要树" class="headerlink" title="为什么需要树"></a>为什么需要树</h3><ul><li>数组的查找效率高，但是插入效率低。</li><li>链表的插入效率高，查找效率低。</li></ul><p>需要一种数据结构来平衡查找与插入效率，使得查找速度和插入速度都能得到提升，因此有了树这种数据结构。</p><h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135230.png" srcset="/img/loading.gif" alt=""></p><h3 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h3><p>每个节点<strong>最多只能有两个子节点</strong>的一种形式称为二叉树</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135439.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135455.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135512.png" srcset="/img/loading.gif" alt=""></p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>如果该二叉树的所有<strong>叶子节点</strong>都在<strong>最后一层</strong>，并且结点总数= <strong>2<sup>n</sup> -1</strong> , n为层数，则我们称为满二叉树。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135734.png" srcset="/img/loading.gif" alt=""></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>如果该二叉树的所有<strong>叶子节点</strong>都在<strong>最后一层</strong>或者<strong>倒数第二层</strong>，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135950.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200715135917.png" srcset="/img/loading.gif" alt=""></p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p><strong>先遍历父节点</strong>，再遍历左子节点，最后遍历右子节点</p><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>先遍历左子节点，<strong>再遍历父节点</strong>，最后遍历右子节点</p><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>先遍历左子节点，再遍历右子节点，最后<strong>遍历父节点</strong></p><p><strong>可以看出，前中后的区别在于父节点遍历的时机</strong></p><h4 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200725144409.png" srcset="/img/loading.gif" alt=""></p><p><strong>前序遍历结果</strong>：1、2、5、6、3</p><p><strong>中序遍历结果</strong>：5、2、6、1、3</p><p><strong>后序遍历结果</strong>：5、6、2、3、1</p><h4 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h4><p>此代码使用<strong>手动</strong>的方式创建二叉树，使用<strong>递归</strong>的方式遍历二叉树</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建二叉树</span>      BinaryTree binaryTree = <span class="hljs-keyword">new</span> BinaryTree();      <span class="hljs-comment">//手动创建节点，并放入二叉树中</span>      StuNode stu1 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);      StuNode stu2 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);      StuNode stu3 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">3</span>, <span class="hljs-string">"C"</span>);      StuNode stu4 = <span class="hljs-keyword">new</span> StuNode(<span class="hljs-number">4</span>, <span class="hljs-string">"D"</span>);      stu1.setLeft(stu2);      stu1.setRight(stu3);      stu3.setRight(stu4);      binaryTree.setRoot(stu1);      <span class="hljs-comment">//遍历二叉树</span>      binaryTree.preTraverse();      binaryTree.midTraverse();      binaryTree.lastTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryTree</span> </span>&#123;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 根节点</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> StuNode root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(StuNode root)</span> </span>&#123;      <span class="hljs-keyword">this</span>.root = root;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"前序遍历"</span>);         root.preTraverse();         System.out.println();      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"二叉树为空！"</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"中序遍历"</span>);         root.midTraverse();         System.out.println();      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"二叉树为空！"</span>);      &#125;  &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root != <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"后序遍历"</span>);         root.lastTraverse();         System.out.println();      &#125;<span class="hljs-keyword">else</span> &#123;         System.out.println(<span class="hljs-string">"二叉树为空！"</span>);      &#125;  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 二叉树中的一个节点</span><span class="hljs-comment"> * 保存了学生信息和左右孩子信息</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StuNode</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   StuNode left;   StuNode right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StuNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StuNode <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(StuNode left)</span> </span>&#123;      <span class="hljs-keyword">this</span>.left = left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StuNode <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> right;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(StuNode right)</span> </span>&#123;      <span class="hljs-keyword">this</span>.right = right;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"StuNode&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//父节点的位置</span>      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 中序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.midTraverse();      &#125;      <span class="hljs-comment">//父节点的位置</span>      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.midTraverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.lastTraverse();      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.lastTraverse();      &#125;      <span class="hljs-comment">//父节点的位置</span>      System.out.println(<span class="hljs-keyword">this</span>);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">前序遍历StuNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'A'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'B'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;中序遍历StuNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'B'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'A'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;后序遍历StuNode&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'B'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;StuNode&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'A'</span>&#125;</code></pre><h3 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h3><p>前、中、后序查找的思路与遍历相似，当找到对应的元素时，直接返回即可。</p><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建根节点</span>      BinarySearchTree tree = <span class="hljs-keyword">new</span> BinarySearchTree();      <span class="hljs-comment">//手动创建节点</span>      Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);      Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);      Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">"C"</span>);      Student student4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">"D"</span>);      Student student5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>, <span class="hljs-string">"E"</span>);      student1.setLeft(student2);      student1.setRight(student3);      student2.setLeft(student4);      student3.setRight(student5);      <span class="hljs-comment">//指定根节点</span>      tree.setRoot(student1);      <span class="hljs-comment">//查找</span>      tree.preSearch(<span class="hljs-number">3</span>);      tree.midSearch(<span class="hljs-number">4</span>);      tree.lastSearch(<span class="hljs-number">7</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySearchTree</span> </span>&#123;   <span class="hljs-keyword">private</span> Student root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(Student root)</span> </span>&#123;      <span class="hljs-keyword">this</span>.root = root;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"前序查找"</span>);      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"树为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student result = root.preSearch(id);      <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);         System.out.println();         <span class="hljs-keyword">return</span>;      &#125;      System.out.println(result);      System.out.println();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"中序查找"</span>);      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"树为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student result = root.midSearch(id);      <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);         System.out.println();         <span class="hljs-keyword">return</span>;      &#125;      System.out.println(result);      System.out.println();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"后序查找"</span>);      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"树为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      Student result = root.lastSearch(id);      <span class="hljs-keyword">if</span>(result == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该元素"</span>);         System.out.println();         <span class="hljs-keyword">return</span>;      &#125;      System.out.println(result);      System.out.println();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   Student left;   Student right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(Student left)</span> </span>&#123;      <span class="hljs-keyword">this</span>.left = left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> right;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(Student right)</span> </span>&#123;      <span class="hljs-keyword">this</span>.right = right;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 要查找的学生id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 查找到的学生</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">preSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-comment">//如果找到了，就返回</span>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.id == id) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-comment">//在左子树中查找，如果找到了就返回</span>      Student student = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         student = left.preSearch(id);      &#125;      <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> student;      &#125;      <span class="hljs-comment">//在右子树中查找，无论是否找到，都需要返回</span>      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         student = right.preSearch(id);      &#125;      <span class="hljs-keyword">return</span> student;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 中序查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 要查找的学生id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 查找到的学生</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">midSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      Student student = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         student = left.midSearch(id);      &#125;      <span class="hljs-keyword">if</span>(student != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> student;      &#125;      <span class="hljs-comment">//找到了就返回</span>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.id == id) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         student = right.midSearch(id);      &#125;      <span class="hljs-keyword">return</span> student;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 后序查找</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 要查找的学生id</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 查找到的学生</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">lastSearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      Student student = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         student = left.lastSearch(id);      &#125;      <span class="hljs-keyword">if</span>(student !=<span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> student;      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         student = right.lastSearch(id);      &#125;      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.id == id) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-keyword">return</span> student;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">前序查找Student&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'C'</span>&#125;中序查找Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'D'</span>&#125;后序查找未找到该元素</code></pre><h3 id="二叉树的删除"><a href="#二叉树的删除" class="headerlink" title="二叉树的删除"></a>二叉树的删除</h3><h4 id="删除要求"><a href="#删除要求" class="headerlink" title="删除要求"></a>删除要求</h4><ul><li>如果删除的是叶子节点，则直接删除即可</li><li>如果删除的是非叶子节点，则<strong>删除该子树</strong></li></ul><h4 id="删除思路"><a href="#删除思路" class="headerlink" title="删除思路"></a>删除思路</h4><ul><li><p>因为我们的二叉树是<strong>单向的</strong>，所以我们是判断<strong>当前结点的子结点</strong>是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点</p></li><li><p>如果当前结点的<strong>左子结点不为空</strong>，并且左子结点就是要删除结点，就将 <strong>this.left = null</strong>; 并且就返回 (结束递归删除)</p></li><li><p>如果当前结点的<strong>右子结点不为空</strong>，并且右子结点就是要删除结点，就将 <strong>this.right= null</strong> ;并且就返回 (结束递归删除)</p></li><li><p>如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</p></li><li><p>如果 4步也没有删除结点，则应当向右子树进行递归删除</p></li></ul><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//创建根节点</span>      BinaryDeleteTree deleteTree = <span class="hljs-keyword">new</span> BinaryDeleteTree();      <span class="hljs-comment">//手动创建节点</span>      StudentNode student1 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">1</span>, <span class="hljs-string">"A"</span>);      StudentNode student2 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">2</span>, <span class="hljs-string">"B"</span>);      StudentNode student3 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">3</span>, <span class="hljs-string">"C"</span>);      StudentNode student4 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">4</span>, <span class="hljs-string">"D"</span>);      StudentNode student5 = <span class="hljs-keyword">new</span> StudentNode(<span class="hljs-number">5</span>, <span class="hljs-string">"E"</span>);      student1.setLeft(student2);      student1.setRight(student3);      student2.setLeft(student4);      student3.setRight(student5);      <span class="hljs-comment">//指定根节点</span>      deleteTree.setRoot(student1);      <span class="hljs-comment">//删除节点</span>      deleteTree.deleteNode(<span class="hljs-number">3</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinaryDeleteTree</span> </span>&#123;   StudentNode root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(StudentNode root)</span> </span>&#123;      <span class="hljs-keyword">this</span>.root = root;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 删除节点的id</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      System.out.println(<span class="hljs-string">"删除节点"</span>);      <span class="hljs-keyword">if</span>(root.id == id) &#123;         root = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"根节点被删除"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//调用删除方法</span>      root.deleteNode(id);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentNode</span> </span>&#123;   <span class="hljs-keyword">int</span> id;   String name;   StudentNode left;   StudentNode right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-keyword">this</span>.id = id;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;      <span class="hljs-keyword">this</span>.name = name;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StudentNode <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(StudentNode left)</span> </span>&#123;      <span class="hljs-keyword">this</span>.left = left;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> StudentNode <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> right;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(StudentNode right)</span> </span>&#123;      <span class="hljs-keyword">this</span>.right = right;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"StudentNode&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> id 删除节点的id</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;      <span class="hljs-comment">//如果左子树不为空且是要查找的节点，就删除</span>      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span> &amp;&amp; left.id == id) &#123;         left = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"删除成功"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果右子树不为空且是要查找的节点，就删除</span>      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span> &amp;&amp; right.id == id) &#123;         right = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"删除成功"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//左递归，继续查找</span>      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.deleteNode(id);      &#125;      <span class="hljs-comment">//右递归，继续查找</span>      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.deleteNode(id);      &#125;   &#125;&#125;</code></pre><h3 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h3><h4 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a><strong>基本说明</strong></h4><p>从数据存储来看，数组存储方式和树的存储方式可以相互转换，即<strong>数组可以转换成树</strong>，<strong>树也可以转换成数组</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200726130159.png" srcset="/img/loading.gif" alt=""></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>顺序二叉树通常只考虑<strong>完全二叉树</strong></li><li>第 n个元素的<strong>左</strong>子节点为 <strong>2 × n + 1</strong></li><li>第 n个元素的<strong>右</strong>子节点为 <strong>2 × n + 2</strong></li><li>第 n个元素的<strong>父</strong>节点为 <strong>(n-1) ÷2</strong><ul><li>其中<strong>n</strong> 表示二叉树中的第几个元素(从0开始编号)</li></ul></li></ul><p>遍历过程和二叉树的遍历类似，只不过递归的条件有所不同</p><h4 id="实现代码-2"><a href="#实现代码-2" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;      ArrBinaryTree arrBinaryTree = <span class="hljs-keyword">new</span> ArrBinaryTree(arr);      <span class="hljs-comment">//前序遍历</span>      System.out.println(<span class="hljs-string">"数组前序遍历"</span>);      arrBinaryTree.preTraverse();      System.out.println();      <span class="hljs-comment">//中序遍历</span>      System.out.println(<span class="hljs-string">"数组中序遍历"</span>);      arrBinaryTree.midTraverse();      System.out.println();      <span class="hljs-comment">//后序遍历</span>      System.out.println(<span class="hljs-string">"数组后序遍历"</span>);      arrBinaryTree.lastTraverse();      System.out.println();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrBinaryTree</span> </span>&#123;   <span class="hljs-keyword">int</span>[] arr;   <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STEP = <span class="hljs-number">2</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-keyword">this</span>.arr = arr;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 数组的前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      preTraverse(<span class="hljs-number">0</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 数组的前序遍历</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> index 遍历到的数组元素下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"数组为空！"</span>);         <span class="hljs-keyword">return</span>;      &#125;      System.out.print(arr[index] + <span class="hljs-string">" "</span>);      <span class="hljs-comment">//向左递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">1</span> &lt; arr.length) &#123;         preTraverse((index * STEP) + <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">//向右递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">2</span> &lt; arr.length) &#123;         preTraverse((index * STEP) + <span class="hljs-number">2</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">()</span> </span>&#123;      midTraverse(<span class="hljs-number">0</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midTraverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"数组为空!"</span>);      &#125;      <span class="hljs-comment">//左递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">1</span> &lt; arr.length) &#123;         midTraverse((index * STEP) + <span class="hljs-number">1</span>);      &#125;      System.out.print(arr[index] + <span class="hljs-string">" "</span>);      <span class="hljs-comment">//右递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">2</span> &lt; arr.length) &#123;         midTraverse((index * STEP) + <span class="hljs-number">2</span>);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">()</span> </span>&#123;      lastTraverse(<span class="hljs-number">0</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lastTraverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;      <span class="hljs-keyword">if</span>(arr == <span class="hljs-keyword">null</span> || arr.length == <span class="hljs-number">0</span>) &#123;         System.out.println(<span class="hljs-string">"数组为空!"</span>);      &#125;      <span class="hljs-comment">//左递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">1</span> &lt; arr.length) &#123;         lastTraverse((index * STEP) + <span class="hljs-number">1</span>);      &#125;      <span class="hljs-comment">//右递归</span>      <span class="hljs-keyword">if</span>((index * STEP) + <span class="hljs-number">2</span> &lt; arr.length) &#123;         lastTraverse((index * STEP) + <span class="hljs-number">2</span>);      &#125;      System.out.print(arr[index] + <span class="hljs-string">" "</span>);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">数组前序遍历<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> 数组中序遍历<span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">6</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> 数组后序遍历<span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span></code></pre><h3 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>因为一般的二叉树，叶子节点的左右指针都为空，这样就会造成<strong>空间的浪费</strong>。为了减少浪费，便有了线索化二叉树</p><ul><li><p>n个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指针域，存放指向该结点在<strong>某种遍历次序</strong>下的前驱和后继结点的指针</p></li><li><p>这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树</p></li><li><p>根据线索性质的不同，线索二叉树可分为<strong>前序</strong>线索二叉树、<strong>中序</strong>线索二叉树和<strong>后序</strong>线索二叉树三种</p></li><li><p>如果一个节点已经有了左右孩子，那么该节点就不能被线索化了，所以线索化二叉树后，节点的left和right有如下两种情况</p><ul><li>left可能指向的是左孩子，也可能指向的是前驱节点</li><li>right可能指向的是右孩子，也可能指向的是后继节点</li></ul></li></ul><h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><strong>中序线索化前</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200726155144.png" srcset="/img/loading.gif" alt=""></p><p><strong>中序线索化后</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200726155345.png" srcset="/img/loading.gif" alt=""></p><h4 id="实现代码-3"><a href="#实现代码-3" class="headerlink" title="实现代码"></a>实现代码</h4><p><strong>线索化思路</strong></p><ul><li>每个节点需要用两个变量来表示<strong>左右指针的类型</strong>（保存左右子树，还是前驱后继）</li><li>需要用两个变量来表示<strong>当前节点</strong>和当前节点的<strong>前驱节点</strong></li><li>通过将<strong>当前节点的左指针</strong>指向前驱节点，来实现前驱节点的绑定</li><li>通过将<strong>前驱节点的右指针</strong>指向当前节点，来实现后继节点的绑定</li></ul><p><strong>遍历方式</strong></p><ul><li>各个节点可以通过<strong>线性</strong>的方式遍历，无需使用递归的方式遍历</li><li>首先有一个外循环，代替递归操作，循环条件的暂存节点不为空</li><li>第一个内循环用于找到第一个元素，然后打印</li><li>第二个循环用于找到节点的后继元素</li><li>最后将暂存节点令为右孩子</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//初始化节点</span>Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"1"</span>);Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"3"</span>);Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">3</span>, <span class="hljs-string">"6"</span>);Student student4 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">4</span>, <span class="hljs-string">"8"</span>);Student student5 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">5</span>, <span class="hljs-string">"10"</span>);Student student6 = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">6</span>, <span class="hljs-string">"14"</span>);<span class="hljs-comment">//手动创建二叉树</span>ThreadedBinaryTree tree = <span class="hljs-keyword">new</span> ThreadedBinaryTree();student1.setLeft(student2);student1.setRight(student3);student2.setLeft(student4);student2.setRight(student5);student3.setLeft(student6);tree.setRoot(student1);tree.midThreaded();<span class="hljs-comment">//得到第五个节点的前驱节点和后继节点</span>System.out.println(<span class="hljs-string">"第五个节点的前驱节点和后继节点"</span>);System.out.println(student5.getLeft());System.out.println(student5.getRight());<span class="hljs-comment">//遍历线索化二叉树</span>System.out.println(<span class="hljs-string">"遍历线索化二叉树"</span>);tree.midThreadedTraverse();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadedBinaryTree</span> </span>&#123;<span class="hljs-keyword">private</span> Student root;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 指向当前节点的前一个节点</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Student pre;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoot</span><span class="hljs-params">(Student root)</span> </span>&#123;<span class="hljs-keyword">this</span>.root = root;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 中序线索化</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node 当前节点</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midThreaded</span><span class="hljs-params">(Student node)</span> </span>&#123;<span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//左线索化</span>midThreaded(node.getLeft());        <span class="hljs-comment">//线索化当前节点</span><span class="hljs-comment">//如果当前节点的左指针为空，就指向前驱节点，并改变左指针类型</span><span class="hljs-keyword">if</span>(node.getLeft() == <span class="hljs-keyword">null</span>) &#123;node.setLeft(pre);node.setLeftType(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//通过前驱节点来将右指针的值令为后继节点</span><span class="hljs-keyword">if</span>(pre != <span class="hljs-keyword">null</span> &amp;&amp; pre.getRight() == <span class="hljs-keyword">null</span>) &#123;pre.setRight(node);pre.setRightType(<span class="hljs-number">1</span>);&#125;<span class="hljs-comment">//处理一个节点后，让当前节点变为下一个节点的前驱节点</span>pre = node;<span class="hljs-comment">//右线索化</span>midThreaded(node.getRight());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midThreaded</span><span class="hljs-params">()</span> </span>&#123;midThreaded(root);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 遍历线索化后的二叉树</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">midThreadedTraverse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//暂存遍历到的节点</span>Student tempNode = root;<span class="hljs-comment">//非递归的方法遍历，如果tempNode不为空就一直循环</span><span class="hljs-keyword">while</span>(tempNode != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//一直访问二叉树的左子树，直到某个节点的左子树指向前驱节点</span><span class="hljs-keyword">while</span>(tempNode.getLeftType() != <span class="hljs-number">1</span>) &#123;tempNode = tempNode.getLeft();&#125;<span class="hljs-comment">//找到了第一个节点</span>System.out.println(tempNode);<span class="hljs-comment">//再访问该节点的右子树，看是否保存了后继节点</span><span class="hljs-comment">//如果是，则打印该节点的后继节点信息</span><span class="hljs-keyword">while</span>(tempNode.getRightType() == <span class="hljs-number">1</span>) &#123;tempNode = tempNode.getRight();System.out.println(tempNode);&#125;tempNode = tempNode.getRight();&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> Student left;<span class="hljs-keyword">private</span> Student right;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 左、右指针的类型，0--&gt;指向的是左右孩子，1--&gt;指向的是前驱、后续节点</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> leftType = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> rightType = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> id;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getLeft</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeft</span><span class="hljs-params">(Student left)</span> </span>&#123;<span class="hljs-keyword">this</span>.left = left;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getRight</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> right;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRight</span><span class="hljs-params">(Student right)</span> </span>&#123;<span class="hljs-keyword">this</span>.right = right;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLeftType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> leftType;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLeftType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> leftType)</span> </span>&#123;<span class="hljs-keyword">this</span>.leftType = leftType;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRightType</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> rightType;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRightType</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rightType)</span> </span>&#123;<span class="hljs-keyword">this</span>.rightType = rightType;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +<span class="hljs-string">"id="</span> + id +<span class="hljs-string">", name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs routeros">第五个节点的前驱节点和后继节点Student&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'3'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'1'</span>&#125;遍历线索化二叉树Student&#123;<span class="hljs-attribute">id</span>=4, <span class="hljs-attribute">name</span>=<span class="hljs-string">'8'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=2, <span class="hljs-attribute">name</span>=<span class="hljs-string">'3'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=5, <span class="hljs-attribute">name</span>=<span class="hljs-string">'10'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=1, <span class="hljs-attribute">name</span>=<span class="hljs-string">'1'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=6, <span class="hljs-attribute">name</span>=<span class="hljs-string">'14'</span>&#125;Student&#123;<span class="hljs-attribute">id</span>=3, <span class="hljs-attribute">name</span>=<span class="hljs-string">'6'</span>&#125;</code></pre><h2 id="2、树的应用"><a href="#2、树的应用" class="headerlink" title="2、树的应用"></a>2、树的应用</h2><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>详见<a href="http://www.wenwenlulu.cn/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#11%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">排序算法——堆排序</a></p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200727192923.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul><li>给定 n个权值作为 n个叶子结点，构造一棵二叉树，<strong>若该树的带权路径长度(wpl)达到最小</strong>，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)</li><li>哈夫曼树是带权路径长度最短的树，<strong>权值较大的结点离根较近</strong></li></ul><h4 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h4><ul><li><strong>路径和路径长度</strong>：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。<strong>通路中分支的数目称为路径长度</strong>。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为 <strong>L-1</strong></li><li><strong>结点的权及带权路径长度</strong>：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该<strong>结点的权</strong>。<ul><li><strong>结点的带权路径长度为</strong>：从根结点到该结点之间的路径长度与该结点的权的<strong>乘积</strong>（W×L）</li></ul></li><li><strong>树的带权路径长度</strong>：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>（W1×L1+W2×L2…），记为WPL(weighted pathlength) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。</li><li>WPL最小的就是哈夫曼树</li></ul><h4 id="创建思路及图解"><a href="#创建思路及图解" class="headerlink" title="创建思路及图解"></a>创建思路及图解</h4><p><strong>创建思路</strong></p><ul><li>从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树</li><li>取出<strong>根节点权值最小</strong>的两颗二叉树</li><li>组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树<strong>根节点权值的和</strong></li><li>再将这颗新的二叉树，以<strong>根节点的权值大小 再次排序</strong>，不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树</li></ul><p><strong>图解</strong></p><p>以{3, 6, 7, 1, 8, 29, 13}为例</p><p><strong>首先排序</strong>：{1, 3, 6, 7, 8, 13, 29}</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185121.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185142.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185223.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185340.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185434.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729185516.png" srcset="/img/loading.gif" alt=""></p><h4 id="实现代码-4"><a href="#实现代码-4" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">29</span>, <span class="hljs-number">13</span>&#125;;      HuffmanTree huffmanTree = <span class="hljs-keyword">new</span> HuffmanTree();      Node root = huffmanTree.createHuffmanTree(arr);      root.preTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanTree</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;      <span class="hljs-comment">//创建数组用于存放Node</span>      ArrayList&lt;Node&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(arr.length);      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> value : arr) &#123;         nodes.add(<span class="hljs-keyword">new</span> Node(value));      &#125;      <span class="hljs-comment">//对集合中的元素进行排序</span>      Collections.sort(nodes);      <span class="hljs-keyword">while</span>(nodes.size() &gt; <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//左右子树在集合中对应的下标</span>         <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>;         <span class="hljs-keyword">int</span> rightIndex = <span class="hljs-number">1</span>;         <span class="hljs-comment">//取出最小的两个节点</span>         Node leftNode = nodes.get(leftIndex);         Node rightNode = nodes.get(rightIndex);         <span class="hljs-comment">//创建父节点，并创建左右子树</span>         Node parent = <span class="hljs-keyword">new</span> Node(leftNode.value + rightNode.value);         parent.left = leftNode;         parent.right = rightNode;         <span class="hljs-comment">//从集合中移除两个最小的节点，并将父节点放入集合中</span>         nodes.add(parent);         nodes.remove(leftNode);         nodes.remove(rightNode);         <span class="hljs-comment">//再次比较</span>         Collections.sort(nodes);      &#125;      <span class="hljs-comment">//返回根节点</span>      <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Node</span>&gt; </span>&#123;   <span class="hljs-keyword">int</span> value;   Node left;   Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Node&#123;"</span> +            <span class="hljs-string">"value="</span> + value +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 重写比较函数，用于排序</span><span class="hljs-comment">    */</span>   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Node o)</span> </span>&#123;      <span class="hljs-keyword">return</span> value - o.value;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.print(<span class="hljs-keyword">this</span>.value + <span class="hljs-string">" "</span>);      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.left != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.left.preTraverse();      &#125;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.right != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">this</span>.right.preTraverse();      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">前序遍历哈夫曼树<span class="hljs-number">67</span> <span class="hljs-number">29</span> <span class="hljs-number">38</span> <span class="hljs-number">15</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">23</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">13</span></code></pre><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><h4 id="原理及图解"><a href="#原理及图解" class="headerlink" title="原理及图解"></a>原理及图解</h4><p><strong>前缀编码</strong>：任何一个字符的编码，都不会是其它的字符的前缀</p><ul><li>统计需编码的字符串中，各个字符出现的次数：如helloworld<ul><li>h:1 e:1 w:1 r:1 d:1 o:2 l:3</li></ul></li><li>将字符出现的次数作为权值，构建哈弗曼树。如下图</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200728190229.png" srcset="/img/loading.gif" alt=""></p><ul><li>根据哈弗曼树进行编码，向左的路径为0，向右的路径为1<ul><li>字符编码结果为：h:000 e:001 w:100 d:1010 r:1011 l:11 o:01</li><li>字符串编码结果为：000001111101100011011111010</li></ul></li></ul><h4 id="实现代码-5"><a href="#实现代码-5" class="headerlink" title="实现代码"></a>实现代码</h4><p>此处代码只实现了哈弗曼树的创建与每个字符的编码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">"helloworld"</span>;      <span class="hljs-comment">//哈夫曼编码</span>      HuffmanCode huffmanCode = <span class="hljs-keyword">new</span> HuffmanCode();      ArrayList&lt;Code&gt; list = huffmanCode.getList(str);      <span class="hljs-comment">//构建哈弗曼树</span>      Code root = huffmanCode.createHuffmanTree(list);      System.out.println(<span class="hljs-string">"前序遍历哈弗曼树"</span>);      root.preTraverse();      <span class="hljs-comment">//进行哈弗曼编码</span>      Map&lt;Byte, String&gt; codeMap = root.getCodeMap();      System.out.println(<span class="hljs-string">"哈弗曼编码"</span>);      System.out.println(codeMap);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuffmanCode</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Code&gt; <span class="hljs-title">getList</span><span class="hljs-params">(String codes)</span> </span>&#123;      <span class="hljs-comment">//得到字符串对应的字节数组</span>      <span class="hljs-keyword">byte</span>[] byteCodes = codes.getBytes();      <span class="hljs-comment">//创建哈希表，用于存放数据及其权值（出现次数）</span>      Map&lt;Byte, Integer&gt; dataAndWight = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">byte</span> b : byteCodes) &#123;         Integer wight = dataAndWight.get(b);         <span class="hljs-comment">//如果还没有该数据，就创建并让其权值为1</span>         <span class="hljs-keyword">if</span>(dataAndWight.get(b) == <span class="hljs-keyword">null</span>) &#123;            dataAndWight.put(b, <span class="hljs-number">1</span>);         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果已经有了该数据，就让其权值加一</span>            dataAndWight.put(b, wight+<span class="hljs-number">1</span>);         &#125;      &#125;      <span class="hljs-comment">//创建List，用于返回</span>      ArrayList&lt;Code&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      <span class="hljs-comment">//遍历哈希表，放入List集合中</span>      <span class="hljs-keyword">for</span>(Map.Entry&lt;Byte, Integer&gt; entry : dataAndWight.entrySet()) &#123;         list.add(<span class="hljs-keyword">new</span> Code(entry.getKey(), entry.getValue()));      &#125;      <span class="hljs-keyword">return</span> list;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Code <span class="hljs-title">createHuffmanTree</span><span class="hljs-params">(ArrayList&lt;Code&gt; lists)</span> </span>&#123;      <span class="hljs-keyword">int</span> leftIndex = <span class="hljs-number">0</span>;      <span class="hljs-keyword">int</span> rightIndex = <span class="hljs-number">1</span>;      <span class="hljs-comment">//根据权值进行排序</span>      Collections.sort(lists);      <span class="hljs-keyword">while</span> (lists.size() &gt; <span class="hljs-number">1</span>) &#123;         Code leftCode = lists.get(leftIndex);         Code rightCode = lists.get(rightIndex);         Code parent = <span class="hljs-keyword">new</span> Code(<span class="hljs-keyword">null</span>,leftCode.weight + rightCode.weight);         parent.left = leftCode;         parent.right = rightCode;         lists.add(parent);         lists.remove(leftCode);         lists.remove(rightCode);         <span class="hljs-comment">//再次排序</span>         Collections.sort(lists);      &#125;      <span class="hljs-keyword">return</span> lists.get(<span class="hljs-number">0</span>);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Code</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Code</span>&gt; </span>&#123;   Byte data;   <span class="hljs-keyword">int</span> weight;   Code left;   Code right;   <span class="hljs-keyword">private</span> Map&lt;Byte, String&gt; codeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Code</span><span class="hljs-params">(Byte data, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;      <span class="hljs-keyword">this</span>.data = data;      <span class="hljs-keyword">this</span>.weight = weight;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Code&#123;"</span> +            <span class="hljs-string">"data="</span> + data +            <span class="hljs-string">", weight="</span> + weight +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span>(left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span>(right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;Byte, String&gt; <span class="hljs-title">getCodeMap</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> getCode(<span class="hljs-keyword">this</span>, <span class="hljs-string">""</span>, <span class="hljs-keyword">new</span> StringBuilder());   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 对哈弗曼树中的叶子节点进行编码</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 根节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> code 左子树为0，右子树为1</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> stringBuilder 用于拼接的字符串</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;Byte, String&gt; <span class="hljs-title">getCode</span><span class="hljs-params">(Code node, String code, StringBuilder stringBuilder)</span> </span>&#123;      <span class="hljs-comment">//新建拼接路径</span>      StringBuilder appendCode = <span class="hljs-keyword">new</span> StringBuilder(stringBuilder);      appendCode.append(code);      <span class="hljs-keyword">if</span>(node != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//如果是非叶子结点，就继续向下遍历</span>         <span class="hljs-keyword">if</span>(node.data == <span class="hljs-keyword">null</span>) &#123;            getCode(node.left, <span class="hljs-string">"0"</span>, appendCode);            getCode(node.right, <span class="hljs-string">"1"</span>, appendCode);         &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//如果是叶子节点，就将哈弗曼编码放入哈希表中</span>            codeMap.put(node.data, appendCode.toString());         &#125;      &#125;      <span class="hljs-keyword">return</span> codeMap;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Code o)</span> </span>&#123;      <span class="hljs-keyword">return</span> weight - o.weight;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">前序遍历哈弗曼树Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">10</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">4</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">2</span>&#125;Code&#123;data=<span class="hljs-number">114</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-number">100</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">2</span>&#125;Code&#123;data=<span class="hljs-number">101</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-number">119</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">6</span>&#125;Code&#123;data=<span class="hljs-number">108</span>, weight=<span class="hljs-number">3</span>&#125;Code&#123;data=<span class="hljs-keyword">null</span>, weight=<span class="hljs-number">3</span>&#125;Code&#123;data=<span class="hljs-number">104</span>, weight=<span class="hljs-number">1</span>&#125;Code&#123;data=<span class="hljs-number">111</span>, weight=<span class="hljs-number">2</span>&#125;每个字符对应的哈弗曼编码&#123;<span class="hljs-number">114</span>=<span class="hljs-number">000</span>, <span class="hljs-number">100</span>=<span class="hljs-number">001</span>, <span class="hljs-number">101</span>=<span class="hljs-number">010</span>, <span class="hljs-number">119</span>=<span class="hljs-number">011</span>, <span class="hljs-number">104</span>=<span class="hljs-number">110</span>, <span class="hljs-number">108</span>=<span class="hljs-number">10</span>, <span class="hljs-number">111</span>=<span class="hljs-number">111</span>&#125;</code></pre><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><h4 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><strong>二叉排序树</strong>：BST: (Binary Sort(Search) Tree), 对于二叉排序树的<strong>任何一个非叶子节点</strong>，要求<strong>左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</strong></p><ul><li><strong>特别说明</strong>：如果有相同的值，可以将该节点放在左子节点或右子节点</li></ul><p> 比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200729161543.png" srcset="/img/loading.gif" alt=""></p><h4 id="操作思路"><a href="#操作思路" class="headerlink" title="操作思路"></a>操作思路</h4><p><strong>添加</strong></p><ul><li>根据插入节点的值来寻找其应该插入的位置</li><li>新插入的节点都是<strong>叶子节点</strong></li></ul><p><strong>删除</strong></p><p>删除<strong>叶子节点</strong>（如删除值为2节点）</p><ul><li>找到待删除的节点</li><li>找到待删除节点的父节点</li><li>判断待删除节点是其<strong>父节点</strong>的左孩子还是右孩子，然后让其令为空</li></ul><p>删除<strong>只有一颗子树的节点</strong>（如删除值为1的节点）</p><ul><li>找到待删除的节点</li><li>找到待删除的节点的父节点</li><li>判断待删除节点是其<strong>父节点</strong>的左孩子还是右孩子</li><li>判断待删除节点的<strong>子树</strong>是其左孩子还是右孩子</li><li>让父节点指向待删除节点的子树指向待删除节点的子树</li></ul><p>删除有<strong>两颗子树的节点</strong>（如删除值为3的节点）</p><ul><li>找到待删除的节点</li><li>找到待删除的节点的父节点</li><li>判断待删除节点是其<strong>父节点</strong>的左孩子还是右孩子</li><li>顺着待删除节点的<strong>右子树</strong>，找到一个值最小的节点（该值的大小最接近待删除节点的值）</li><li>让父节点指向待删除节点的子树指向上一步找到的最小的节点</li></ul><p>删除<strong>根节点</strong>（如删除值为7的节点）</p><ul><li>删除根结点的方法和删除有两个子树的方法相似</li><li>找到一个接近根节点值的节点</li><li>删除该节点，将该节点的值赋值给根节点即可</li></ul><h4 id="实现代码-6"><a href="#实现代码-6" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>&#125;;      <span class="hljs-comment">//创建二叉排序树</span>      BinarySortTree binarySortTree = <span class="hljs-keyword">new</span> BinarySortTree();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;         binarySortTree.addNode(<span class="hljs-keyword">new</span> Node(arr[i]));      &#125;      <span class="hljs-comment">//前序遍历</span>      System.out.println(<span class="hljs-string">"前序遍历二叉排序树"</span>);      binarySortTree.preTraverse();      System.out.println();      <span class="hljs-comment">//删除值为5、1、3、10、7的节点</span>      binarySortTree.deleteNode(<span class="hljs-number">2</span>);      binarySortTree.deleteNode(<span class="hljs-number">1</span>);      binarySortTree.deleteNode(<span class="hljs-number">10</span>);      binarySortTree.deleteNode(<span class="hljs-number">7</span>);      System.out.println(<span class="hljs-string">"前序遍历二叉排序树"</span>);      binarySortTree.preTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinarySortTree</span> </span>&#123;   <span class="hljs-keyword">private</span> Node root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-comment">//如果根节点为空，就直接将该节点作为根节点</span>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         root = node;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//否则就插入该节点到对应的位置</span>      root.add(node);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"二叉树为空"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;         root.preTraverse();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getTargetNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"请先创建二叉树"</span>);         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> root.getTargetNode(targetValue);      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getParentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"请先创建二叉树"</span>);         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> root.getParentNode(targetValue);      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 删除节点</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> targetValue 待删除节点的值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"请先创建二叉树"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//找到待删除结点</span>      Node targetNode = getTargetNode(targetValue);      <span class="hljs-keyword">if</span> (targetNode == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"未找到该节点，删除失败"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果只有一个根节点，就删除根节点</span>      <span class="hljs-keyword">if</span>(root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) &#123;         root = <span class="hljs-keyword">null</span>;         System.out.println(<span class="hljs-string">"删除成功"</span>);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//得到其父节点</span>      Node parentNode = getParentNode(targetValue);      <span class="hljs-comment">//如果父节点为空（待删除节点为根节点）</span>      <span class="hljs-keyword">if</span>(parentNode == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">int</span> minValue = getMinValue(targetNode.right);         deleteNode(minValue);         <span class="hljs-comment">//根节点的值令为最接近的值</span>         targetNode.value = minValue;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果待删除节点为叶子节点</span>      <span class="hljs-keyword">if</span> (targetNode.left == <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">if</span> (parentNode.left != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.left == targetNode) &#123;            <span class="hljs-comment">//删除左子树</span>            parentNode.left = <span class="hljs-keyword">null</span>;            System.out.println(<span class="hljs-string">"删除成功"</span>);         &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentNode.right != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.right == targetNode) &#123;            <span class="hljs-comment">//删除右子树</span>            parentNode.right = <span class="hljs-keyword">null</span>;            System.out.println(<span class="hljs-string">"删除成功"</span>);         &#125;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (targetNode.left != <span class="hljs-keyword">null</span> &amp;&amp; targetNode.right != <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">//待删除节点有左右子树</span>         <span class="hljs-comment">//得到并删除待删除节点右子树中值最小的节点</span>         <span class="hljs-keyword">int</span> minValue = getMinValue(targetNode.right);         deleteNode(minValue);         <span class="hljs-comment">//将值最小的节点的值作为新的目标节点</span>         targetNode.value = minValue;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">//待删除节点只有左子树</span>         <span class="hljs-keyword">if</span>(targetNode.left != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span>(parentNode.left != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.left == targetNode) &#123;               parentNode.left = targetNode.left;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentNode.right != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.right == targetNode) &#123;               parentNode.right = targetNode.left;            &#125;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//待删除节点只有右子树</span>            <span class="hljs-keyword">if</span>(parentNode.left != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.left == targetNode) &#123;               parentNode.left = targetNode.right;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parentNode.right != <span class="hljs-keyword">null</span> &amp;&amp; parentNode.right == targetNode) &#123;               parentNode.right = targetNode.right;            &#125;         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 找到以node为根节点的二叉树的最小节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 作为根节点的节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 值最小的节点的值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinValue</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">while</span>(node.left != <span class="hljs-keyword">null</span>) &#123;         node = node.left;      &#125;      <span class="hljs-comment">//返回值最小的节点</span>      <span class="hljs-keyword">return</span> node.value;   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">int</span> value;   Node left;   Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Node&#123;"</span> +            <span class="hljs-string">"value="</span> + value +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 添加节点到二叉排序树的对应位置</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 待插入的节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果该节点的值大待插入节点的值</span>      <span class="hljs-keyword">if</span> (value &gt; node.value) &#123;         <span class="hljs-comment">//如果该节点的左子树为空，就直接插入</span>         <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;            left = node;         &#125; <span class="hljs-keyword">else</span> &#123;            left.add(node);         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;            right = node;         &#125; <span class="hljs-keyword">else</span> &#123;            right.add(node);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 得到目标节点</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> targetValue 目标节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 目标节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getTargetNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-comment">//如果当前节点就是目标节点，就返回</span>      <span class="hljs-keyword">if</span> (value == targetValue) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;      <span class="hljs-comment">//如果当前节点的值大于目标节点，就向左查找，反之向右查找</span>      <span class="hljs-keyword">if</span> (value &gt; targetValue) &#123;         <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> left.getTargetNode(targetValue);         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> right.getTargetNode(targetValue);         &#125;      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 得到目标节点的父节点</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> targetValue 目标节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 目标节点的父节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">getParentNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> targetValue)</span> </span>&#123;      <span class="hljs-comment">//如果左右子树是目标节点，就返回该节点，否则继续向下查找</span>      <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; left.value == targetValue) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span> &amp;&amp; right.value == targetValue) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; value &gt; targetValue) &#123;            <span class="hljs-keyword">return</span> left.getParentNode(targetValue);         &#125;         <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span> &amp;&amp; value &lt;= targetValue) &#123;            <span class="hljs-keyword">return</span> right.getParentNode(targetValue);         &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//没有父节点（根节点）</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;         &#125;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs crmsh">前序遍历二叉排序树<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">7</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">1</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">2</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">5</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">10</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">9</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">12</span>&#125;删除成功删除成功删除成功删除成功前序遍历二叉排序树<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">9</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">3</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">5</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">12</span>&#125;</code></pre><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><h4 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><strong>为什么需要平衡二叉树</strong></p><ul><li>如果由数组{1, 2, 3, 4}来构建一颗二叉排序树，得到的二叉树不仅没有体现其特点，反而还退化成了链表</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730152912.png" srcset="/img/loading.gif" alt=""></p><p><strong>简介</strong></p><ul><li><p>平衡二叉树也叫平衡<strong>二叉搜索树</strong>（Self-balancing binary search tree）又被称为AVL树，可以保证<strong>查询效率较高</strong></p></li><li><p>具有以下特点：</p><ul><li><strong>它是一棵空树</strong>或<strong>它的左右两个子树的高度差的绝对值不超过</strong> <strong>1</strong>，并且<strong>左右两个子树都是一棵平衡二叉树</strong></li><li>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等</li></ul></li><li><p>下图所示的二叉树就是平衡二叉树</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730153215.png" srcset="/img/loading.gif" alt=""></p><h4 id="应用案例——左旋转"><a href="#应用案例——左旋转" class="headerlink" title="应用案例——左旋转"></a>应用案例——左旋转</h4><p>将由数列 {4,3,6,5,7,8}构建的二叉排序树，修改为一颗平衡二叉树</p><p>此处<strong>右子树的高度高于左子树，且差值大于1</strong>，所以需要进行<strong>左旋转</strong>，来降低右子树的高度</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730154440.png" srcset="/img/loading.gif" alt=""></p><p><strong>步骤</strong></p><ul><li>创建一个新节点，值为当前节点的值（4）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730200322.png" srcset="/img/loading.gif" alt=""></p><ul><li>让新节点的左子树指向当前节点的左子树</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730154609.png" srcset="/img/loading.gif" alt=""></p><ul><li>让新节点的右子树指向当前节点的右子树的左子树</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155228.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>将当前节点的值改为其右子树的值</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155216.png" srcset="/img/loading.gif" alt=""></p></li><li><p>将当前节点的右子树变为其右子树的右子树</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155146.png" srcset="/img/loading.gif" alt=""></p><ul><li>让当前节点的左子树指向新节点</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155127.png" srcset="/img/loading.gif" alt=""></p><p><strong>整理后结果</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730155105.png" srcset="/img/loading.gif" alt=""></p><h4 id="应用案例——右旋转"><a href="#应用案例——右旋转" class="headerlink" title="应用案例——右旋转"></a>应用案例——右旋转</h4><p>当一颗二叉排序树的<strong>左子树高度大于右子树高度，且差值大于1</strong>时，需要进行右旋转，来降低左子树的高度</p><p><strong>步骤</strong></p><ul><li>创建一个新节点，其值为当前节点的值</li><li>将新节点的右子树指向当前节点的右子树</li><li>将新节点的左子树指向当前节点的左子树的右子树</li><li>将当前节点的值改为其左子树的值</li><li>将当前节点的左子树指向其左子树的左子树</li><li>将当前节点的右子树指向新节点</li></ul><h4 id="应用案例——双旋转"><a href="#应用案例——双旋转" class="headerlink" title="应用案例——双旋转"></a>应用案例——双旋转</h4><p>某些时候，只进行左旋转或者右旋转，并不能将二叉排序树变为平衡二叉树。这时就需要进行<strong>双旋转</strong>，即<strong>同时进行左旋转和右旋转</strong></p><ul><li>进行左旋转时，如果当前节点右子树的左子树高于其右子树，需要先进行左旋转</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730171100.png" srcset="/img/loading.gif" alt=""></p><ul><li>进行右旋转时，如果当前节点左子树的右子树高于其左子树，需要先进性右旋转</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730171151.png" srcset="/img/loading.gif" alt=""></p><h4 id="实现代码-7"><a href="#实现代码-7" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;;      AVLTree tree = <span class="hljs-keyword">new</span> AVLTree();      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> value : arr) &#123;         tree.addNode(<span class="hljs-keyword">new</span> Node(value));      &#125;      System.out.println(<span class="hljs-string">"左右子树高度差值为 "</span> + tree.getDifference());      System.out.println(<span class="hljs-string">"前序遍历"</span>);      tree.preTraverse();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span> </span>&#123;   <span class="hljs-keyword">private</span> Node root;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNode</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-comment">//如果根节点为空，就直接将该节点作为根节点</span>      <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;         root = node;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//否则就插入该节点到对应的位置</span>      root.add(node);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>) &#123;         System.out.println(<span class="hljs-string">"二叉树为空"</span>);      &#125; <span class="hljs-keyword">else</span> &#123;         root.preTraverse();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 找到以node为根节点的二叉树的最小节点的值</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 作为根节点的节点</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 值最小的节点的值</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMinValue</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">while</span>(node.left != <span class="hljs-keyword">null</span>) &#123;         node = node.left;      &#125;      <span class="hljs-comment">//返回值最小的节点</span>      <span class="hljs-keyword">return</span> node.value;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDifference</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> leftHeight = root.getLeftHeight();      <span class="hljs-keyword">int</span> rightHeight = root.getRightHeight();      <span class="hljs-comment">//返回左右子树高度差值</span>      <span class="hljs-keyword">return</span> Math.abs(leftHeight - rightHeight);   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;   <span class="hljs-keyword">int</span> value;   Node left;   Node right;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;      <span class="hljs-keyword">this</span>.value = value;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">"Node&#123;"</span> +            <span class="hljs-string">"value="</span> + value +            <span class="hljs-string">'&#125;'</span>;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 添加节点到二叉排序树的对应位置</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> node 待插入的节点</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Node node)</span> </span>&#123;      <span class="hljs-keyword">if</span> (node == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果该节点的值大待插入节点的值</span>      <span class="hljs-keyword">if</span> (value &gt; node.value) &#123;         <span class="hljs-comment">//如果该节点的左子树为空，就直接插入</span>         <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span>) &#123;            left = node;         &#125; <span class="hljs-keyword">else</span> &#123;            left.add(node);         &#125;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) &#123;            right = node;         &#125; <span class="hljs-keyword">else</span> &#123;            right.add(node);         &#125;      &#125;      <span class="hljs-comment">//如果右子树高度与左子树高度差值大于一，就进行左旋转</span>      <span class="hljs-keyword">if</span>(getRightHeight() - getLeftHeight() &gt; <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//如果当前节点右子树的左子树高度高于右子树，其右子树先进行右旋转</span>         <span class="hljs-keyword">if</span>(right.getLeftHeight() &gt; right.getRightHeight()) &#123;            right.rightRotate();         &#125;         leftRotate();      &#125;      <span class="hljs-comment">//如果左子树高度与右子树的高度差值大于一，就进行右旋转</span>      <span class="hljs-keyword">if</span>(getLeftHeight() - getRightHeight() &gt; <span class="hljs-number">1</span>) &#123;         <span class="hljs-comment">//如果当前节点左子树的右子树高度高于左子树，其左子树先进行左旋转</span>         <span class="hljs-keyword">if</span>(left.getRightHeight() &gt; left.getLeftHeight()) &#123;            left.leftRotate();         &#125;         rightRotate();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 前序遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preTraverse</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-keyword">this</span>);      <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span>) &#123;         left.preTraverse();      &#125;      <span class="hljs-keyword">if</span> (right != <span class="hljs-keyword">null</span>) &#123;         right.preTraverse();      &#125;   &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">    * 获得该节点为根节点的树的高度</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 高度</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> Math.max(left == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : left.getHeight(), right == <span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : right.getHeight()) + <span class="hljs-number">1</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLeftHeight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> left.getHeight();      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRightHeight</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">if</span>(right == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;      &#125; <span class="hljs-keyword">else</span> &#123;         <span class="hljs-keyword">return</span> right.getHeight();      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 对二叉排序树进行左旋转（右子树高度较高）</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">leftRotate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//创建新节点</span>      Node newNode = <span class="hljs-keyword">new</span> Node(value);      <span class="hljs-comment">//新节点的左子树指向当前节点的左子树</span>      newNode.left = left;      <span class="hljs-comment">//新节点的右子树指向当前节点的右子树的左子树</span>      newNode.right = right.left;      <span class="hljs-comment">//当前节点的值变为其右子树的值</span>      value = right.value;      <span class="hljs-comment">//当前节点的右子树指向其右子树的右子树</span>      right = right.right;      <span class="hljs-comment">//当前节点的左子树指向新节点</span>      left = newNode;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 对二叉树进行右旋转（左子树高度较高）</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rightRotate</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//创建新节点，值为当前节点的值</span>      Node newNode = <span class="hljs-keyword">new</span> Node(value);      <span class="hljs-comment">//新节点的右子树为当前节点的右子树</span>      newNode.right = right;      <span class="hljs-comment">//新节点的左子树为当前节点的左子树的右子树</span>      newNode.left = left.right;      <span class="hljs-comment">//当前节点的值为其左子树的值</span>      value = left.value;      <span class="hljs-comment">//当前节点的左子树为其左子树的左子树</span>      left = left.left;      <span class="hljs-comment">//当前节点的右子树为新节点</span>      right = newNode;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs crmsh">左右子树高度差值为 <span class="hljs-number">0</span>前序遍历<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">8</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">7</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">5</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">10</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">9</span>&#125;<span class="hljs-keyword">Node</span><span class="hljs-title">&#123;value</span>=<span class="hljs-number">11</span>&#125;</code></pre><h2 id="3、多叉树"><a href="#3、多叉树" class="headerlink" title="3、多叉树"></a>3、多叉树</h2><h4 id="基本介绍-3"><a href="#基本介绍-3" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>在二叉树中，每个节点最多有<strong>一个</strong>数据项和<strong>两个</strong>子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</p><p>多叉树通过重新组织节点，<strong>减少树的高度，能对二叉树进行优化</strong></p><h4 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730195237.png" srcset="/img/loading.gif" alt=""></p><p><strong>2-3树是最简单的B树结构，具有以下特点</strong></p><ul><li>2-3树的所有<strong>叶子节点都在同一层</strong>(只要是 B树都满足这个条件)</li><li>有两个子节点的节点叫<strong>二节点</strong>，二节点要么没有子节点，要么有两个子节点</li><li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li><li>2-3树是由<strong>二节点和三节点构成的树</strong>（2和3）</li></ul><p><strong>2-3树插入规则</strong></p><ul><li><p>2-3树的所有<strong>叶子节点都在同一层</strong>.(只要是 B树都满足这个条件)</p></li><li><p>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</p></li><li><p>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</p></li><li><p>当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，<strong>先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面 3个条件</strong></p></li><li><p>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</p><ul><li>左边的子树值小于父节点的值</li><li>中间的子树值在父节点的值之间</li><li>右边子树的值大于父节点的值</li></ul></li></ul><h4 id="B树、B-和B-树"><a href="#B树、B-和B-树" class="headerlink" title="B树、B+和B*树"></a>B树、B+和B*树</h4><p><strong>B树</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730192248.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>B树的阶：节点的<strong>最多子节点个数</strong>。比如 2-3树的阶是3，2-3-4树的阶是4</p></li><li><p>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</p></li><li><p>关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据</p></li><li><p>搜索<strong>有可能在非叶子结点结束</strong></p></li><li><p>其搜索性能等价于在关键字全集内做一次二分查找</p></li></ul><p><strong>B+树</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200730193949.png" srcset="/img/loading.gif" alt=""></p><ul><li>B+树是B树的变体，也是一种多路搜索树</li><li>B+树的搜索与 B树也基本相同，区别是 B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li><li><strong>所有关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫<strong>稠密索引</strong>】），且链表中的关键字(数据)恰好是有序的</li><li><strong>不可能在非叶子结点命中</strong></li><li><strong>非叶子结点</strong>相当于是叶子结点的<strong>索引</strong>（稀疏索引），<strong>叶子结点</strong>相当于是存储（关键字）<strong>数据</strong>的数据层</li><li>更适合文件索引系统</li><li>B树和 B+树各有自己的应用场景，不能说 B+树完全比 B树好，反之亦然</li></ul><p><strong>B*树</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200801002754.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>B*树是 B+树的变体，在 B+树的非根和非叶子结点再增加指向兄弟的指针</p></li><li><p>B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为 2/3，而B+树的块的最低使用率为的1/2</p></li><li><p>从第 1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高</p></li></ul><h1 id="九、图结构"><a href="#九、图结构" class="headerlink" title="九、图结构"></a>九、图结构</h1><h2 id="1、基本介绍-1"><a href="#1、基本介绍-1" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li><p>当我们需要表示<strong>多对多</strong>的关系时，我们就需要<strong>图</strong></p></li><li><p>图是一种<strong>数据结构</strong>，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为<strong>边</strong>。结点也可以称为顶点</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200731153146.png" srcset="/img/loading.gif" alt=""></p><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ul><li>邻接矩阵是表示图形中<strong>顶点之间相邻关系</strong>的矩阵，对于n个顶点的图而言，矩阵是的row和 col表示的是1…n个点</li></ul><p>如上图的邻接矩阵就是</p><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span></code></pre><p>其中0表示没有连接，1表示有连接</p><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><ul><li>邻接矩阵需要为每个顶点都分配 n个边的空间，其实有很多边都是不存在,<strong>会造成空间的一定损失</strong></li><li>邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，<strong>邻接表由数组+链表组成</strong><ul><li>数组的索引代表顶点</li><li>链表中元素的值代表与该顶点相连的顶点的值</li></ul></li></ul><p>如上图的进阶表就是</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200731154231.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、图的创建"><a href="#2、图的创建" class="headerlink" title="2、图的创建"></a>2、图的创建</h2><h3 id="邻接矩阵创建图"><a href="#邻接矩阵创建图" class="headerlink" title="邻接矩阵创建图"></a>邻接矩阵创建图</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">5</span>;      String[] vertex = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;      Graph graph = <span class="hljs-keyword">new</span> Graph(sum);      <span class="hljs-comment">//指明图的顶点</span>      <span class="hljs-keyword">for</span>(String top : vertex) &#123;         graph.insertVertex(top);      &#125;      <span class="hljs-comment">//指明相连的顶点</span>      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">//显示邻接矩阵</span>      System.out.println(<span class="hljs-string">"邻接矩阵"</span>);      graph.showGraph();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;   ArrayList&lt;String&gt; vertexList;   <span class="hljs-keyword">int</span>[][] edges;   <span class="hljs-keyword">int</span> numOfEdges;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span> </span>&#123;      <span class="hljs-comment">//根据顶点总数进行初始化</span>      vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(sum);      edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum][sum];      numOfEdges = <span class="hljs-number">0</span>;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;      vertexList.add(vertex);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;      edges[vertex1][vertex2] = weight;      edges[vertex2][vertex1] = weight;      numOfEdges++;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfEdges</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> numOfEdges;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNumOfVertex</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">return</span> vertexList.size();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWeight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2)</span> </span>&#123;      <span class="hljs-keyword">return</span> edges[vertex1][vertex2];   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] list : edges) &#123;         System.out.println(Arrays.toString(list));      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs json">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>][<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre><h2 id="3、图的遍历"><a href="#3、图的遍历" class="headerlink" title="3、图的遍历"></a>3、图的遍历</h2><p>对该图进行深度优先遍历和广度优先遍历</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200801122515.png" srcset="/img/loading.gif" alt=""></p><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><ul><li>深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点，可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点。</li><li>这样的访问策略是<strong>优先往纵向挖掘深入</strong></li><li>深度优先搜索是一个递归的过程</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>访问初始结点v，并标记结点v为已访问</li><li>查找结点v的第一个邻接结点w</li><li>若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续</li><li>若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）</li><li>查找结点v的w邻接结点的下一个邻接结点，转到步骤 3</li></ul><h4 id="实现代码-8"><a href="#实现代码-8" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">5</span>;String[] vertex = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;Graph graph = <span class="hljs-keyword">new</span> Graph(sum);<span class="hljs-comment">//指明图的顶点</span><span class="hljs-keyword">for</span>(String top : vertex) &#123;graph.insertVertex(top);&#125;<span class="hljs-comment">//指明相连的顶点</span>graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<span class="hljs-comment">//显示邻接矩阵</span>System.out.println(<span class="hljs-string">"邻接矩阵"</span>);graph.showGraph();<span class="hljs-comment">//深度优先遍历</span>System.out.println(<span class="hljs-string">"进行深度优先遍历"</span>);graph.dfs();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;<span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 标记是否访问过该顶点，用于遍历</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isTraversed;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span> </span>&#123;<span class="hljs-comment">//根据顶点总数进行初始化</span>vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(sum);edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum][sum];isTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[sum];numOfEdges = <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;vertexList.add(vertex);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;edges[vertex1][vertex2] = weight;edges[vertex2][vertex1] = weight;numOfEdges++;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] list : edges) &#123;System.out.println(Arrays.toString(list));&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 深度优先遍历</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> vertex 开始顶点下标</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>&#123;<span class="hljs-comment">//被访问过了就返回</span><span class="hljs-keyword">if</span>(isTraversed[vertex]) &#123;<span class="hljs-keyword">return</span>;&#125;System.out.print(vertexList.get(vertex) + <span class="hljs-string">"-&gt;"</span>);<span class="hljs-comment">//标记已被访问</span>isTraversed[vertex] = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//从相邻顶点开始深度优先遍历</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextVertex = vertex+<span class="hljs-number">1</span>; nextVertex&lt;vertexList.size(); nextVertex++) &#123;<span class="hljs-comment">//如果该顶点存在且未被访问，就向下访问</span><span class="hljs-keyword">if</span>(edges[vertex][nextVertex] != <span class="hljs-number">0</span> &amp;&amp; !isTraversed[nextVertex] ) &#123;dfs(nextVertex);&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//对未被访问的顶点都进行深度优先遍历</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;vertexList.size(); i++) &#123;<span class="hljs-keyword">if</span>(!isTraversed[i]) &#123;dfs(i);&#125;&#125;&#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">邻接矩阵[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>][<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]进行深度优先遍历A-&gt;B-&gt;C-&gt;E-&gt;D-&gt;</code></pre><h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><ul><li>类似于一个<strong>分层搜索</strong>的过程，广度优先遍历需要使用一个<strong>队列</strong>以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点</li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>访问初始结点 v并标记结点 v为已访问</li><li>结点v入队列</li><li>当队列非空时，继续执行，否则算法结束</li><li>出队列，取得队头结点u</li><li>查找结点 u的第一个邻接结点 w。</li><li>若结点 u的邻接结点 w不存在，则转到步骤 3；否则循环执行以下三个步骤：<ul><li>若结点 w尚未被访问，则访问结点 w并标记为已访问</li><li>结点 w入队列</li><li>查找结点 u的继 w邻接结点后的下一个邻接结点 w，转到步骤6</li></ul></li></ul><h4 id="实现代码-9"><a href="#实现代码-9" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> sum = <span class="hljs-number">5</span>;      String[] vertex = &#123;<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>, <span class="hljs-string">"D"</span>, <span class="hljs-string">"E"</span>&#125;;      Graph graph = <span class="hljs-keyword">new</span> Graph(sum);      <span class="hljs-comment">//指明图的顶点</span>      <span class="hljs-keyword">for</span>(String top : vertex) &#123;         graph.insertVertex(top);      &#125;      <span class="hljs-comment">//指明相连的顶点</span>      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);      graph.insertEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);      <span class="hljs-comment">//显示邻接矩阵</span>      System.out.println(<span class="hljs-string">"邻接矩阵"</span>);      graph.showGraph();      <span class="hljs-comment">//广度优先遍历</span>      System.out.println(<span class="hljs-string">"进行广度优先遍历"</span>);      graph.bfs();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span> </span>&#123;   <span class="hljs-keyword">private</span> ArrayList&lt;String&gt; vertexList;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] edges;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numOfEdges;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 标记是否访问过该顶点，用于遍历</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] isTraversed;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 用于保存访问过的顶点</span><span class="hljs-comment">    */</span>   <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Graph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sum)</span> </span>&#123;      <span class="hljs-comment">//根据顶点总数进行初始化</span>      vertexList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(sum);      edges = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum][sum];      isTraversed = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[sum];      numOfEdges = <span class="hljs-number">0</span>;      queue = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertVertex</span><span class="hljs-params">(String vertex)</span> </span>&#123;      vertexList.add(vertex);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex1, <span class="hljs-keyword">int</span> vertex2, <span class="hljs-keyword">int</span> weight)</span> </span>&#123;      edges[vertex1][vertex2] = weight;      edges[vertex2][vertex1] = weight;      numOfEdges++;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showGraph</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] list : edges) &#123;         System.out.println(Arrays.toString(list));      &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 广度优先遍历</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> vertex 遍历顶点的下标</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vertex)</span> </span>&#123;      <span class="hljs-comment">//未被访问，打印顶点信息</span>      <span class="hljs-keyword">if</span>(!isTraversed[vertex]) &#123;         System.out.print(vertexList.get(vertex) + <span class="hljs-string">"-&gt;"</span>);         isTraversed[vertex] = <span class="hljs-keyword">true</span>;      &#125;      <span class="hljs-comment">//继续访问相邻元素</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> nextVertex = vertex+<span class="hljs-number">1</span>; nextVertex &lt; vertexList.size(); nextVertex++) &#123;         <span class="hljs-comment">//如果存在且未被访问</span>         <span class="hljs-keyword">if</span>(edges[vertex][nextVertex] != <span class="hljs-number">0</span> &amp;&amp; !isTraversed[nextVertex]) &#123;            <span class="hljs-comment">//打印顶点信息</span>            System.out.print(vertexList.get(nextVertex) + <span class="hljs-string">"-&gt;"</span>);            <span class="hljs-comment">//标记为已访问</span>            isTraversed[nextVertex] = <span class="hljs-keyword">true</span>;            <span class="hljs-comment">//入队</span>            queue.add(nextVertex);         &#125;      &#125;      <span class="hljs-comment">//相邻元素访问完了（广度优先），再让队列中的元素出队，继续访问</span>      <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;         <span class="hljs-comment">//队首元素出队，继续访问</span>         bfs(queue.remove());      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;vertexList.size(); i++) &#123;         <span class="hljs-comment">//未被访问过，就进行广度优先遍历</span>         <span class="hljs-keyword">if</span>(!isTraversed[i]) &#123;            bfs(i);         &#125;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">邻接矩阵[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>][<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]进行广度优先遍历A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;</code></pre><h1 id="十、算法"><a href="#十、算法" class="headerlink" title="十、算法"></a>十、算法</h1><h2 id="1、分治算法"><a href="#1、分治算法" class="headerlink" title="1、分治算法"></a>1、分治算法</h2><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>分治法是一种很重要的算法。字面上的解释是“分而治之”，就是<strong>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</strong>。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p><strong>分治法在每一层递归上都有三个步骤</strong>：</p><ul><li>分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题</li><li>解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</li><li>合并：将各个子问题的解合并为原问题的解</li></ul><h3 id="应用——汉诺塔"><a href="#应用——汉诺塔" class="headerlink" title="应用——汉诺塔"></a>应用——汉诺塔</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>A、B、C三个塔</p><ul><li>如果只有一个盘，直接A-&gt;C</li><li>如果大于等于两个盘，就分成两部分。<strong>最下面的一个盘为一部分，上面的所有盘为一部分</strong><ul><li>将上面部分的盘A-&gt;B</li><li>最下面的盘A-&gt;C</li><li>再将B中的盘B-&gt;C</li></ul></li></ul><h4 id="实现代码-10"><a href="#实现代码-10" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      hanoiTower(<span class="hljs-number">3</span>, <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>);   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">    * 汉诺塔</span><span class="hljs-comment">    *</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> num 盘的总数</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> a 第一个塔</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> b 第二个塔</span><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> c 第三个塔</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hanoiTower</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">char</span> a, <span class="hljs-keyword">char</span> b, <span class="hljs-keyword">char</span> c)</span> </span>&#123;      <span class="hljs-comment">//如果只有一个盘，把这个盘从A移动到C</span>      <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) &#123;         System.out.println(<span class="hljs-string">"把第"</span> + num + <span class="hljs-string">"个盘从"</span> + a + <span class="hljs-string">"-&gt;"</span> + c);         <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-comment">//如果大于等于两个盘，将上面部分的盘从A借助C移动到B</span>      hanoiTower(num-<span class="hljs-number">1</span>, a, c, b);      <span class="hljs-comment">//把最下面的盘从A移动到C</span>      System.out.println(<span class="hljs-string">"把第"</span> + num + <span class="hljs-string">"个盘从"</span> + a + <span class="hljs-string">"-&gt;"</span> + c);      <span class="hljs-comment">//把上面部分的盘从B借助A移动到C</span>      hanoiTower(num-<span class="hljs-number">1</span>, b, a, c);   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs angelscript">把第<span class="hljs-number">1</span>个盘从A-&gt;C把第<span class="hljs-number">2</span>个盘从A-&gt;B把第<span class="hljs-number">1</span>个盘从C-&gt;B把第<span class="hljs-number">3</span>个盘从A-&gt;C把第<span class="hljs-number">1</span>个盘从B-&gt;A把第<span class="hljs-number">2</span>个盘从B-&gt;C把第<span class="hljs-number">1</span>个盘从A-&gt;C</code></pre><h2 id="2、动态规划"><a href="#2、动态规划" class="headerlink" title="2、动态规划"></a>2、动态规划</h2><h3 id="算法介绍-1"><a href="#算法介绍-1" class="headerlink" title="算法介绍"></a>算法介绍</h3><ul><li>动态规划(Dynamic Programming)算法的核心思想是：将<strong>大问题划分为小问题</strong>进行解决，从而一步步获取最优解的处理算法</li><li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</li><li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到<strong>子问题往往不是互相独立的</strong>。( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li><li>动态规划可以通过<strong>填表</strong>的方式来逐步推进，得到最优解</li></ul><h3 id="算法应用——01背包问题"><a href="#算法应用——01背包问题" class="headerlink" title="算法应用——01背包问题"></a>算法应用——01背包问题</h3><table><thead><tr><th align="center">物品</th><th align="center">重量</th><th align="center">价值</th></tr></thead><tbody><tr><td align="center">吉他</td><td align="center">1</td><td align="center">1500</td></tr><tr><td align="center">音响</td><td align="center">4</td><td align="center">3000</td></tr><tr><td align="center">电脑</td><td align="center">3</td><td align="center">2000</td></tr></tbody></table><p>一个背包最多装4kg的东西，求</p><ul><li>装入物品使得背包的总价值最大，且不超出背包的容量</li><li>要求装入的物品<strong>不能重复</strong>（01背包）</li></ul><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>算法的主要思想，利用动态规划来解决。每次遍历到的第 i个物品，根据 w[i]和 v[i]来确定是否需要将该物品放入背包中。即对于给定的 n个物品，<strong>设 v[i]、w[i]分别为第 i个物品的价值和重量</strong>，C为背包的容量。再令二维数组</p><pre><code class="hljs markdown">v[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>]</code></pre><p>表示在前 i个物品中能够装入容量为 j的背包中的<strong>最大价值</strong>。则我们有下面的结果</p><pre><code class="hljs java"><span class="hljs-comment">//表示填入表的第一行和第一列是 0，主要是为了方便表示物品和容量</span>(<span class="hljs-number">1</span>) v[i][<span class="hljs-number">0</span>]=v[<span class="hljs-number">0</span>][j]=<span class="hljs-number">0</span>; <span class="hljs-comment">// 当准备加入新增的商品的重量大于当前背包的容量时，就直接使用上一个单元格的装入策略（装入物品的价值）</span>(<span class="hljs-number">2</span>) 当 w[i]&gt;j 时：v[i][j]=v[i-<span class="hljs-number">1</span>][j] <span class="hljs-comment">// 当准备加入的新增的商品的容量小于等于当前背包的容量,</span><span class="hljs-comment">// 装入的方式:</span>(<span class="hljs-number">3</span>) 当 j&gt;=w[i]时：v[i][j]=max&#123;v[i-<span class="hljs-number">1</span>][j], v[i]+v[i-<span class="hljs-number">1</span>][j-w[i]]&#125;v[i-<span class="hljs-number">1</span>][j]：上一个装法的总价值v[i] : 表示当前商品的价值v[i-<span class="hljs-number">1</span>][j-w[i]] ： 装入i-<span class="hljs-number">1</span>商品，到剩余空间j-w[i]的总价值</code></pre><p>简单来说：</p><ul><li><p>装入物品的容量大于背包容量时，直接使用之前装入背包物品的最大价值</p></li><li><p>装入物品容量小于等于背包容量时，比较</p><ul><li>装入该物品之前，背包物品的最大价值</li><li>装入该后，该物品的价值+剩余容量能放入物品的最大价值</li></ul><p>选取较大者</p></li></ul><h4 id="实现代码-11"><a href="#实现代码-11" class="headerlink" title="实现代码"></a>实现代码</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//各个物品的重量</span>      <span class="hljs-keyword">int</span>[] weight = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;;      <span class="hljs-comment">//各个物品的价值</span>      <span class="hljs-keyword">int</span>[] value = &#123;<span class="hljs-number">1500</span>, <span class="hljs-number">3000</span>, <span class="hljs-number">2000</span>&#125;;      <span class="hljs-comment">//背包的最大容量</span>      <span class="hljs-keyword">int</span> maxSize = <span class="hljs-number">4</span>;      <span class="hljs-comment">//各种方法的价值的最大值，第0行和第0列值为0，方便后续操作</span>      <span class="hljs-keyword">int</span>[][] maxValue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[value.length+<span class="hljs-number">1</span>][maxSize+<span class="hljs-number">1</span>];      <span class="hljs-comment">//用于表示物品放入背包的方式</span>      <span class="hljs-keyword">int</span>[][] method = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[value.length+<span class="hljs-number">1</span>][maxSize+<span class="hljs-number">1</span>];      <span class="hljs-comment">//依次将物品放入背包</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i&lt;maxValue.length; i++) &#123;         <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j&lt;maxValue[<span class="hljs-number">0</span>].length; j++) &#123;            <span class="hljs-comment">//如果物品的重量大于背包剩余的容量，就不放入</span>            <span class="hljs-comment">//i-1是因为下标是从1开始的，减一后才为0</span>            <span class="hljs-keyword">if</span>(weight[i-<span class="hljs-number">1</span>] &gt; j) &#123;               maxValue[i][j] = maxValue[i-<span class="hljs-number">1</span>][j];            &#125; <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">//背包剩余的容量</span>               <span class="hljs-keyword">int</span> remaining = j - weight[i-<span class="hljs-number">1</span>];               <span class="hljs-comment">//如果放入该物品前的最大价值大于放入该物品后的最大价值，就不放入该物品</span>               <span class="hljs-keyword">if</span>(maxValue[i-<span class="hljs-number">1</span>][j] &gt; value[i-<span class="hljs-number">1</span>]+maxValue[i-<span class="hljs-number">1</span>][remaining]) &#123;                  maxValue[i][j] = maxValue[i-<span class="hljs-number">1</span>][j];               &#125; <span class="hljs-keyword">else</span> &#123;                  maxValue[i][j] = value[i-<span class="hljs-number">1</span>]+maxValue[i-<span class="hljs-number">1</span>][remaining];                  <span class="hljs-comment">//存入放入方法</span>                  method[i][j] = <span class="hljs-number">1</span>;               &#125;            &#125;         &#125;      &#125;      <span class="hljs-comment">//打印放入背包的最大价值</span>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] arr : maxValue) &#123;         System.out.println(Arrays.toString(arr));      &#125;      <span class="hljs-comment">//打印价值最大的放法</span>      <span class="hljs-comment">//存放方法的二维数组的最大下标，从最后开始搜索存放方法</span>      <span class="hljs-keyword">int</span> i = method.length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> j = method[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;      <span class="hljs-keyword">while</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; j &gt; <span class="hljs-number">0</span>) &#123;         <span class="hljs-keyword">if</span>(method[i][j] == <span class="hljs-number">1</span>) &#123;            System.out.println(<span class="hljs-string">"将第"</span> + i + <span class="hljs-string">"个物品放入背包"</span>);            <span class="hljs-comment">//背包剩余容量</span>            j -= weight[i-<span class="hljs-number">1</span>];         &#125;         i--;      &#125;   &#125;&#125;</code></pre><p><strong>运行结果</strong></p><pre><code class="hljs java">[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">3000</span>][<span class="hljs-number">0</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">1500</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">3500</span>]将第<span class="hljs-number">3</span>个物品放入背包将第<span class="hljs-number">1</span>个物品放入背包</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2020/06/08/JVM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/06/08/JVM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p>本博客是根据<a href="https://www.bilibili.com/video/BV1yE411Z7AP" target="_blank" rel="noopener"><strong>解密JVM【黑马程序员出品】</strong></a>教学视频学习时，所做的笔记</p><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" srcset="/img/loading.gif" alt=""></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>每个<strong>线程</strong>运行需要的内存空间，称谓<strong>虚拟机栈</strong></p></li><li><p>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</p></li><li><p>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></p></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;method1();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = a + b;<span class="hljs-keyword">return</span> c;&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" srcset="/img/loading.gif" alt=""></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong>    通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong>  通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" srcset="/img/loading.gif" alt=""></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" srcset="/img/loading.gif" alt=""></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><pre><code class="hljs taggerscript">F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\b</span>in&gt;javac F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.java</code></pre><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><pre><code class="hljs taggerscript">javap -v F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.class</code></pre></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" srcset="/img/loading.gif" alt=""></p></li><li><p>常量池</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" srcset="/img/loading.gif" alt=""></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，<strong>#号的内容需要在常量池中查找</strong>）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是<em>.class文件中的，当该*</em>类被加载以后<strong>，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址变为真实地址**</li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>; String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;&#125;&#125;</code></pre><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><span class="hljs-number">2</span>: astore_1<span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><span class="hljs-number">5</span>: astore_2<span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><span class="hljs-number">8</span>: astore_3<span class="hljs-number">9</span>: <span class="hljs-keyword">return</span></code></pre><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>;String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;<span class="hljs-comment">//拼接字符串对象来创建新的字符串</span>String ab2 = a+b; &#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs angelscript"> Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span>         <span class="hljs-number">2</span>: astore_1         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span>         <span class="hljs-number">5</span>: astore_2         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>         <span class="hljs-number">8</span>: astore_3         <span class="hljs-number">9</span>: new           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>        <span class="hljs-number">12</span>: dup        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder."&lt;init&gt;":()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span>ing;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span></code></pre><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuffer().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><pre><code class="hljs java">String ab = <span class="hljs-string">"ab"</span>;String ab2 = a+b;<span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span>System.out.println(ab == ab2);</code></pre><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>;String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;String ab2 = a+b;<span class="hljs-comment">//使用拼接字符串的方法创建字符串</span>String ab3 = <span class="hljs-string">"a"</span> + <span class="hljs-string">"b"</span>;&#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs angelscript">   Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span>         <span class="hljs-number">2</span>: astore_1         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span>         <span class="hljs-number">5</span>: astore_2         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>         <span class="hljs-number">8</span>: astore_3         <span class="hljs-number">9</span>: new           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>        <span class="hljs-number">12</span>: dup        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder."&lt;init&gt;":()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span>ing;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span>        <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuffer来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);<span class="hljs-comment">//调用str的intern方法，这时串池中没有"ab"，则会将该字符串对象放入到串池中，此时堆内存与串池中的"ab"是同一个对象</span>String st2 = str.intern();<span class="hljs-comment">//给str3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回</span>String str3 = <span class="hljs-string">"ab"</span>;<span class="hljs-comment">//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true</span>System.out.println(str == st2);System.out.println(str == str3);&#125;&#125;</code></pre><p><strong>例2</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//此处创建字符串对象"ab"，因为串池中还没有"ab"，所以将其放入串池中</span>String str3 = <span class="hljs-string">"ab"</span>;        <span class="hljs-comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);        <span class="hljs-comment">//此时因为在创建str3时，"ab"已存在与串池中，所以放入失败，但是会返回串池中的"ab"</span>String str2 = str.intern();        <span class="hljs-comment">//false</span>System.out.println(str == str2);        <span class="hljs-comment">//false</span>System.out.println(str == str3);        <span class="hljs-comment">//true</span>System.out.println(str2 == str3);&#125;&#125;</code></pre><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=xxxx</code></pre><p>​    </p></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" srcset="/img/loading.gif" alt=""></p><p><strong>使用了DirectBuffer</strong> </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" srcset="/img/loading.gif" alt=""></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;</code></pre><p>DirectByteBuffer类</p><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span>       <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();    <span class="hljs-keyword">int</span> ps = Bits.pageSize();    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));    Bits.reserveMemory(size, cap);    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;    <span class="hljs-keyword">try</span> &#123;        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        <span class="hljs-keyword">throw</span> x;    &#125;    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;        <span class="hljs-comment">// Round up to page boundary</span>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        address = base;    &#125;    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span>    att = <span class="hljs-keyword">null</span>;&#125;</code></pre><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();                       &#125;                       System.exit(<span class="hljs-number">1</span>);                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                   &#125;               &#125;);           &#125;</code></pre><p>对应对象的run方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// Paranoia</span>        <span class="hljs-keyword">return</span>;    &#125;    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span>    address = <span class="hljs-number">0</span>;    Bits.unreserveMemory(size, capacity);&#125;</code></pre><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" srcset="/img/loading.gif" alt=""></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" srcset="/img/loading.gif" alt=""></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);&#125;&#125;</code></pre><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span>ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span>Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span>list.remove(poll);<span class="hljs-comment">//移动到引用队列中的下一个元素</span>poll = queue.poll();&#125;&#125;&#125;</code></pre><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li><p>软引用和弱引用<strong>可以配合</strong>引用队列</p><ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li><p>虚引用和终结器引用<strong>必须配合</strong>引用队列</p><ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" srcset="/img/loading.gif" alt=""></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" srcset="/img/loading.gif" alt=""></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" srcset="/img/loading.gif" alt=""></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" srcset="/img/loading.gif" alt=""></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" srcset="/img/loading.gif" alt=""></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" srcset="/img/loading.gif" alt=""></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" srcset="/img/loading.gif" alt=""></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" srcset="/img/loading.gif" alt=""></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" srcset="/img/loading.gif" alt=""></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" srcset="/img/loading.gif" alt=""></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel  Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li><p>多线程</p></li><li><p>堆内存较大，多核CPU</p></li><li><p>尽可能让单次STW时间变短（尽量不影响其他线程运行）</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" srcset="/img/loading.gif" alt=""></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>一种以获取<strong>最短回收停顿时间</strong>为目标的收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p> CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" srcset="/img/loading.gif" alt=""></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" srcset="/img/loading.gif" alt=""></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园    S：幸存区    O：老年代</p><ul><li>会STW</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" srcset="/img/loading.gif" alt=""></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" srcset="/img/loading.gif" alt=""></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p> 会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx    用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" srcset="/img/loading.gif" alt=""></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>卡表与Remembered Set</p><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li><p>在引用变更时通过post-write barried + dirty card queue</p></li><li><p>concurrent refinement threads  更新 Remembered Set</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" srcset="/img/loading.gif" alt=""></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的  灰色：正在处理中的 白色：还未处理的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" srcset="/img/loading.gif" alt=""></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" srcset="/img/loading.gif" alt=""></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" srcset="/img/loading.gif" alt=""></p><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p><pre><code class="hljs taggerscript">"F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\j</span>ava" -XX:+PrintFlagsFinal -version | findstr "GC"</code></pre><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li><p>内存</p></li><li><p>锁竞争</p></li><li><p>CPU占用</p></li><li><p>IO</p></li><li><p>GC</p></li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li><p>CMS G1 ZGC</p></li><li><p>ParallelGC</p></li><li><p>Zing</p></li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题 </p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li><p>新生代的特点</p><ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li><p>新生代内存越大越好么？</p><ul><li><p>不是</p><ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li><p>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</p></li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>在文件对应目录下运行cmd，执行javac XXX.java</li></ul><p>以下是字节码文件</p><pre><code class="hljs angelscript"><span class="hljs-number">0000000</span> ca fe ba be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">23</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">09</span> <span class="hljs-number">0000020</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">17</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">18</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>a <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">07</span> <span class="hljs-number">0000040</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>c <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">3</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">3</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <span class="hljs-number">0000060</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">43</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">4</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">65</span> <span class="hljs-number">4</span>e <span class="hljs-number">0000100</span> <span class="hljs-number">75</span> <span class="hljs-number">6</span>d <span class="hljs-number">62</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">4</span>c <span class="hljs-number">6f</span> <span class="hljs-number">63</span> <span class="hljs-number">0000120</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>c <span class="hljs-number">56</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">0000140</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">4</span>c <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">63</span> <span class="hljs-number">0000160</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">0000200</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">0000220</span> <span class="hljs-number">28</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">0000240</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">0000260</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">0000300</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">50</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span> <span class="hljs-number">0000320</span> <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">53</span> <span class="hljs-number">6f</span> <span class="hljs-number">75</span> <span class="hljs-number">72</span> <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">46</span> <span class="hljs-number">0000340</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span><span class="hljs-number">0000360</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">1</span>e <span class="hljs-number">0000400</span> <span class="hljs-number">00</span> <span class="hljs-number">1f</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">20</span> <span class="hljs-number">77</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">0000420</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">22</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">0000440</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">0000460</span> <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">0000500</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">4f</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>a <span class="hljs-number">65</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0000520</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">79</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>d <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">6f</span> <span class="hljs-number">0000540</span> <span class="hljs-number">75</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">0000560</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">0000600</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">0000620</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">70</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">28</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">0000640</span> <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">0000660</span> <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">0000700</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">0000720</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">2</span>a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">0000740</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0000760</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">0001000</span> <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0001020</span> <span class="hljs-number">09</span> b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">0001040</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">0001060</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0001100</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">00</span> <span class="hljs-number">0001120</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">14</span></code></pre><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><pre><code class="hljs properties"><span class="hljs-attr">u4</span>  <span class="hljs-string">magic</span><span class="hljs-attr">u2</span> <span class="hljs-string">            minor_version;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            major_version;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            constant_pool_count;    </span><span class="hljs-attr">cp_info</span> <span class="hljs-string">       constant_pool[constant_pool_count-1];    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            access_flags;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            this_class;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            super_class;   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            interfaces_count;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            interfaces[interfaces_count];   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            fields_count;    </span><span class="hljs-attr">field_info</span> <span class="hljs-string">    fields[fields_count];   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            methods_count;    </span><span class="hljs-attr">method_info</span> <span class="hljs-string">   methods[methods_count];    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            attributes_count;    </span><span class="hljs-attr">attribute_info</span> <span class="hljs-string">attributes[attributes_count];</span></code></pre><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic </p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2             minor_version;    </p><p>u2             major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09 </p><p>34H = 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p><p>…略</p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考 </p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><pre><code class="hljs taggerscript">javap -v F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.class</code></pre><pre><code class="hljs lasso">F:\Thread_study&gt;javap <span class="hljs-params">-v</span> F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class  Last modified <span class="hljs-number">2020</span><span class="hljs-number">-6</span><span class="hljs-number">-6</span>; size <span class="hljs-number">434</span> <span class="hljs-built_in">bytes</span>  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from <span class="hljs-string">"Demo1.java"</span><span class="hljs-keyword">public</span> class com.nyima.JVM.day5.Demo1  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #6.#15         <span class="hljs-comment">// java/lang/Object."&lt;init&gt;":()V</span>   #2 = Fieldref           #16.#17        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span>   #3 = <span class="hljs-built_in">String</span>             #18            <span class="hljs-comment">// hello world</span>   #4 = Methodref          #19.#20        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span>   #5 = Class              #21            <span class="hljs-comment">// com/nyima/JVM/day5/Demo1</span>   #6 = Class              #22            <span class="hljs-comment">// java/lang/Object</span>   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               main  #12 = Utf8               (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V  #13 = Utf8               SourceFile  #14 = Utf8               Demo1.java  #15 = NameAndType        #7:#8          <span class="hljs-comment">// "&lt;init&gt;":()V</span>  #16 = Class              #23            <span class="hljs-comment">// java/lang/System</span>  #17 = NameAndType        #24:#25        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span>  #18 = Utf8               hello world  #19 = Class              #26            <span class="hljs-comment">// java/io/PrintStream</span>  #20 = NameAndType        #27:#28        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span>  #21 = Utf8               com/nyima/JVM/day5/Demo1  #22 = Utf8               java/lang/Object  #23 = Utf8               java/lang/System  #24 = Utf8               out  #25 = Utf8               Ljava/io/PrintStream;  #26 = Utf8               java/io/PrintStream  #27 = Utf8               println  #28 = Utf8               (Ljava/lang/<span class="hljs-built_in">String</span>;)V&#123;  <span class="hljs-keyword">public</span> com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      <span class="hljs-built_in">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #1                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>  <span class="hljs-keyword">public</span> static <span class="hljs-literal">void</span> main(java.lang.<span class="hljs-built_in">String</span><span class="hljs-meta">[</span><span class="hljs-meta">]</span>);    descriptor: (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      <span class="hljs-built_in">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: getstatic     #2                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="hljs-number">3</span>: ldc           #3                  <span class="hljs-comment">// String hello world</span>         <span class="hljs-number">5</span>: invokevirtual #4                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span>&#125;</code></pre><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> c = a + b;        System.out.println(c);       &#125; &#125;</code></pre><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" srcset="/img/loading.gif" alt=""></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" srcset="/img/loading.gif" alt=""></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong> </p><ul><li><strong>将一个 byte 压入操作数栈</strong>（其长度会补齐 4 个字节），类似的指令还有 <ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈 </li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的 </p><pre><code class="hljs java">a = <span class="hljs-number">10</span></code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" srcset="/img/loading.gif" alt=""></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" srcset="/img/loading.gif" alt=""></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" srcset="/img/loading.gif" alt=""></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" srcset="/img/loading.gif" alt=""></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" srcset="/img/loading.gif" alt=""></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" srcset="/img/loading.gif" alt=""></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法 </p><p>生成新的栈帧（分配 locals、stack等） </p><p>传递参数，执行新栈帧中的字节码</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" srcset="/img/loading.gif" alt=""></p><p>执行完毕，弹出栈帧 </p><p>清除 main 操作数栈内容</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" srcset="/img/loading.gif" alt=""></p><p>*<em>return *</em><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;x = x++;i++;&#125;System.out.println(x); <span class="hljs-comment">//接过为0</span>&#125;&#125;</code></pre><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span>        <span class="hljs-number">0</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">1</span>: istore_1<span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span>        <span class="hljs-number">2</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">3</span>: istore_2<span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0</span>        <span class="hljs-number">4</span>: iload_1<span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span><span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span>       <span class="hljs-number">10</span>: iload_2<span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span>       <span class="hljs-number">14</span>: istore_2<span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了1</span>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span>       21: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">24</span>: iload_2       25: invokevirtual #3                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span></code></pre><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><h5 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">static</span> &#123;i = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">static</span> &#123;i = <span class="hljs-number">30</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(i); <span class="hljs-comment">//结果为30</span>&#125;&#125;</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方 法 <cinit>()V ：</p><pre><code class="hljs angelscript">stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>         <span class="hljs-number">7</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">10</span>: bipush        <span class="hljs-number">30</span>        <span class="hljs-number">12</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span></code></pre><h5 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-keyword">private</span> String a = <span class="hljs-string">"s1"</span>;&#123;b = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;&#123;a = <span class="hljs-string">"s2"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">this</span>.a = a;<span class="hljs-keyword">this</span>.b = b;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">"s3"</span>, <span class="hljs-number">30</span>);System.out.println(d.a);System.out.println(d.b);&#125;&#125;</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span>        <span class="hljs-number">0</span>: aload_0        <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span>        <span class="hljs-number">4</span>: aload_0        <span class="hljs-number">5</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String s1</span>        <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-number">10</span>: aload_0       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">16</span>: aload_0       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span>       <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">22</span>: aload_0       <span class="hljs-number">23</span>: ldc           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// String s2</span>       <span class="hljs-number">25</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-comment">//原始构造方法在最后执行</span>       <span class="hljs-number">28</span>: aload_0       <span class="hljs-number">29</span>: aload_1       <span class="hljs-number">30</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-number">33</span>: aload_0       <span class="hljs-number">34</span>: iload_2       <span class="hljs-number">35</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span></code></pre><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();demo5.test1();demo5.test2();demo5.test3();Demo5.test4();&#125;&#125;</code></pre><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><pre><code class="hljs angelscript">Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: new           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/nyima/JVM/day5/Demo5 </span>         <span class="hljs-number">3</span>: dup         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method "&lt;init&gt;":()V</span>         <span class="hljs-number">7</span>: astore_1         <span class="hljs-number">8</span>: aload_1         <span class="hljs-number">9</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method test1:()V</span>        <span class="hljs-number">12</span>: aload_1        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method test2:()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method test3:()V</span>        <span class="hljs-number">20</span>: invokestatic  #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method test4:()V</span>        <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈 </li><li>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配 合 invokespecial 调用该对象的构造方法 “<init>“:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量 </li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定 </li><li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 </li></ul><h4 id="多态原理"><a href="#多态原理" class="headerlink" title="多态原理"></a>多态原理</h4><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;i = <span class="hljs-number">20</span>;&#125;&#125;&#125;</code></pre><p>对应字节码指令</p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">12</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//多出来一个异常表</span>     Exception table:        <span class="hljs-keyword">from</span>    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/Exception</code></pre><ul><li>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号 </li><li>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</li></ul><h5 id="多个single-catch"><a href="#多个single-catch" class="headerlink" title="多个single-catch"></a>多个single-catch</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;i = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;i = <span class="hljs-number">30</span>;&#125;&#125;&#125;</code></pre><p>对应的字节码</p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-number">5</span>: goto          <span class="hljs-number">19</span>        <span class="hljs-number">8</span>: astore_2        <span class="hljs-number">9</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">11</span>: istore_1       <span class="hljs-number">12</span>: goto          <span class="hljs-number">19</span>       <span class="hljs-number">15</span>: astore_2       <span class="hljs-number">16</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">18</span>: istore_1       <span class="hljs-number">19</span>: <span class="hljs-keyword">return</span>     Exception table:        <span class="hljs-keyword">from</span>    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>     <span class="hljs-number">8</span>   Class java/lang/ArithmeticException            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">15</span>   Class java/lang/Exception</code></pre><ul><li>因为异常出现时，<strong>只能进入</strong> Exception table 中<strong>一个分支</strong>，所以局部变量表 slot 2 位置<strong>被共用</strong></li></ul><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;i = <span class="hljs-number">20</span>;&#125; <span class="hljs-keyword">finally</span> &#123;i = <span class="hljs-number">30</span>;&#125;&#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">4</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: iconst_0        <span class="hljs-number">1</span>: istore_1        <span class="hljs-comment">//try块</span>        <span class="hljs-number">2</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">4</span>: istore_1        <span class="hljs-comment">//try块执行完后，会执行finally    </span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">30</span>        <span class="hljs-number">7</span>: istore_1        <span class="hljs-number">8</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//catch块     </span>       <span class="hljs-number">11</span>: astore_2 <span class="hljs-comment">//异常信息放入局部变量表的2号槽位</span>       <span class="hljs-number">12</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">14</span>: istore_1       <span class="hljs-comment">//catch块执行完后，会执行finally        </span>       <span class="hljs-number">15</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">17</span>: istore_1       <span class="hljs-number">18</span>: goto          <span class="hljs-number">27</span>       <span class="hljs-comment">//出现异常，但未被Exception捕获，会抛出其他异常，这时也需要执行finally块中的代码   </span>       <span class="hljs-number">21</span>: astore_3       <span class="hljs-number">22</span>: bipush        <span class="hljs-number">30</span>       <span class="hljs-number">24</span>: istore_1       <span class="hljs-number">25</span>: aload_3       <span class="hljs-number">26</span>: athrow  <span class="hljs-comment">//抛出异常</span>       <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span>     Exception table:        from    to  target type            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">11</span>   Class java/lang/Exception            <span class="hljs-number">2</span>     <span class="hljs-number">5</span>    <span class="hljs-number">21</span>   any           <span class="hljs-number">11</span>    <span class="hljs-number">15</span>    <span class="hljs-number">21</span>   any</code></pre><p>可以看到 ﬁnally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程 </p><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p><h5 id="finally中的return"><a href="#finally中的return" class="headerlink" title="finally中的return"></a>finally中的return</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = Demo3.test();        <span class="hljs-comment">//结果为20</span>System.out.println(i);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">try</span> &#123;i = <span class="hljs-number">10</span>;<span class="hljs-keyword">return</span> i;&#125; <span class="hljs-keyword">finally</span> &#123;i = <span class="hljs-number">20</span>;<span class="hljs-keyword">return</span> i;&#125;&#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0        <span class="hljs-number">3</span>: iload_0        <span class="hljs-number">4</span>: istore_1  <span class="hljs-comment">//暂存返回值</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0        <span class="hljs-number">8</span>: iload_0        <span class="hljs-number">9</span>: ireturn<span class="hljs-comment">//ireturn会返回操作数栈顶的整型值20</span>       <span class="hljs-comment">//如果出现异常，还是会执行finally块中的内容，没有抛出异常</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: iload_0       <span class="hljs-number">15</span>: ireturn<span class="hljs-comment">//这里没有athrow了，也就是如果在finally块中如果有返回操作的话，且try块中出现异常，会吞掉异常！</span>     Exception table:        from    to  target type            <span class="hljs-number">0</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre><ul><li>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准 </li><li>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子 </li><li>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></li><li>所以<strong>不要在finally中进行返回操作</strong></li></ul><h5 id="被吞掉的异常"><a href="#被吞掉的异常" class="headerlink" title="被吞掉的异常"></a>被吞掉的异常</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> i = Demo3.test();      <span class="hljs-comment">//最终结果为20</span>      System.out.println(i);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-keyword">int</span> i;      <span class="hljs-keyword">try</span> &#123;         i = <span class="hljs-number">10</span>;         <span class="hljs-comment">//这里应该会抛出异常</span>         i = i/<span class="hljs-number">0</span>;         <span class="hljs-keyword">return</span> i;      &#125; <span class="hljs-keyword">finally</span> &#123;         i = <span class="hljs-number">20</span>;         <span class="hljs-keyword">return</span> i;      &#125;   &#125;&#125;</code></pre><p>会发现打印结果为20，并未抛出异常</p><h5 id="finally不带return"><a href="#finally不带return" class="headerlink" title="finally不带return"></a>finally不带return</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = Demo4.test();System.out.println(i);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">return</span> i;&#125; <span class="hljs-keyword">finally</span> &#123;i = <span class="hljs-number">20</span>;&#125;&#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">0</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_0 <span class="hljs-comment">//赋值给i 10</span>        <span class="hljs-number">3</span>: iload_0<span class="hljs-comment">//加载到操作数栈顶</span>        <span class="hljs-number">4</span>: istore_1 <span class="hljs-comment">//加载到局部变量表的1号位置</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>        <span class="hljs-number">7</span>: istore_0 <span class="hljs-comment">//赋值给i 20</span>        <span class="hljs-number">8</span>: iload_1 <span class="hljs-comment">//加载局部变量表1号位置的数10到操作数栈</span>        <span class="hljs-number">9</span>: ireturn <span class="hljs-comment">//返回操作数栈顶元素 10</span>       <span class="hljs-number">10</span>: astore_2       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: istore_0       <span class="hljs-number">14</span>: aload_2 <span class="hljs-comment">//加载异常</span>       <span class="hljs-number">15</span>: athrow <span class="hljs-comment">//抛出异常</span>     Exception table:        from    to  target type            <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">10</span>   any</code></pre><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;Lock lock = <span class="hljs-keyword">new</span> Lock();<span class="hljs-keyword">synchronized</span> (lock) &#123;System.out.println(i);&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span></span>&#123;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>        <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>        <span class="hljs-number">2</span>: istore_1        3: new           #2                  // class com/nyima/JVM/day06/Lock        <span class="hljs-number">6</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈顶，用于构造函数消耗</span>        7: invokespecial #3                  // Method com/nyima/JVM/day06/Lock."&lt;init&gt;":()V       <span class="hljs-number">10</span>: astore_2 <span class="hljs-comment">//剩下的一份放到局部变量表的2号位置</span>       <span class="hljs-number">11</span>: aload_2 <span class="hljs-comment">//加载到操作数栈</span>       <span class="hljs-number">12</span>: dup <span class="hljs-comment">//复制一份，放到操作数栈，用于加锁时消耗</span>       <span class="hljs-number">13</span>: astore_3 <span class="hljs-comment">//将操作数栈顶元素弹出，暂存到局部变量表的三号槽位。这时操作数栈中有一份对象的引用</span>       <span class="hljs-number">14</span>: monitorenter <span class="hljs-comment">//加锁</span>       <span class="hljs-comment">//锁住后代码块中的操作    </span>       15: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;       <span class="hljs-number">18</span>: iload_1       19: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V       <span class="hljs-comment">//加载局部变量表中三号槽位对象的引用，用于解锁    </span>       <span class="hljs-number">22</span>: aload_3           <span class="hljs-number">23</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">24</span>: goto          <span class="hljs-number">34</span>       <span class="hljs-comment">//异常操作    </span>       <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>       <span class="hljs-number">29</span>: aload_3       <span class="hljs-number">30</span>: monitorexit <span class="hljs-comment">//解锁</span>       <span class="hljs-number">31</span>: aload         <span class="hljs-number">4</span>       <span class="hljs-number">33</span>: athrow       <span class="hljs-number">34</span>: <span class="hljs-keyword">return</span>     <span class="hljs-comment">//可以看出，无论何时出现异常，都会跳转到27行，将异常放入局部变量中，并进行解锁操作，然后加载异常并抛出异常。      </span>     Exception table:        from    to  target type           <span class="hljs-number">15</span>    <span class="hljs-number">24</span>    <span class="hljs-number">27</span>   any           <span class="hljs-number">27</span>    <span class="hljs-number">31</span>    <span class="hljs-number">27</span>   any</code></pre><h3 id="3、编译期处理"><a href="#3、编译期处理" class="headerlink" title="3、编译期处理"></a>3、编译期处理</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 <em>.java 源码编译为 <em>.class 字节码的过程中，</em></em>自动生成<strong>和</strong>转换**的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p><p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。 </p><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;&#125;</code></pre><p>经过编译期优化后</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy1</span> </span>&#123;   <span class="hljs-comment">//这个无参构造器是java编译器帮我们加上的</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Candy1</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">//即调用父类 Object 的无参构造方法，即调用 java/lang/Object." &lt;init&gt;":()V</span>      <span class="hljs-keyword">super</span>();   &#125;&#125;</code></pre><h4 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称谓拆装箱</p><p>在JDK 5以后，它们的转换可以在编译期自动完成</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Integer x = <span class="hljs-number">1</span>;      <span class="hljs-keyword">int</span> y = x;   &#125;&#125;</code></pre><p>转换过程如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//基本类型赋值给包装类型，称为装箱</span>      Integer x = Integer.valueOf(<span class="hljs-number">1</span>);      <span class="hljs-comment">//包装类型赋值给基本类型，称谓拆箱</span>      <span class="hljs-keyword">int</span> y = x.intValue();   &#125;&#125;</code></pre><h4 id="泛型集合取值"><a href="#泛型集合取值" class="headerlink" title="泛型集合取值"></a>泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();      list.add(<span class="hljs-number">10</span>);      Integer x = list.get(<span class="hljs-number">0</span>);   &#125;&#125;</code></pre><p>对应字节码</p><pre><code class="hljs java">Code:    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span>       0: new           #2                  // class java/util/ArrayList       <span class="hljs-number">3</span>: dup       4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V       <span class="hljs-number">7</span>: astore_1       <span class="hljs-number">8</span>: aload_1       <span class="hljs-number">9</span>: bipush        <span class="hljs-number">10</span>      11: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;      <span class="hljs-comment">//这里进行了泛型擦除，实际调用的是add(Objcet o)</span>      14: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z      <span class="hljs-number">19</span>: pop      <span class="hljs-number">20</span>: aload_1      <span class="hljs-number">21</span>: iconst_0      <span class="hljs-comment">//这里也进行了泛型擦除，实际调用的是get(Object o)   </span>      22: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;<span class="hljs-comment">//这里进行了类型转换，将Object转换成了Integer</span>      27: checkcast     #7                  // class java/lang/Integer      <span class="hljs-number">30</span>: astore_2      <span class="hljs-number">31</span>: <span class="hljs-keyword">return</span></code></pre><p>所以调用get函数取值时，有一个类型转换的操作</p><pre><code class="hljs java">Integer x = (Integer) list.get(<span class="hljs-number">0</span>);</code></pre><p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> x = (Integer) list.get(<span class="hljs-number">0</span>).intValue();</code></pre><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String... args)</span> </span>&#123;      <span class="hljs-comment">//将args赋值给arr，可以看出String...实际就是String[] </span>      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>);   &#125;&#125;</code></pre><p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo4 &#123;&#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String[] arr = args;      System.out.println(arr.length);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      foo(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>&#125;);   &#125;&#125;</code></pre><p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p><h4 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//数组赋初值的简化写法也是一种语法糖。</span><span class="hljs-keyword">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x : arr) &#123;System.out.println(x);&#125;&#125;&#125;</code></pre><p>编译器会帮我们转换为</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;arr.length; ++i) &#123;<span class="hljs-keyword">int</span> x = arr[i];System.out.println(x);&#125;&#125;&#125;</code></pre><p><strong>如果是集合使用foreach</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-keyword">for</span> (Integer x : list) &#123;         System.out.println(x);      &#125;   &#125;&#125;</code></pre><p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;    <span class="hljs-keyword">public</span> Demo5 &#123;&#125;       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);      <span class="hljs-comment">//获得该集合的迭代器</span>      Iterator&lt;Integer&gt; iterator = list.iterator();      <span class="hljs-keyword">while</span>(iterator.hasNext()) &#123;         Integer x = iterator.next();         System.out.println(x);      &#125;   &#125;&#125;</code></pre><h4 id="switch字符串"><a href="#switch字符串" class="headerlink" title="switch字符串"></a>switch字符串</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">"hello"</span>;      <span class="hljs-keyword">switch</span> (str) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-string">"hello"</span> :            System.out.println(<span class="hljs-string">"h"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-string">"world"</span> :            System.out.println(<span class="hljs-string">"w"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre><p>在编译器中执行的操作</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo6</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo6</span><span class="hljs-params">()</span> </span>&#123;         &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      String str = <span class="hljs-string">"hello"</span>;      <span class="hljs-keyword">int</span> x = -<span class="hljs-number">1</span>;      <span class="hljs-comment">//通过字符串的hashCode+value来判断是否匹配</span>      <span class="hljs-keyword">switch</span> (str.hashCode()) &#123;         <span class="hljs-comment">//hello的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">99162322</span> :            <span class="hljs-comment">//再次比较，因为字符串的hashCode有可能相等</span>            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">"hello"</span>)) &#123;               x = <span class="hljs-number">0</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-comment">//world的hashCode</span>         <span class="hljs-keyword">case</span> <span class="hljs-number">11331880</span> :            <span class="hljs-keyword">if</span>(str.equals(<span class="hljs-string">"world"</span>)) &#123;               x = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;      <span class="hljs-comment">//用第二个switch在进行输出判断</span>      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:            System.out.println(<span class="hljs-string">"h"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">"w"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;</code></pre><p>过程说明：</p><ul><li>在编译期间，单个的switch被分为了两个<ul><li>第一个用来匹配字符串，并给x赋值<ul><li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li><li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li></ul></li><li>第二个用来根据x的值来决定输出语句</li></ul></li></ul><h4 id="switch枚举"><a href="#switch枚举" class="headerlink" title="switch枚举"></a>switch枚举</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-keyword">switch</span> (sex) &#123;         <span class="hljs-keyword">case</span> MALE:            System.out.println(<span class="hljs-string">"man"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> FEMALE:            System.out.println(<span class="hljs-string">"woman"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</code></pre><p>编译器中执行的代码如下</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo7</span> </span>&#123;   <span class="hljs-comment">/**     </span><span class="hljs-comment">    * 定义一个合成类（仅 jvm 使用，对我们不可见）     </span><span class="hljs-comment">    * 用来映射枚举的 ordinal 与数组元素的关系     </span><span class="hljs-comment">    * 枚举的 ordinal 表示枚举对象的序号，从 0 开始     </span><span class="hljs-comment">    * 即 MALE 的 ordinal()=0，FEMALE 的 ordinal()=1     </span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">MAP</span> </span>&#123;      <span class="hljs-comment">//数组大小即为枚举元素个数，里面存放了case用于比较的数字</span>      <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">2</span>];      <span class="hljs-keyword">static</span> &#123;         <span class="hljs-comment">//ordinal即枚举元素对应所在的位置，MALE为0，FEMALE为1</span>         map[SEX.MALE.ordinal()] = <span class="hljs-number">1</span>;         map[SEX.FEMALE.ordinal()] = <span class="hljs-number">2</span>;      &#125;   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      SEX sex = SEX.MALE;      <span class="hljs-comment">//将对应位置枚举元素的值赋给x，用于case操作</span>      <span class="hljs-keyword">int</span> x = $MAP.map[sex.ordinal()];      <span class="hljs-keyword">switch</span> (x) &#123;         <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:            System.out.println(<span class="hljs-string">"man"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:            System.out.println(<span class="hljs-string">"woman"</span>);            <span class="hljs-keyword">break</span>;         <span class="hljs-keyword">default</span>:            <span class="hljs-keyword">break</span>;      &#125;   &#125;&#125;<span class="hljs-keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</code></pre><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><pre><code class="hljs java"><span class="hljs-keyword">enum</span> SEX &#123;   MALE, FEMALE;&#125;</code></pre><p>转换后的代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Enum</span>&lt;<span class="hljs-title">Sex</span>&gt; </span>&#123;      <span class="hljs-comment">//对应枚举类中的元素</span>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex MALE;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex FEMALE;       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Sex[] $VALUES;       <span class="hljs-keyword">static</span> &#123;           <span class="hljs-comment">//调用构造函数，传入枚举元素的值及ordinal</span>    MALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">"MALE"</span>, <span class="hljs-number">0</span>);            FEMALE = <span class="hljs-keyword">new</span> Sex(<span class="hljs-string">"FEMALE"</span>, <span class="hljs-number">1</span>);           $VALUES = <span class="hljs-keyword">new</span> Sex[]&#123;MALE, FEMALE&#125;;    &#125;    <span class="hljs-comment">//调用父类中的方法</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Sex</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>&#123;             <span class="hljs-keyword">super</span>(name, ordinal);        &#125;       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex[] values() &#123;          <span class="hljs-keyword">return</span> $VALUES.clone();      &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Sex <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>&#123;         <span class="hljs-keyword">return</span> Enum.valueOf(Sex<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">name</span>)</span>;      &#125;    &#125;</code></pre><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(<span class="hljs-string">"running..."</span>);         &#125;      &#125;;   &#125;&#125;</code></pre><p>转换后的代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">//用额外创建的类来创建匿名内部类对象</span>      Runnable runnable = <span class="hljs-keyword">new</span> Demo8$<span class="hljs-number">1</span>();   &#125;&#125;<span class="hljs-comment">//创建了一个额外的类，实现了Runnable接口</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>() &#123;&#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"running..."</span>);   &#125;&#125;</code></pre><p>如果匿名内部类中引用了<strong>局部变量</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;</code></pre><p>转化后代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;      Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;         <span class="hljs-meta">@Override</span>         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;            System.out.println(x);         &#125;      &#125;;   &#125;&#125;<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo8</span>$1 <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;   <span class="hljs-comment">//多创建了一个变量</span>   <span class="hljs-keyword">int</span> val$x;   <span class="hljs-comment">//变为了有参构造器</span>   <span class="hljs-keyword">public</span> Demo8$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span> x) &#123;      <span class="hljs-keyword">this</span>.val$x = x;   &#125;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(val$x);   &#125;&#125;</code></pre><h3 id="4、类加载阶段"><a href="#4、类加载阶段" class="headerlink" title="4、类加载阶段"></a>4、类加载阶段</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ul><li>将类的字节码载入<strong>方法区</strong>（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有： <ul><li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用 </li><li>_super 即父类</li><li>_ﬁelds 即成员变量 </li><li>_methods 即方法 </li><li>_constants 即常量池 </li><li>_class_loader 即类加载器 </li><li>_vtable 虚方法表 </li><li>_itable 接口方法</li></ul></li><li>如果这个类还有父类没有加载，<strong>先加载父类</strong> </li><li>加载和链接可能是<strong>交替运行</strong>的</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611205050.png" srcset="/img/loading.gif" alt=""></p><ul><li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li><li>_java_mirror则是保存在<strong>堆内存</strong>中</li><li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li><li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证类是否符合 JVM规范，安全性检查</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>为 static 变量分配空间，设置默认值</p><ul><li>static变量在JDK 7以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li><li>static变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成</li><li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong> </li><li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li></ul><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p><strong>HSDB的使用</strong></p><ul><li>先获得要查看的进程ID</li></ul><pre><code class="hljs ebnf"><span class="hljs-attribute">jps</span></code></pre><ul><li>打开HSDB</li></ul><pre><code class="hljs crystal">java -cp <span class="hljs-symbol">F:</span>\JAVA\JDK8.<span class="hljs-number">0</span>\<span class="hljs-class"><span class="hljs-keyword">lib</span>\<span class="hljs-title">sa</span>-<span class="hljs-title">jdi</span>.<span class="hljs-title">jar</span> <span class="hljs-title">sun</span>.<span class="hljs-title">jvm</span>.<span class="hljs-title">hotspot</span>.<span class="hljs-title">HSDB</span></span></code></pre><ul><li>运行时可能会报错，是因为<strong>缺少一个.dll的文件</strong>，我们在JDK的安装目录中找到该文件，复制到缺失的文件下即可</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221703.png" srcset="/img/loading.gif" alt=""></p><ul><li>定位需要的进程</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611221857.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611222029.png" srcset="/img/loading.gif" alt=""></p><p><strong>解析的含义</strong></p><p>将常量池中的符号引用解析为直接引用</p><ul><li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;      ClassLoader loader = Demo1<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>;      <span class="hljs-comment">//只加载不解析</span>      Class&lt;?&gt; c = loader.loadClass(<span class="hljs-string">"com.nyima.JVM.day8.C"</span>);      <span class="hljs-comment">//用于阻塞主线程</span>      System.in.read();   &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;   D d = <span class="hljs-keyword">new</span> D();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> </span>&#123;&#125;</code></pre><ul><li>打开HSDB<ul><li>可以看到此时只加载了类C</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223153.png" srcset="/img/loading.gif" alt=""></p><p>查看类C的常量池，可以看到类D<strong>未被解析</strong>，只是存在于常量池中的符号</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611230658.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>解析以后，会将常量池中的符号引用解析为直接引用</p><ul><li>可以看到，此时已加载并解析了类C和类D</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200611223441.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200613104723.png" srcset="/img/loading.gif" alt=""></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化即调用 <strong>cinit()V</strong> ，虚拟机会保证这个类的『构造方法』的线程安全</p><h5 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p><ul><li>main 方法所在的类，总会被首先初始化 </li><li>首次访问这个类的静态变量或静态方法时 </li><li>子类初始化，如果父类还没初始化，会引发 </li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>Class.forName </li><li>new 会导致初始化</li></ul><p>以下情况不会初始化</p><ul><li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li><li>类对象.class 不会触发初始化</li><li>创建该类对象的数组</li><li>类加载器的.loadClass方法</li><li>Class.forNamed的参数2为false时</li></ul><p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p><h3 id="5、类加载器"><a href="#5、类加载器" class="headerlink" title="5、类加载器"></a>5、类加载器</h3><p>以JDK 8为例</p><table><thead><tr><th>名称</th><th>加载的类</th><th>说明</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader（启动类加载器）</td><td>JAVA_HOME/jre/lib</td><td>无法直接访问</td></tr><tr><td>Extension ClassLoader(拓展类加载器)</td><td>JAVA_HOME/jre/lib/ext</td><td>上级为Bootstrap，<strong>显示为null</strong></td></tr><tr><td>Application ClassLoader(应用程序类加载器)</td><td>classpath</td><td>上级为Extension</td></tr><tr><td>自定义类加载器</td><td>自定义</td><td>上级为Application</td></tr></tbody></table><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p><h4 id="拓展类加载器"><a href="#拓展类加载器" class="headerlink" title="拓展类加载器"></a>拓展类加载器</h4><p>如果classpath和JAVA_HOME/jre/lib/ext 下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载</p><h4 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h4><p>双亲委派模式，即调用类加载器ClassLoader 的 loadClass 方法时，查找类的规则</p><p>loadClass源码</p><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)    <span class="hljs-keyword">throws</span> ClassNotFoundException&#123;    <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;        <span class="hljs-comment">// 首先查找该类是否已经被该类加载器加载过了</span>        Class&lt;?&gt; c = findLoadedClass(name);        <span class="hljs-comment">//如果没有被加载过</span>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">long</span> t0 = System.nanoTime();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null</span>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;                    c = parent.loadClass(name, <span class="hljs-keyword">false</span>);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-comment">//看是否被启动类加载器加载过</span>                    c = findBootstrapClassOrNull(name);                &#125;            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;                <span class="hljs-comment">// ClassNotFoundException thrown if class not found</span>                <span class="hljs-comment">// from the non-null parent class loader</span>                <span class="hljs-comment">//捕获异常，但不做任何处理</span>            &#125;            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">//如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常</span>                <span class="hljs-comment">//然后让应用类加载器去找classpath下找该类</span>                <span class="hljs-keyword">long</span> t1 = System.nanoTime();                c = findClass(name);                <span class="hljs-comment">// 记录时间</span>                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);                sun.misc.PerfCounter.getFindClasses().increment();            &#125;        &#125;        <span class="hljs-keyword">if</span> (resolve) &#123;            resolveClass(c);        &#125;        <span class="hljs-keyword">return</span> c;    &#125;&#125;</code></pre><h4 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h4><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><ul><li>想加载非 classpath 随意路径中的类文件 </li><li>通过接口来使用实现，希望解耦时，常用在框架设计 </li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>继承ClassLoader父类</li><li>要遵从双亲委派机制，重写 ﬁndClass 方法 <ul><li>不是重写loadClass方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 deﬁneClass 方法来加载类 </li><li>使用者调用该类加载器的 loadClass 方法</li></ul><h3 id="6、运行期优化"><a href="#6、运行期优化" class="headerlink" title="6、运行期优化"></a>6、运行期优化</h3><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>JVM 将执行状态分成了 5 个层次：</p><ul><li>0层：解释执行，用解释器将字节码翻译为机器码</li><li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling） </li><li>2层：使用  C1 即时编译器编译执行（带基本的profiling）</li><li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li><li>4层：使用 C2 即时编译器编译执行</li></ul><p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p><h5 id="即时编译器（JIT）与解释器的区别"><a href="#即时编译器（JIT）与解释器的区别" class="headerlink" title="即时编译器（JIT）与解释器的区别"></a>即时编译器（JIT）与解释器的区别</h5><ul><li>解释器<ul><li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释 </li><li>是将字节码解释为针对所有平台都通用的机器码 </li></ul></li><li>即时编译器 <ul><li>将一些字节码<strong>编译</strong>为机器码，<strong>并存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译 </li><li>根据平台类型，生成平台特定的机器码</li></ul></li></ul><p>对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p><p>逃逸分析的 JVM 参数如下：</p><ul><li>开启逃逸分析：-XX:+DoEscapeAnalysis</li><li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li><li>显示分析结果：-XX:+PrintEscapeAnalysis</li></ul><p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数</p><p><strong>对象逃逸状态</strong></p><p><strong>全局逃逸（GlobalEscape）</strong></p><ul><li>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul><li>对象是一个静态变量</li><li>对象是一个已经发生逃逸的对象</li><li>对象作为当前方法的返回值</li></ul></li></ul><p><strong>参数逃逸（ArgEscape）</strong></p><ul><li>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的</li></ul><p><strong>没有逃逸</strong></p><ul><li>即方法中的对象没有发生逃逸</li></ul><p><strong>逃逸分析优化</strong></p><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化</p><p><strong>锁消除</strong></p><p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</p><p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作</p><p>锁消除的 JVM 参数如下：</p><ul><li>开启锁消除：-XX:+EliminateLocks</li><li>关闭锁消除：-XX:-EliminateLocks</li></ul><p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上</p><p><strong>标量替换</strong></p><p>首先要明白标量和聚合量，<strong>基础类型</strong>和<strong>对象的引用</strong>可以理解为<strong>标量</strong>，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象</p><p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做<strong>标量替换</strong>。</p><p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能</p><p>标量替换的 JVM 参数如下：</p><ul><li>开启标量替换：-XX:+EliminateAllocations</li><li>关闭标量替换：-XX:-EliminateAllocations</li><li>显示标量替换详情：-XX:+PrintEliminateAllocations</li></ul><p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上</p><p><strong>栈上分配</strong></p><p>当对象没有发生逃逸时，该<strong>对象</strong>就可以通过标量替换分解成成员标量分配在<strong>栈内存</strong>中，和方法的生命周期一致，随着栈帧出栈时销毁，减少了 GC 压力，提高了应用程序性能</p><h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a><strong>内联函数</strong></h5><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换</p><h5 id="JVM内联函数"><a href="#JVM内联函数" class="headerlink" title="JVM内联函数"></a><strong>JVM内联函数</strong></h5><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;          <span class="hljs-comment">// to do something  </span>&#125;</code></pre><p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p><p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p><p>第二个原因则更重要：<strong>方法内联</strong> </p><p> 如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123; <span class="hljs-comment">//这里调用了add2方法</span>        <span class="hljs-keyword">return</span> add2(x1, x2) + add2(x3, x4);      &#125;      <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2)</span> </span>&#123;          <span class="hljs-keyword">return</span> x1 + x2;      &#125;</code></pre><p>方法调用被替换后</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> x2, <span class="hljs-keyword">int</span> x3, <span class="hljs-keyword">int</span> x4)</span> </span>&#123;      <span class="hljs-comment">//被替换为了方法本身</span>        <span class="hljs-keyword">return</span> x1 + x2 + x3 + x4;      &#125;</code></pre><h4 id="反射优化"><a href="#反射优化" class="headerlink" title="反射优化"></a>反射优化</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reflect1</span> </span>&#123;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;      System.out.println(<span class="hljs-string">"foo..."</span>);   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, IllegalAccessException </span>&#123;      Method foo = Demo3.class.getMethod("foo");      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;=<span class="hljs-number">16</span>; i++) &#123;         foo.invoke(<span class="hljs-keyword">null</span>);      &#125;   &#125;&#125;</code></pre><p>foo.invoke 前面 0 ~ 15 次调用使用的是 MethodAccessor 的 NativeMethodAccessorImpl 实现</p><p>invoke方法源码</p><pre><code class="hljs java"><span class="hljs-meta">@CallerSensitive</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object obj, Object... args)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException,</span><span class="hljs-function">       InvocationTargetException</span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span> (!override) &#123;        <span class="hljs-keyword">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;            Class&lt;?&gt; caller = Reflection.getCallerClass();            checkAccess(caller, clazz, obj, modifiers);        &#125;    &#125;    <span class="hljs-comment">//MethodAccessor是一个接口，有3个实现类，其中有一个是抽象类</span>    MethodAccessor ma = methodAccessor;             <span class="hljs-comment">// read volatile</span>    <span class="hljs-keyword">if</span> (ma == <span class="hljs-keyword">null</span>) &#123;        ma = acquireMethodAccessor();    &#125;    <span class="hljs-keyword">return</span> ma.invoke(obj, args);&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614133554.png" srcset="/img/loading.gif" alt=""></p><p>会由DelegatingMehodAccessorImpl去调用NativeMethodAccessorImpl</p><p>NativeMethodAccessorImpl源码</p><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> NativeMethodAccessorImpl extends MethodAccessorImpl &#123;    <span class="hljs-keyword">private</span> final Method <span class="hljs-keyword">method</span>;    <span class="hljs-keyword">private</span> DelegatingMethodAccessorImpl parent;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> numInvocations;    <span class="hljs-constructor">NativeMethodAccessorImpl(Method <span class="hljs-params">var1</span>)</span> &#123;        this.<span class="hljs-keyword">method</span> = var1;    &#125;<span class="hljs-comment">//每次进行反射调用，会让numInvocation与ReflectionFactory.inflationThreshold的值（15）进行比较，并使使得numInvocation的值加一</span><span class="hljs-comment">//如果numInvocation&gt;ReflectionFactory.inflationThreshold，则会调用本地方法invoke0方法</span>    public Object invoke(Object var1, Object<span class="hljs-literal">[]</span> var2) throws IllegalArgumentException, InvocationTargetException &#123;        <span class="hljs-keyword">if</span> (++this.numInvocations &gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectionFactory</span>.</span></span>inflation<span class="hljs-constructor">Threshold()</span><span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ReflectUtil</span>.</span></span>is<span class="hljs-constructor">VMAnonymousClass(<span class="hljs-params">this</span>.<span class="hljs-params">method</span>.<span class="hljs-params">getDeclaringClass</span>()</span>)) &#123;            MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="hljs-keyword">new</span> <span class="hljs-constructor">MethodAccessorGenerator()</span>).generate<span class="hljs-constructor">Method(<span class="hljs-params">this</span>.<span class="hljs-params">method</span>.<span class="hljs-params">getDeclaringClass</span>()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Name()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ParameterTypes()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ReturnType()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">ExceptionTypes()</span>, this.<span class="hljs-keyword">method</span>.get<span class="hljs-constructor">Modifiers()</span>);            this.parent.set<span class="hljs-constructor">Delegate(<span class="hljs-params">var3</span>)</span>;        &#125;        return invoke0(this.<span class="hljs-keyword">method</span>, var1, var2);    &#125;    void set<span class="hljs-constructor">Parent(DelegatingMethodAccessorImpl <span class="hljs-params">var1</span>)</span> &#123;        this.parent = var1;    &#125;    <span class="hljs-keyword">private</span> static native Object invoke0(Method var0, Object var1, Object<span class="hljs-literal">[]</span> var2);&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">//ReflectionFactory.inflationThreshold()方法的返回值</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> inflationThreshold = <span class="hljs-number">15</span>;</code></pre><ul><li>一开始if条件不满足，就会调用本地方法invoke0</li><li>随着numInvocation的增大，当它大于ReflectionFactory.inflationThreshold的值16时，就会本地方法访问器替换为一个运行时动态生成的访问器，来提高效率<ul><li>这时会从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()</li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200614135011.png" srcset="/img/loading.gif" alt=""></p><h2 id="五、内存模型"><a href="#五、内存模型" class="headerlink" title="五、内存模型"></a>五、内存模型</h2><p>内存模型内容详见 <a href="http://www.wenwenlulu.cn/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#%E5%9B%9B%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98" target="_blank" rel="noopener">JAVA并发 第四章</a></p>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JAVA并发</title>
    <link href="/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h1><p>本博客根据<a href="https://www.bilibili.com/video/av81461839?from=search&seid=8445102345230304010" target="_blank" rel="noopener"><strong>黑马java并发编程教程</strong></a>学习而做的笔记，链接如下</p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 </p><ul><li><p>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication） </p></li><li><p>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP </p></li></ul></li><li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p>并发是一个CPU在不同的时间去不同线程中执行指令。</p><p>并行是多个CPU同时处理不同的线程。</p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力 </li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p><ul><li><p>需要等待结果返回，才能继续运行就是同步 </p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><p>1) 设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…<br>2) 结论 </p><ul><li><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p></li><li><p>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</p></li><li><p>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p></li></ul><p>结论 </p><ol><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 </p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 </p><ul><li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</p></li><li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 </p></li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p></li></ol><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：直接使用Thread创建线程"><a href="#方法一：直接使用Thread创建线程" class="headerlink" title="方法一：直接使用Thread创建线程"></a>方法一：直接使用Thread创建线程</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程</span>Thread t1 = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"thread running..."</span>);&#125;&#125;;<span class="hljs-comment">//设置线程名</span>t1.setName(<span class="hljs-string">"t1"</span>);<span class="hljs-comment">//启动线程</span>t1.start();System.out.println(<span class="hljs-string">"main running..."</span>);&#125;&#125;</code></pre><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程任务</span>Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"Runnable running"</span>);&#125;&#125;;<span class="hljs-comment">//将Runnable对象传给Thread</span>Thread t = <span class="hljs-keyword">new</span> Thread(r);<span class="hljs-comment">//启动线程</span>t.start();&#125;&#125;</code></pre><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程任务</span>Runnable r = () -&gt; &#123;            <span class="hljs-comment">//直接写方法体即可</span>System.out.println(<span class="hljs-string">"Runnable running"</span>);System.out.println(<span class="hljs-string">"Hello Thread"</span>);&#125;;<span class="hljs-comment">//将Runnable对象传给Thread</span>Thread t = <span class="hljs-keyword">new</span> Thread(r);<span class="hljs-comment">//启动线程</span>t.start();&#125;&#125;</code></pre><p>可以再Runnable上使用Alt+Enter</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" srcset="/img/loading.gif" alt=""></p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了 </li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        <span class="hljs-comment">//需要传入一个Callable对象</span>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;System.out.println(<span class="hljs-string">"线程执行!"</span>);Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;&#125;&#125;);Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">"t2"</span>);r1.start();<span class="hljs-comment">//获取线程中方法执行后的返回结果</span>System.out.println(task.get());&#125;&#125;</code></pre><h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong> </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能 </li></ul><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>  被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol><li><p>调用 sleep 会让当前线程从 <strong>Running  进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用  <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">//休眠一分钟</span>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);</code></pre></li></ol><h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable  就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程 </li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 </p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高</span></code></pre></li></ul><h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<span class="hljs-comment">//等待thread线程执行结束</span>thread.join();<span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span>thread.join(<span class="hljs-number">1000</span>);</code></pre><h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。 </li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span>t1.isInterrupted();</code></pre><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;        break;    &#125;&#125;</code></pre><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-comment">//判断当前线程是否被打断了</span><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);                        <span class="hljs-comment">//终止线程执行</span><span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();<span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span>Thread.currentThread().interrupt();&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();&#125;&#125;</code></pre><h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul><li>stop方法   停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);</code></pre><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态 </p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li></ul></li><li><p>【阻塞状态】</p><ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 </li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 </li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>NEW</strong>  线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） </li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。 </li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源 <ul><li>多个线程读共享资源其实也没有问题 </li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题 </li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;       counter++; &#125; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;     counter--; &#125;</code></pre><h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock </li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<span class="hljs-comment">//临界区</span>&#125;</code></pre><p>例：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object(); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                    <span class="hljs-keyword">synchronized</span> (room) &#123;             counter++;                    &#125;           &#125;        &#125;, <span class="hljs-string">"t1"</span>);     Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                     <span class="hljs-keyword">synchronized</span> (room) &#123;                        counter--;                      &#125;            &#125;     &#125;, <span class="hljs-string">"t2"</span>);     t1.start();        t2.start();     t1.join();       t2.join();        log.debug(<span class="hljs-string">"&#123;&#125;"</span>,counter); &#125;</code></pre><h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul><li><p>加在成员方法上</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<span class="hljs-comment">//在方法上加上synchronized关键字</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;&#125;&#125;&#125;</code></pre></li><li><p>加在静态方法上</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<span class="hljs-comment">//在静态方法上加上synchronized关键字</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span>(Demo<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;&#125;&#125;&#125;</code></pre></li></ul><h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全 </p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必 （要看该对象<strong>是否被共享</strong>且被执行了读写操作）<ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><ul><li>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" srcset="/img/loading.gif" alt=""></p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer </li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li><p>它们的每个方法是原子的（都被加上了synchronized）</p></li><li><p>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" srcset="/img/loading.gif" alt=""></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h2 id="4、Monitor概念"><a href="#4、Monitor概念" class="headerlink" title="4、Monitor概念"></a>4、Monitor概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><ul><li>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</li><li>如果<strong>已经绑定</strong>，则会去查询该Monitor是否已经有了Owner<ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li><p>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</p></li><li><p>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</p></li></ul></li></ul><h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" srcset="/img/loading.gif" alt=""></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>第一种情况</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" srcset="/img/loading.gif" alt=""></p><ul><li>第二种情况</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" srcset="/img/loading.gif" alt=""></p><h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" srcset="/img/loading.gif" alt=""></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p>​    <img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" srcset="/img/loading.gif" alt=""></p><ul><li>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</li><li>处于BLOCKED和WAITING状态的线程都为<strong>阻塞</strong>状态，CPU都不会分给他们时间片。但是有所区别：<ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span><span class="hljs-keyword">synchronized</span> (LOCK) &#123;LOCK.wait();&#125;&#125;&#125;</code></pre><h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span>LOCK.wait();&#125;<span class="hljs-comment">//满足条件后再运行</span>&#125;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-comment">//唤醒所有等待线程</span>LOCK.notifyAll();&#125;</code></pre><h2 id="7、模式之保护性暂停"><a href="#7、模式之保护性暂停" class="headerlink" title="7、模式之保护性暂停"></a>7、模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String hello = <span class="hljs-string">"hello thread!"</span>;Guarded guarded = <span class="hljs-keyword">new</span> Guarded();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">"想要得到结果"</span>);<span class="hljs-keyword">synchronized</span> (guarded) &#123;System.out.println(<span class="hljs-string">"结果是："</span>+guarded.getResponse());&#125;System.out.println(<span class="hljs-string">"得到结果"</span>);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">"设置结果"</span>);<span class="hljs-keyword">synchronized</span> (guarded) &#123;guarded.setResponse(hello);&#125;&#125;).start();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 要返回的结果</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Object response;    <span class="hljs-comment">//优雅地使用wait/notify</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span><span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">this</span>.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span class="hljs-keyword">return</span> response;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<span class="hljs-keyword">this</span>.response = response;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-comment">//唤醒休眠的线程</span><span class="hljs-keyword">this</span>.notifyAll();&#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Guarded&#123;"</span> +<span class="hljs-string">"response="</span> + response +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p><strong>带超时判断的暂停</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-comment">//获取开始时间</span><span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();<span class="hljs-comment">//用于保存已经等待了的时间</span><span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span><span class="hljs-keyword">long</span> waitTime = time -passedTime;<span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">try</span> &#123;                   <span class="hljs-comment">//等待剩余时间</span><span class="hljs-keyword">this</span>.wait(waitTime);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//获取当前时间</span>passedTime = System.currentTimeMillis()-currentTime            &#125;&#125;<span class="hljs-keyword">return</span> response;&#125;</code></pre><h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> base = System.currentTimeMillis();        <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"timeout value is negative"</span>);        &#125;        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                wait(<span class="hljs-number">0</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                <span class="hljs-keyword">long</span> delay = millis - now;                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                wait(delay);                now = System.currentTimeMillis() - base;            &#125;        &#125;    &#125;</code></pre><h2 id="8、park-unpark"><a href="#8、park-unpark" class="headerlink" title="8、park/unpark"></a>8、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span>LockSupport.park;<span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread);</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"park"</span>);            <span class="hljs-comment">//暂停线程运行</span>LockSupport.park();System.out.println(<span class="hljs-string">"resume"</span>);&#125;, <span class="hljs-string">"t1"</span>);thread.start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"unpark"</span>);    <span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread);&#125;</code></pre><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p><ul><li><p>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</p></li><li><p>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</p></li><li><p>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</p></li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象<strong>_counter, _cond,__mutex</strong>组成</p><ul><li><p>先调用park再调用unpark时</p><ul><li><p>先调用park</p><ul><li>线程运行时，会将Park对象中的<strong>_counter的值设为0</strong>；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li><p>然后调用unpark</p><ul><li><p>调用unpark方法后，会将counter的值设置为1</p></li><li><p>去唤醒阻塞队列cond中的线程</p></li><li><p>线程继续运行并将counter的值设为0</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" srcset="/img/loading.gif" alt=""></p><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" srcset="/img/loading.gif" alt=""></p><h2 id="9、线程中的状态转换"><a href="#9、线程中的状态转换" class="headerlink" title="9、线程中的状态转换"></a>9、线程中的状态转换</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" srcset="/img/loading.gif" alt=""></p><h4 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h4><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE </li></ul><h4 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h4><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 <ul><li>竞争锁成功，t 线程从  WAITING –&gt; RUNNABLE </li><li>竞争锁失败，t 线程从  WAITING –&gt; BLOCKED </li></ul></li></ul></li></ul><h4 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h4><ul><li><strong>当前线程</strong>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING<ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li></ul><h4 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h4><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h4 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h4><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从  TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从  TIMED_WAITING –&gt; BLOCKED </li></ul></li></ul><h4 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 t.join<strong>(long n</strong>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING <ul><li>注意是当前线程在t 线程对象的监视器上等待 </li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h4 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>当前线程等待时间超过了 n 毫秒，当前线程从  TIMED_WAITING –&gt; RUNNABLE</li></ul><h4 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING </li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h4 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h4><ul><li>t 线程用  synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从  RUNNABLE –&gt; BLOCKED </li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED  的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然  BLOCKED </li></ul><h4 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h4><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><h2 id="10、多把锁"><a href="#10、多把锁" class="headerlink" title="10、多把锁"></a>10、多把锁</h2><p><strong>将锁的粒度细分</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;    <span class="hljs-comment">//额外创建对象来作为锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();&#125;</code></pre><h2 id="11、活跃性"><a href="#11、活跃性" class="headerlink" title="11、活跃性"></a>11、活跃性</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (A) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">2000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">synchronized</span> (B) &#123;&#125;&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (B) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">synchronized</span> (A) &#123;&#125;&#125;&#125;).start();&#125;</code></pre><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li><p>jps+jstack ThreadID</p><ul><li><p>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" srcset="/img/loading.gif" alt=""></p></li></ul><pre><code class="hljs angelscript">F:\Thread_study&gt;jps<span class="hljs-number">20672</span> RemoteMavenServer36<span class="hljs-number">22880</span> Jps<span class="hljs-number">4432</span> Launcher<span class="hljs-number">5316</span> Test5<span class="hljs-number">20184</span> KotlinCompileDaemon<span class="hljs-number">11132</span>F:\Thread_study&gt;jstack <span class="hljs-number">5316</span></code></pre></li></ul><ul><li><p>打印的结果</p><pre><code class="hljs java"><span class="hljs-comment">//找到一个java级别的死锁</span>Found one Java-level deadlock:=============================<span class="hljs-string">"Thread-1"</span>:  waiting to lock monitor <span class="hljs-number">0x0000000017f40de8</span> (object <span class="hljs-number">0x00000000d6188880</span>, a java.lang.Object),  which is held by <span class="hljs-string">"Thread-0"</span><span class="hljs-string">"Thread-0"</span>:  waiting to lock monitor <span class="hljs-number">0x0000000017f43678</span> (object <span class="hljs-number">0x00000000d6188890</span>, a java.lang.Object),  which is held by <span class="hljs-string">"Thread-1"</span></code></pre></li></ul><ul><li><p>jconsole检测死锁</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" srcset="/img/loading.gif" alt=""></p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" srcset="/img/loading.gif" alt=""></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>在使用顺序加锁时，可能会出现饥饿现象</p><h2 id="12、ReentrantLock"><a href="#12、ReentrantLock" class="headerlink" title="12、ReentrantLock"></a>12、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可中断 </li><li>可以设置超时时间 </li><li>可以设置为公平锁  (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p><strong>基本语法</strong></p><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//加锁</span>lock.lock();<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//需要执行的代码</span>&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;</code></pre><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//加锁，可打断锁</span>lock.lockInterruptibly();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();                <span class="hljs-comment">//被打断，返回，不再向下执行</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;&#125;);lock.lock();<span class="hljs-keyword">try</span> &#123;t1.start();Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//打断</span>t1.interrupt();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-comment">//未设置等待时间，一旦获取失败，直接返回false</span><span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;System.out.println(<span class="hljs-string">"获取失败"</span>);                <span class="hljs-comment">//获取失败，不再向下执行，返回</span><span class="hljs-keyword">return</span>;&#125;System.out.println(<span class="hljs-string">"得到了锁"</span>);lock.unlock();&#125;);lock.lock();<span class="hljs-keyword">try</span>&#123;t1.start();Thread.sleep(<span class="hljs-number">3000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><p>设置等待时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span><span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;System.out.println(<span class="hljs-string">"获取失败"</span>);<span class="hljs-comment">//获取失败，不再向下执行，直接返回</span><span class="hljs-keyword">return</span>;&#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();<span class="hljs-comment">//被打断，不再向下执行，直接返回</span><span class="hljs-keyword">return</span>;&#125;System.out.println(<span class="hljs-string">"得到了锁"</span>);<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;);lock.lock();<span class="hljs-keyword">try</span>&#123;t1.start();<span class="hljs-comment">//打断等待</span>t1.interrupt();Thread.sleep(<span class="hljs-number">3000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比 </p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息 </li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 </li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//获得条件变量</span>Condition condition = lock.newCondition();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;lock.lock();<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">while</span>(!judge) &#123;System.out.println(<span class="hljs-string">"不满足条件，等待..."</span>);<span class="hljs-comment">//等待</span>condition.await();&#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;System.out.println(<span class="hljs-string">"执行完毕！"</span>);lock.unlock();&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;lock.lock();<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1</span>);judge = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//释放</span>condition.signal();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;).start();&#125;</code></pre><h2 id="13、同步模式之顺序控制"><a href="#13、同步模式之顺序控制" class="headerlink" title="13、同步模式之顺序控制"></a>13、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//判断先执行的内容是否执行完毕</span><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-keyword">while</span> (!judge) &#123;<span class="hljs-keyword">try</span> &#123;LOCK.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;System.out.println(<span class="hljs-string">"2"</span>);&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;System.out.println(<span class="hljs-string">"1"</span>);judge = <span class="hljs-keyword">true</span>;               <span class="hljs-comment">//执行完毕，唤醒所有等待线程</span>LOCK.notifyAll();&#125;&#125;).start();&#125;</code></pre><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p><strong>wait/notify版本</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;<span class="hljs-keyword">static</span> Symbol symbol = <span class="hljs-keyword">new</span> Symbol();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;symbol.run(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;symbol.run(<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);&#125;).start();symbol.run(<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;&#125;).start();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Symbol</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;<span class="hljs-keyword">while</span>(flag != <span class="hljs-keyword">this</span>.flag) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">this</span>.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;System.out.println(str);<span class="hljs-comment">//设置下一个运行的线程标记</span><span class="hljs-keyword">this</span>.flag = nextFlag;<span class="hljs-comment">//唤醒所有线程</span><span class="hljs-keyword">this</span>.notifyAll();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 线程的执行标记， 1-&gt;a 2-&gt;b 3-&gt;c</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFlag</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> flag;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag)</span> </span>&#123;<span class="hljs-keyword">this</span>.flag = flag;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> loopNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<span class="hljs-keyword">this</span>.loopNumber = loopNumber;&#125;&#125;</code></pre><p><strong>await/signal版本</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;<span class="hljs-keyword">static</span> AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal();<span class="hljs-keyword">static</span> Condition conditionA = awaitSignal.newCondition();<span class="hljs-keyword">static</span> Condition conditionB = awaitSignal.newCondition();<span class="hljs-keyword">static</span> Condition conditionC = awaitSignal.newCondition();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"a"</span>, conditionA, conditionB);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"b"</span>, conditionB, conditionC);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"c"</span>, conditionC, conditionA);&#125;).start();<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;awaitSignal.lock();<span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//唤醒一个等待的线程</span>conditionA.signal();&#125;<span class="hljs-keyword">finally</span> &#123;awaitSignal.unlock();&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, Condition thisCondition, Condition nextCondition)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;lock();<span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//全部进入等待状态</span>thisCondition.await();System.out.print(str);nextCondition.signal();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;unlock();&#125;&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber=<span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> loopNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<span class="hljs-keyword">this</span>.loopNumber = loopNumber;&#125;&#125;</code></pre><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享共享）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 </p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">while</span> (run) &#123;<span class="hljs-comment">//如果run为真，则一直执行</span>&#125;&#125;).start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"改变run的值为false"</span>);run = <span class="hljs-keyword">false</span>;&#125;</code></pre><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" srcset="/img/loading.gif" alt=""></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" srcset="/img/loading.gif" alt=""></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" srcset="/img/loading.gif" alt=""></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong> </li></ul><pre><code class="hljs java"><span class="hljs-comment">//使用易变关键字</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">while</span> (run) &#123;<span class="hljs-comment">//如果run为真，则一直执行</span>&#125;&#125;).start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"改变run的值为false"</span>);run = <span class="hljs-keyword">false</span>;&#125;</code></pre><h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li><p>因为使用了<strong>synchronized</strong>关键字</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<span class="hljs-comment">//使用了synchronized关键字</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            print(x);            newLine();        &#125;    &#125;</code></pre></li></ul></li></ul><h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">//设置标记，用于判断是否被终止了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span>(stop) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);<span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;System.out.println(<span class="hljs-string">"被打断了"</span>);&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();        <span class="hljs-comment">//修改标记</span>stop = <span class="hljs-keyword">true</span>;&#125;&#125;</code></pre><h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong> </p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong> </p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.nyima.day1;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/3/26 16:11</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">//设置标记，用于判断是否被终止了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">if</span> (starting) &#123;<span class="hljs-comment">//已被启动，直接返回</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//启动监视器，改变标记</span>starting = <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span>(stop) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);<span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;System.out.println(<span class="hljs-string">"被打断了"</span>);&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();stop = <span class="hljs-keyword">true</span>;&#125;&#125;</code></pre><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" srcset="/img/loading.gif" alt=""></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p></li><li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; System.out.println( a + b );<span class="hljs-comment">// 不能重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;</code></pre></li></ul><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" srcset="/img/loading.gif" alt=""></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><ul><li>可见性 <ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中 </li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据 </li></ul></li><li>有序性 <ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后 </li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul></li></ul><h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障 </li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" srcset="/img/loading.gif" alt=""></p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" srcset="/img/loading.gif" alt=""></p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" srcset="/img/loading.gif" alt=""></p><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去 </li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><ul><li><p>使用<strong>原子整数</strong></p><pre><code class="hljs ebnf"><span class="hljs-attribute">AtomicInteger balance</span> = new AtomicInteger();</code></pre></li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">long</span> start = System.nanoTime();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;account.withdraw(<span class="hljs-number">10</span>);&#125;));&#125;ts.forEach(Thread::start);ts.forEach(t -&gt; &#123;<span class="hljs-keyword">try</span> &#123;t.join();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);<span class="hljs-keyword">long</span> end = System.nanoTime();System.out.println(account.getBalance() + <span class="hljs-string">" cost: "</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">" ms"</span>);&#125;&#125;<span class="hljs-comment">//线程不安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-keyword">private</span> Integer balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = balance;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;balance -= amount;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));&#125;&#125;<span class="hljs-comment">//线程安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-comment">//使用原子整数</span><span class="hljs-keyword">private</span> AtomicInteger balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//得到原子整数的值</span><span class="hljs-keyword">return</span> balance.get();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//获得修改前的值</span><span class="hljs-keyword">int</span> prev = balance.get();<span class="hljs-comment">//获得修改后的值</span><span class="hljs-keyword">int</span> next = prev-amount;<span class="hljs-comment">//比较并设值</span><span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;</code></pre><h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" srcset="/img/loading.gif" alt=""></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li><p>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</p></li><li><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。为2</p><p><strong>注意</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</code></pre><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果 </p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" srcset="/img/loading.gif" alt=""></p><p><strong>原因</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </li><li>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 </li><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger </li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><pre><code class="hljs java"> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span> <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span> <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span> <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span>System.out.println(i.getAndDecrement()); <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>)); <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>)); <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>)); <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x)); <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));</code></pre><h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">long</span> start = System.nanoTime();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;account.withdraw(BigDecimal.TEN);&#125;));&#125;ts.forEach(Thread::start);ts.forEach(t -&gt; &#123;<span class="hljs-keyword">try</span> &#123;t.join();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);<span class="hljs-keyword">long</span> end = System.nanoTime();System.out.println(account.getBalance() + <span class="hljs-string">" cost: "</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">" ms"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<span class="hljs-comment">//原子引用，泛型类型为小数类型</span>AtomicReference&lt;BigDecimal&gt; balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> balance.get();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;BigDecimal pre = balance.get();BigDecimal next = pre.subtract(amount);<span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"10000"</span>)));&#125;&#125;</code></pre><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">"A"</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.get();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C</span>System.out.println(<span class="hljs-string">"change A-&gt;C "</span> + str.compareAndSet(pre, <span class="hljs-string">"C"</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"change A-&gt;B "</span> + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>));&#125;).start();Thread.sleep(<span class="hljs-number">500</span>);<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"change B-&gt;A "</span> + str.compareAndSet(<span class="hljs-string">"B"</span>, <span class="hljs-string">"A"</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" srcset="/img/loading.gif" alt=""></p><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-comment">//指定版本号</span><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">"A"</span>, <span class="hljs-number">0</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.getReference();<span class="hljs-comment">//获得版本号</span><span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>System.out.println(<span class="hljs-string">"change A-&gt;C stamp "</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">"C"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change A-&gt;B stamp "</span> + stamp + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();Thread.sleep(<span class="hljs-number">500</span>);<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change B-&gt;A stamp "</span> + stamp +  str.compareAndSet(<span class="hljs-string">"B"</span>, <span class="hljs-string">"A"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" srcset="/img/loading.gif" alt=""></p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-comment">//指定版本号</span><span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">"A"</span>, <span class="hljs-keyword">true</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.getReference();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>System.out.println(<span class="hljs-string">"change A-&gt;C mark "</span> +  str.compareAndSet(pre, <span class="hljs-string">"C"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;System.out.println(<span class="hljs-string">"change A-&gt;A mark "</span> + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"A"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" srcset="/img/loading.gif" alt=""></p><h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray </li><li>AtomicReferenceArray</li></ul><h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域  字段 </li><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFieldUpdate</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Student student = <span class="hljs-keyword">new</span> Student();AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">"张三"</span>);System.out.println(student);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<span class="hljs-comment">//cas操作需要搭配volatile一起使用</span><span class="hljs-keyword">volatile</span> String name;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><h2 id="8、原子累加器"><a href="#8、原子累加器" class="headerlink" title="8、原子累加器"></a>8、原子累加器</h2><h2 id="9、LongAdder原理"><a href="#9、LongAdder原理" class="headerlink" title="9、LongAdder原理"></a>9、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p>​    <img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" srcset="/img/loading.gif" alt=""></p><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" srcset="/img/loading.gif" alt=""></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" srcset="/img/loading.gif" alt=""></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1] </li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" srcset="/img/loading.gif" alt=""></p><p><strong>累加主要调用以下方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;       Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;           <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;           <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||               (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||               !(uncontended = a.cas(v = a.value, v + x)))               longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);       &#125;   &#125;</code></pre><p><strong>累加流程图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" srcset="/img/loading.gif" alt=""></p><h2 id="10、Unsafe"><a href="#10、Unsafe" class="headerlink" title="10、Unsafe"></a>10、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> &#123;</span><span class="hljs-keyword">static</span> Unsafe unsafe;<span class="hljs-keyword">static</span> &#123;Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">"theUnsafe"</span>);theUnsafe.setAccessible(<span class="hljs-literal">true</span>);unsafe = (Unsafe)theUnsafe.<span class="hljs-built_in">get</span>(null);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> unsafe;&#125;&#125;</code></pre><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];    <span class="hljs-comment">/** Cache the hash code for the string */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span>       <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre><p><strong>ﬁnal 的使用 **<br>发现该类、类中所有属性都是 **ﬁnal</strong> 的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改 </li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li></ul><p>*<em>保护性拷贝 *</em></p><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);        &#125;        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);        &#125;    <span class="hljs-comment">//返回的是一个新的对象</span>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;</code></pre><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        &#125;        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);            &#125;            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">""</span>.value;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);        &#125;        <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);    &#125;</code></pre><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    
    <categories>
      
      <category>JAVA</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习</title>
    <link href="/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <url>/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h1><p>本博客根据<a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=2" target="_blank" rel="noopener"><strong>黑马Redis教程</strong></a>学习而做的笔记，链接如下</p><h2 id="一、Redis常用指令"><a href="#一、Redis常用指令" class="headerlink" title="一、Redis常用指令"></a>一、Redis常用指令</h2><pre><code class="hljs awk"><span class="hljs-regexp">//</span>启动容器docker run -d -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -it   --name=<span class="hljs-string">"myredis"</span>  redis输入密码：auth 密码<span class="hljs-regexp">//</span>进入redis容器docker exec -it myredis  redis-cli<span class="hljs-regexp">//</span>退出quit<span class="hljs-keyword">exit</span><span class="hljs-regexp">//</span>清屏clear<span class="hljs-regexp">//</span>获取帮助, 可以使用Tab键来切换help 命令名称help @组名</code></pre><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p><strong>所有的key都为String类型，讨论数据类型是说的value的类型</strong></p><h3 id="1、String"><a href="#1、String" class="headerlink" title="1、String"></a>1、String</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs q"><span class="hljs-comment">//设置String</span><span class="hljs-built_in">set</span> <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span>mset key1 value1 key2 value2...<span class="hljs-comment">//设置生命周期</span>setex <span class="hljs-built_in">key</span> seconds <span class="hljs-built_in">value</span> <span class="hljs-comment">//得到String</span><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span> mget key1 key2...<span class="hljs-comment">//删除String</span>del <span class="hljs-built_in">key</span><span class="hljs-comment">//向字符串的后面追加字符，如果有就补在后面，如果没有就新建</span>append <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span></code></pre><h4 id="string-类型数据的扩展操作"><a href="#string-类型数据的扩展操作" class="headerlink" title="string 类型数据的扩展操作"></a>string 类型数据的扩展操作</h4><p> <strong>String作为数值的操作</strong></p><pre><code class="hljs gauss"><span class="hljs-comment">//增长指令，只有当value为数字时才能增长</span>incr <span class="hljs-built_in">key</span>  incrby <span class="hljs-built_in">key</span> increment  incrbyfloat <span class="hljs-built_in">key</span> increment <span class="hljs-comment">//减少指令，有当value为数字时才能减少</span>decr <span class="hljs-built_in">key</span>  decrby <span class="hljs-built_in">key</span> increment</code></pre><ul><li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。 </li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。 </li><li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。                 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><p><strong>tips：</strong></p><ul><li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong> </li><li>此方案适用于所有数据库，且支持数据库集群</li></ul><p><strong>指定生命周期</strong></p><pre><code class="hljs q"><span class="hljs-comment">//设置数据的生命周期，单位 秒</span>setex <span class="hljs-built_in">key</span> seconds <span class="hljs-built_in">value</span><span class="hljs-comment">//设置数据的生命周期，单位 毫秒</span>psetex <span class="hljs-built_in">key</span> milliseconds <span class="hljs-built_in">value</span></code></pre><p><strong>tips</strong></p><ul><li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 </li></ul><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142355.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、Hash"><a href="#2、Hash" class="headerlink" title="2、Hash"></a>2、Hash</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142425.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs q"><span class="hljs-comment">//插入（如果已存在同名的field，会被覆盖）</span>hset <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span>hmset <span class="hljs-built_in">key</span> field1 value1 field2 value2...<span class="hljs-comment">//插入（如果已存在同名的field，不会被覆盖）</span>hsetnx <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span><span class="hljs-comment">//取出</span>hget <span class="hljs-built_in">key</span> fieldhgetall <span class="hljs-built_in">key</span><span class="hljs-comment">//删除</span><span class="hljs-built_in">hdel</span> <span class="hljs-built_in">key</span> field1 field2...<span class="hljs-comment">//获取field数量</span>hlen <span class="hljs-built_in">key</span><span class="hljs-comment">//查看是否存在</span>hexists <span class="hljs-built_in">key</span> field<span class="hljs-comment">//获取哈希表中所有的字段名或字段值 </span>hkeys <span class="hljs-built_in">key</span>hvals <span class="hljs-built_in">key</span><span class="hljs-comment">//设置指定字段的数值数据增加指定范围的值 </span>hincrby <span class="hljs-built_in">key</span> field increment hdecrby <span class="hljs-built_in">key</span> field increment</code></pre><h4 id="hash-类型数据操作的注意事项"><a href="#hash-类型数据操作的注意事项" class="headerlink" title="hash 类型数据操作的注意事项"></a>hash 类型数据操作的注意事项</h4><ul><li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong> </li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈 </li></ul><h3 id="3、List"><a href="#3、List" class="headerlink" title="3、List"></a>3、List</h3><ul><li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 </li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 </li><li>list类型：保存多个数据，底层使用双向链表存储结构实现 </li><li><strong>元素有序，且可重</strong></li></ul><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs tcl">//添加修改数据,lpush为从左边添加，rpush为从右边添加lpush key value1 value2 value3...rpush key value1 value2 value3...//查看数据, 从左边开始向右查看. 如果不知道<span class="hljs-keyword">list</span>有多少个元素，end的值可以为<span class="hljs-number">-1</span>,代表倒数第一个元素//lpush先进的元素放在最后,rpush先进的元素放在最前面<span class="hljs-keyword">lrange</span> key start end//得到长度llen key//取出对应索引的元素<span class="hljs-keyword">lindex</span> key index//获取并移除元素（从<span class="hljs-keyword">list</span>左边或者右边移除）lpop keyrpop key</code></pre><h4 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs gams"><span class="hljs-comment">//规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除</span><span class="hljs-function"><span class="hljs-title">blpop</span></span> key1 key2... timeout<span class="hljs-function"><span class="hljs-title">brpop</span></span> key1 key2... timeout<span class="hljs-comment">//移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span>lrem key count value</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。 </li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作 </li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载 </li></ul><h3 id="4、Set"><a href="#4、Set" class="headerlink" title="4、Set"></a>4、Set</h3><ul><li><strong>不重复且无需</strong></li></ul><h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs gauss"><span class="hljs-comment">//添加元素</span>sadd <span class="hljs-built_in">key</span> member1 member2...<span class="hljs-comment">//查看元素</span>smembers <span class="hljs-built_in">key</span><span class="hljs-comment">//移除元素</span>srem <span class="hljs-built_in">key</span> member<span class="hljs-comment">//查看元素个数</span>scard <span class="hljs-built_in">key</span><span class="hljs-comment">//查看某个元素是否存在</span>sismember <span class="hljs-built_in">key</span> member</code></pre><h4 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h4><pre><code class="hljs gams"><span class="hljs-comment">//从set中任意选出count个元素</span>srandmember key count<span class="hljs-comment">//从set中任意选出count个元素并移除</span>spop key count<span class="hljs-comment">//求两个集合的交集、并集、差集</span><span class="hljs-function"><span class="hljs-title">sinter</span></span> key1 key2...<span class="hljs-function"><span class="hljs-title">sunion</span></span> key1 key2...<span class="hljs-function"><span class="hljs-title">sdiff</span></span> key1 key2...<span class="hljs-comment">//求两个set的交集、并集、差集，并放入另一个set中</span><span class="hljs-function"><span class="hljs-title">sinterstore</span></span> destination key1 key2...<span class="hljs-function"><span class="hljs-title">sunionstore</span></span> destination key1 key2...<span class="hljs-function"><span class="hljs-title">sdiffstore</span></span> destination key1 key2...<span class="hljs-comment">//求指定元素从原集合放入目标集合中</span>smove source destination key</code></pre><h3 id="5、sorted-set"><a href="#5、sorted-set" class="headerlink" title="5、sorted_set"></a>5、sorted_set</h3><ul><li><p><strong>不重但有序（score）</strong></p></li><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式 </p></li><li><p>需要的存储结构：新的存储模型，可以保存<strong>可排序</strong>的数据 </p></li><li><p>sorted_set类型：在set的存储结构基础上添加可排序字段 </p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142442.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs sql">//插入元素, 需要指定score(用于排序)zadd key score1 member1 score2 member2//查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来zrange key <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)//查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来zrevrange <span class="hljs-keyword">key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)//移除元素zrem <span class="hljs-keyword">key</span> member1 member2...//按条件获取数据, 其中<span class="hljs-keyword">offset</span>为索引开始位置，<span class="hljs-keyword">count</span>为获取的数目zrangebyscore <span class="hljs-keyword">key</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span> [withscore] [<span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span> <span class="hljs-keyword">count</span>]zrevrangebyscore <span class="hljs-keyword">key</span> <span class="hljs-keyword">max</span> <span class="hljs-keyword">min</span> [withscore] [<span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span> <span class="hljs-keyword">count</span>]//按条件移除元素zremrangebyrank <span class="hljs-keyword">key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>zremrangebysocre <span class="hljs-keyword">key</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span>//按照从大到小的顺序移除<span class="hljs-keyword">count</span>个值zpopmax <span class="hljs-keyword">key</span> [<span class="hljs-keyword">count</span>]//按照从小到大的顺序移除<span class="hljs-keyword">count</span>个值zpopmin <span class="hljs-keyword">key</span> [<span class="hljs-keyword">count</span>]//获得元素个数zcard <span class="hljs-keyword">key</span>//获得元素在范围内的个数zcount <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span>//求交集、并集并放入destination中, 其中numkey1为要去交集或并集集合的数目zinterstore destination numkeys key1 key2...zunionstore destination numkeys key1 key2...</code></pre><p><strong>注意</strong></p><ul><li>min与max用于限定搜索查询的<strong>条件</strong> </li><li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引 </li><li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong> </li></ul><h4 id="拓展操作-1"><a href="#拓展操作-1" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs maxima">//查看某个元素的索引(排名)zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>//查看某个元素索引的值zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>//增加某个元素索引的值zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992 </li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong> </li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果 </li></ul><h2 id="三、通用指令"><a href="#三、通用指令" class="headerlink" title="三、通用指令"></a>三、通用指令</h2><h3 id="1、Key的特征"><a href="#1、Key的特征" class="headerlink" title="1、Key的特征"></a>1、Key的特征</h3><ul><li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据 </li></ul><h3 id="2、Key的操作"><a href="#2、Key的操作" class="headerlink" title="2、Key的操作"></a>2、Key的操作</h3><h4 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs gauss"><span class="hljs-comment">//查看key是否存在</span>exists <span class="hljs-built_in">key</span><span class="hljs-comment">//删除key</span>del <span class="hljs-built_in">key</span><span class="hljs-comment">//查看key的类型</span><span class="hljs-built_in">type</span> <span class="hljs-built_in">key</span></code></pre><h4 id="拓展操作（时效性操作）"><a href="#拓展操作（时效性操作）" class="headerlink" title="拓展操作（时效性操作）"></a>拓展操作（时效性操作）</h4><pre><code class="hljs gauss"><span class="hljs-comment">//设置生命周期</span>expire <span class="hljs-built_in">key</span> secondspexpire <span class="hljs-built_in">key</span> milliseconds<span class="hljs-comment">//查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span>ttl <span class="hljs-built_in">key</span>pttl <span class="hljs-built_in">key</span><span class="hljs-comment">//将有时限的数据设置为永久有效</span>persist <span class="hljs-built_in">key</span></code></pre><h4 id="拓展操作（查询操作）"><a href="#拓展操作（查询操作）" class="headerlink" title="拓展操作（查询操作）"></a>拓展操作（查询操作）</h4><pre><code class="hljs q"><span class="hljs-comment">//根据key查询符合条件的数据</span><span class="hljs-built_in">keys</span> pattern</code></pre><p><strong>查询规则</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142500.png" srcset="/img/loading.gif" alt=""></p><h4 id="拓展操作（其他操作）"><a href="#拓展操作（其他操作）" class="headerlink" title="拓展操作（其他操作）"></a>拓展操作（其他操作）</h4><pre><code class="hljs haxe"><span class="hljs-comment">//重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx</span>rename key <span class="hljs-keyword">new</span><span class="hljs-type">Key</span><span class="hljs-type">renamenx</span> key <span class="hljs-keyword">new</span><span class="hljs-type">Key</span><span class="hljs-type"></span><span class="hljs-type"></span>//查看所有关于key的操作, 可以使用Tab快速切换help @generic</code></pre><h3 id="3、数据库通用操作"><a href="#3、数据库通用操作" class="headerlink" title="3、数据库通用操作"></a>3、数据库通用操作</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>Redis为每个服务提供有16个数据库，编号从0到15 </li><li>每个数据库之间的数据相互独立 </li></ul><h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>切换数据库 0~15select index<span class="hljs-string">//</span>其他操作<span class="hljs-keyword">quit</span>ping<span class="hljs-keyword">echo</span> massage</code></pre><h4 id="拓展操作-2"><a href="#拓展操作-2" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs stata"><span class="hljs-comment">//移动数据, 必须保证目的数据库中没有该数据</span><span class="hljs-keyword">mov</span> key <span class="hljs-keyword">db</span><span class="hljs-comment">//查看该库中数据总量</span>dbsize</code></pre><h2 id="三、Jedis"><a href="#三、Jedis" class="headerlink" title="三、Jedis"></a>三、Jedis</h2><p><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</p><h3 id="1、Java操作redis的步骤"><a href="#1、Java操作redis的步骤" class="headerlink" title="1、Java操作redis的步骤"></a>1、Java操作redis的步骤</h3><ul><li>连接Redis</li></ul><pre><code class="hljs java"><span class="hljs-comment">//参数为Redis所在的ip地址和端口号</span>Jedis jedis = <span class="hljs-keyword">new</span> Jedis(String host, <span class="hljs-keyword">int</span> port)</code></pre><ul><li>操作Redis</li></ul><pre><code class="hljs java"><span class="hljs-comment">//操作redis的指令和redis本身的指令几乎一致</span>jedis.set(String key, String value);</code></pre><ul><li>断开连接</li></ul><pre><code class="hljs java">jedis.close();</code></pre><h3 id="2、配置工具"><a href="#2、配置工具" class="headerlink" title="2、配置工具"></a>2、配置工具</h3><ul><li>配置文件</li></ul><pre><code class="hljs properties"><span class="hljs-meta">redis.host</span>=<span class="hljs-string">47.103.10.63</span><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">redis.maxTotal</span>=<span class="hljs-string">30</span><span class="hljs-meta">redis.maxIdle</span>=<span class="hljs-string">10</span></code></pre><ul><li>工具类</li></ul><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<span class="hljs-keyword">import</span> java.util.ResourceBundle;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/4/6 16:24</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtil</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis jedis = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<span class="hljs-comment">//使用静态代码块，只加载一次</span><span class="hljs-keyword">static</span> &#123;<span class="hljs-comment">//读取配置文件</span>ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="hljs-string">"redis"</span>);<span class="hljs-comment">//获取配置文件中的数据</span>host = resourceBundle.getString(<span class="hljs-string">"redis.host"</span>);port = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.port"</span>));<span class="hljs-comment">//读取最大连接数</span>maxTotal = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.maxTotal"</span>));<span class="hljs-comment">//读取最大活跃数</span>maxIdle = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.maxIdle"</span>));JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();jedisPoolConfig.setMaxTotal(maxTotal);jedisPoolConfig.setMaxIdle(maxIdle);<span class="hljs-comment">//获取连接池</span>JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, host, port);jedis = jedisPool.getResource();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> jedis;&#125;&#125;</code></pre><h2 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h2><h3 id="Redis容器配置redis-conf"><a href="#Redis容器配置redis-conf" class="headerlink" title="Redis容器配置redis.conf"></a>Redis容器配置redis.conf</h3><ul><li><p>redis容器里边的配置文件是需要在<strong>创建容器时映射</strong>进来的 </p><pre><code class="hljs axapta">停止容器：docker <span class="hljs-keyword">container</span> stop myredis删除容器：docker <span class="hljs-keyword">container</span> rm myredis</code></pre></li><li><p>重新开始创建容器</p><pre><code class="hljs groovy"><span class="hljs-number">1.</span> 创建docker统一的外部配置文件mkdir -p docker<span class="hljs-regexp">/redis/</span>&#123;conf,data&#125;<span class="hljs-number">2.</span> 在conf目录创建redis.conf的配置文件touch <span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<span class="hljs-number">3.</span> redis.conf文件的内容需要自行去下载，网上很多<span class="hljs-number">4.</span> 创建启动容器，加载配置文件并持久化数据docker run -d --privileged=<span class="hljs-literal">true</span> -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v <span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.<span class="hljs-string">conf:</span><span class="hljs-regexp">/etc/</span>redis<span class="hljs-regexp">/redis.conf -v /</span>docker<span class="hljs-regexp">/redis/</span><span class="hljs-string">data:</span><span class="hljs-regexp">/data --name myredis redis redis-server /</span>etc<span class="hljs-regexp">/redis/</span>redis.conf --appendonly yes</code></pre></li><li><p>文件目录</p><pre><code class="hljs awk"><span class="hljs-regexp">/docker/</span>redis</code></pre></li></ul><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h4><p>利用<strong>永久性</strong>存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。 </p><h4 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h4><p><strong>防止</strong>数据的意外<strong>丢失</strong>，确保数据<strong>安全性</strong> </p><h4 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h4><ul><li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong> </li><li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong> </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142523.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h3><h4 id="RDB启动方式——save"><a href="#RDB启动方式——save" class="headerlink" title="RDB启动方式——save"></a>RDB启动方式——save</h4><ul><li><p>命令</p><pre><code class="hljs ebnf"><span class="hljs-attribute">save</span></code></pre></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><h4 id="RDB配置相关命令"><a href="#RDB配置相关命令" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul><li>dbfilename dump.rdb <ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb </li><li>经验：通常设置为dump-端口号.rdb</li></ul></li><li>dir<ul><li>说明：设置存储.rdb文件的路径 </li><li>经验：通常设置成存储空间较大的目录中，目录名称data </li></ul></li><li>rdbcompression yes <ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 </li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大） </li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 </li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险 </li></ul></li></ul><h4 id="RDB启动方式——save指令工作原理"><a href="#RDB启动方式——save指令工作原理" class="headerlink" title="RDB启动方式——save指令工作原理"></a>RDB启动方式——save指令工作原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142541.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：<strong>save指令</strong>的执行会<strong>阻塞</strong>当前Redis服务器，直到当前RDB过程完成为止，有可能会造成<strong>长时间阻塞</strong>，线上环境<strong>不建议使用</strong>。   </p><h4 id="RDB启动方式——bgsave"><a href="#RDB启动方式——bgsave" class="headerlink" title="RDB启动方式——bgsave"></a>RDB启动方式——bgsave</h4><ul><li><p>命令</p><pre><code class="hljs ebnf"><span class="hljs-attribute">bgsave</span></code></pre></li><li><p>作用</p><p>手动启动后台保存操作，但<strong>不是立即执行</strong> </p></li></ul><h4 id="RDB启动方式-——-bgsave指令工作原理"><a href="#RDB启动方式-——-bgsave指令工作原理" class="headerlink" title="RDB启动方式 —— bgsave指令工作原理"></a>RDB启动方式 —— bgsave指令工作原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142558.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>： <strong>bgsave命令</strong>是针对save阻塞问题做的<strong>优化</strong>。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用，推荐使用bgsave</p><p><strong>bgsave的保存操作可以通过redis的日志查看</strong></p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker logs myredis</span></code></pre><h4 id="RDB启动方式-——save配置"><a href="#RDB启动方式-——save配置" class="headerlink" title="RDB启动方式 ——save配置"></a>RDB启动方式 ——save配置</h4><ul><li><p>配置</p><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes</code></pre></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化 </p></li><li><p>参数</p><ul><li>second：监控时间范围 </li><li>changes：监控key的变化量 </li></ul></li><li><p>配置位置</p><p>在<strong>conf文件</strong>中进行配置 </p></li></ul><h4 id="RDB启动方式-——save配置原理"><a href="#RDB启动方式-——save配置原理" class="headerlink" title="RDB启动方式 ——save配置原理"></a>RDB启动方式 ——save配置原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142617.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 </li><li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系 </li><li>save配置启动后执行的是<strong>bgsave操作</strong> </li></ul><h4 id="RDB启动方式对比"><a href="#RDB启动方式对比" class="headerlink" title="RDB启动方式对比"></a>RDB启动方式对比</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142629.png" srcset="/img/loading.gif" alt=""></p><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong> </li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景 </li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong> </li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象 </li></ul></li></ul><h3 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h3><h4 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h4><ul><li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程  </li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式 </li></ul><h4 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142645.png" srcset="/img/loading.gif" alt=""></p><h4 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h4><ul><li>always<ul><li>每次写入操作均同步到AOF文件中，数据零误差，<strong>性能较低</strong>,<strong>不建议使用</strong></li></ul></li><li>everysec<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置 </li><li>在系统突然宕机的情况下丢失1秒内的数据 </li></ul></li><li>no<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong> </li></ul></li></ul><h4 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h4><ul><li><p>配置</p><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span></code></pre><ul><li>​    作用<ul><li>是否开启AOF持久化功能，<strong>默认为不开启状态</strong> </li></ul></li></ul></li><li><p>配置</p><pre><code class="hljs coq">appendfsync always|<span class="hljs-type">everysec</span>|<span class="hljs-type">no</span></code></pre><ul><li>作用<ul><li>AOF写数据策略 </li></ul></li></ul></li></ul><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>降低磁盘占用量，提高磁盘利用率 </li><li>提高持久化效率，降低持久化写时间，提高IO性能 </li><li>降低数据恢复用时，提高数据恢复效率 </li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>进程内已超时的数据不再写入文件 </li><li>忽略<strong>无效指令</strong>，重写时使用进程内数据直接生成，这样新的AOF文件<strong>只保留最终数据的写入命令</strong><ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 </li></ul></li><li>对同一数据的多条写命令合并为一条命令 <ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 </li></ul></li></ul><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>手动重写</p><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span></code></pre></li><li><p>自动重写</p><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-<span class="hljs-built_in">min</span>-<span class="hljs-built_in">size</span> <span class="hljs-built_in">size</span> <span class="hljs-keyword">auto</span>-aof-rewrite-percentage percentage</code></pre></li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142657.png" srcset="/img/loading.gif" alt=""></p><h5 id="AOF自动重写"><a href="#AOF自动重写" class="headerlink" title="AOF自动重写"></a>AOF自动重写</h5><ul><li><p>自动重写触发条件设置 </p><pre><code class="hljs arduino"><span class="hljs-comment">//触发重写的最小大小</span><span class="hljs-keyword">auto</span>-aof-rewrite-<span class="hljs-built_in">min</span>-<span class="hljs-built_in">size</span> <span class="hljs-built_in">size</span> <span class="hljs-comment">//触发重写须达到的最小百分比</span><span class="hljs-keyword">auto</span>-aof-rewrite-percentage percent</code></pre></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） </p><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>当前<span class="hljs-string">.aof</span>的文件大小aof_current_size <span class="hljs-string">//</span>基础文件大小aof_base_size</code></pre></li><li><p>自动重写触发条件 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142715.png" srcset="/img/loading.gif" alt=""></p></li></ul><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142734.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142755.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142814.png" srcset="/img/loading.gif" alt=""></p><h5 id="缓冲策略"><a href="#缓冲策略" class="headerlink" title="缓冲策略"></a>缓冲策略</h5><p> AOF缓冲区同步文件策略，由参数<strong>appendfsync</strong>控制 </p><ul><li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用 来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依 赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之 前，如果此时系统故障宕机，缓冲区内数据将丢失。 </li><li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道 写入硬盘完成后返回，保证了数据持久化。 </li></ul><h4 id="4、RDB-VS-AOF"><a href="#4、RDB-VS-AOF" class="headerlink" title="4、RDB VS AOF"></a>4、RDB VS AOF</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142837.png" srcset="/img/loading.gif" alt=""></p><h5 id="RDB与AOF的选择之惑"><a href="#RDB与AOF的选择之惑" class="headerlink" title="RDB与AOF的选择之惑"></a>RDB与AOF的选择之惑</h5><ul><li>对数据非常<strong>敏感</strong>，建议使用默认的<strong>AOF</strong>持久化方案  <ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。 </li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong> </li></ul></li><li>数据呈现<strong>阶段有效性</strong>，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案 </li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li>综合比对 <ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 </li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong> </li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong> </li><li><strong>灾难恢复选用RDB</strong> </li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li></ul></li></ul><h2 id="五、Redis事务"><a href="#五、Redis事务" class="headerlink" title="五、Redis事务"></a>五、Redis事务</h2><h3 id="1、Redis事务的定义"><a href="#1、Redis事务的定义" class="headerlink" title="1、Redis事务的定义"></a>1、Redis事务的定义</h3><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p><h3 id="2、事务的基本操作"><a href="#2、事务的基本操作" class="headerlink" title="2、事务的基本操作"></a>2、事务的基本操作</h3><ul><li><p>开启事务</p><pre><code class="hljs ebnf"><span class="hljs-attribute">multi</span></code></pre><ul><li>作用<ul><li>作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中 </li></ul></li></ul></li><li><p>取消事务</p><pre><code class="hljs ebnf"><span class="hljs-attribute">discard</span></code></pre><ul><li>作用<ul><li>终止当前事务的定义，发生在multi之后，exec之前 </li></ul></li></ul></li><li><p>执行事务</p><pre><code class="hljs bash"><span class="hljs-built_in">exec</span></code></pre><ul><li>作用<ul><li>设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用 </li></ul></li></ul></li></ul><h3 id="3、事务操作的基本流程"><a href="#3、事务操作的基本流程" class="headerlink" title="3、事务操作的基本流程"></a>3、事务操作的基本流程</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142857.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、事务操作的注意事项"><a href="#4、事务操作的注意事项" class="headerlink" title="4、事务操作的注意事项"></a>4、事务操作的注意事项</h3><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p><ul><li>语法错误 <ul><li>指命令书写格式有误  例如执行了一条不存在的指令</li></ul></li><li>处理结果 <ul><li>如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li></ul></li></ul><p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong> </p><ul><li>运行错误 <ul><li>指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作 </li></ul></li><li>处理结果 <ul><li>能够正确运行的命令会执行，运行错误的命令不会被执行 </li></ul></li></ul><p><strong>注意</strong>：已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。 </p><h3 id="5、基于特定条件的事务执行"><a href="#5、基于特定条件的事务执行" class="headerlink" title="5、基于特定条件的事务执行"></a>5、基于特定条件的事务执行</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">watch</span></span> key1, key2....</code></pre></li><li><p>取消对<strong>所有</strong>key的监视</p><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span></code></pre></li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li><p>使用 setnx 设置一个公共锁 </p><pre><code class="hljs cs"><span class="hljs-comment">//上锁</span>setnx <span class="hljs-keyword">lock</span>-key <span class="hljs-keyword">value</span><span class="hljs-comment">//释放锁</span>del <span class="hljs-keyword">lock</span>-key</code></pre><ul><li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li><li>操作完毕通过del操作释放锁 </li></ul></li></ul><p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性 </p><h4 id="分布式锁加强"><a href="#分布式锁加强" class="headerlink" title="分布式锁加强"></a>分布式锁加强</h4><ul><li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁 </p><pre><code class="hljs sql">expire <span class="hljs-keyword">lock</span>-<span class="hljs-keyword">key</span> <span class="hljs-keyword">seconds</span>pexpire <span class="hljs-keyword">lock</span>-<span class="hljs-keyword">key</span> milliseconds</code></pre></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。 </p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。 </li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时 </li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110% </li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可 </li></ul></li></ul><h2 id="六、删除策略"><a href="#六、删除策略" class="headerlink" title="六、删除策略"></a>六、删除策略</h2><h3 id="1、数据删除策略"><a href="#1、数据删除策略" class="headerlink" title="1、数据删除策略"></a>1、数据删除策略</h3><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><ul><li>Redis中的数据，在expire中以哈希的方式保存在其中。其value是数据在内存中的地址，filed是对应的生命周期</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142921.png" srcset="/img/loading.gif" alt=""></p><h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露 </p><h3 id="2、三种删除策略"><a href="#2、三种删除策略" class="headerlink" title="2、三种删除策略"></a>2、三种删除策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><ul><li><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</p></li><li><p>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用  </p></li><li><p>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </p></li><li><p>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</p></li></ul><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><ul><li>数据到达过期时间，不做处理。等下次访问该数据时 <ul><li>如果未过期，返回数据 </li><li>发现已过期，删除，返回不存在 </li></ul></li><li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除 </li><li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据 </li><li>总结：用存储空间换取处理器性能 （拿空间换时间） </li></ul><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142941.png" srcset="/img/loading.gif" alt=""></p><ul><li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度 </li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置 </li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 </li><li>总结：周期性抽查存储空间 （随机抽查，重点抽查） </li></ul><h3 id="3、逐出算法"><a href="#3、逐出算法" class="headerlink" title="3、逐出算法"></a>3、逐出算法</h3><p>*<em>当新数据进入redis时，如果内存不足怎么办？ *</em></p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()</strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为<strong>逐出算法</strong></li><li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 </li></ul><h4 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><ul><li><p>最大可使用内存 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span></code></pre><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。 </p></li><li><p>每次选取待删除数据的个数 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span></code></pre><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据 </p></li><li><p>删除策略</p><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span></code></pre><p>达到最大内存后的，对被挑选出来的数据进行删除的策略 </p></li></ul><h4 id="影响数据逐出的相关配置-1"><a href="#影响数据逐出的相关配置-1" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142953.png" srcset="/img/loading.gif" alt=""></p><p><strong>LRU</strong>：最长时间没被使用的数据</p><p><strong>LFU</strong>：一段时间内使用次数最少的数据</p><h4 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a><strong>数据逐出策略配置依据</strong></h4><ul><li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143004.png" srcset="/img/loading.gif" alt=""></p><h2 id="七、高级数据类型"><a href="#七、高级数据类型" class="headerlink" title="七、高级数据类型"></a>七、高级数据类型</h2><h3 id="1、Bitmaps"><a href="#1、Bitmaps" class="headerlink" title="1、Bitmaps"></a>1、Bitmaps</h3><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li><p>获取指定key对应偏移量上的bit值 </p><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span></code></pre></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0 </p><pre><code class="hljs excel">setbit key <span class="hljs-built_in">offset</span> <span class="hljs-built_in">value</span></code></pre></li></ul><h4 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h4><ul><li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中 </p><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key1<span class="hljs-meta"> [key2...]</span></code></pre><ul><li>and：交 </li><li>or：并 </li><li>not：非 </li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量 </p><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]</code></pre></li></ul><h3 id="2、HyperLogLog"><a href="#2、HyperLogLog" class="headerlink" title="2、HyperLogLog"></a>2、HyperLogLog</h3><h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><ul><li>基数是数据集<strong>去重后元素个数</strong> </li><li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143020.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加数据</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfadd</span></span> key element1, element2...</code></pre></li><li><p>统计数据</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfcount</span></span> key1 key2....</code></pre></li><li><p>合并数据</p><pre><code class="hljs apache"><span class="hljs-attribute">pfmerge</span> destkey sourcekey<span class="hljs-meta"> [sourcekey...]</span></code></pre></li></ul><h4 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h4><ul><li>用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据 </li><li>核心是基数估算算法，最终数值<strong>存在一定误差</strong> </li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数 </li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong> </li><li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少 </li></ul><h3 id="3、GEO"><a href="#3、GEO" class="headerlink" title="3、GEO"></a>3、GEO</h3><h4 id="基本操作-8"><a href="#基本操作-8" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加坐标点</p><pre><code class="hljs routeros">geoadd key longitude latitude member [longitude latitude member <span class="hljs-built_in">..</span>.] georadius key longitude latitude<span class="hljs-built_in"> radius </span>m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code></pre></li><li><p>获取坐标点</p><pre><code class="hljs routeros">geopos key member [member <span class="hljs-built_in">..</span>.] georadiusbymember key member<span class="hljs-built_in"> radius </span>m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code></pre></li><li><p>计算坐标点距离 </p><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]</code></pre></li></ul><h2 id="八、主从复制"><a href="#八、主从复制" class="headerlink" title="八、主从复制"></a>八、主从复制</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a>多台服务器连接方案</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143033.png" srcset="/img/loading.gif" alt=""></p><ul><li>提供数据方：master <ul><li>主服务器，主节点，主库</li><li>主客户端</li></ul></li><li>接收数据的方：slave<ul><li>从服务器，从节点，从库</li><li>从客户端</li></ul></li><li>需要解决的问题<ul><li><strong>数据同步</strong></li></ul></li><li>核心工作<ul><li>master的数据<strong>复制</strong>到slave中 </li></ul></li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中 </p><p>特征：一个master可以拥有多个slave，一个slave只对应一个master </p><p>职责： </p><ul><li>master: <ul><li>写数据 </li><li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave </li><li>读数据（可忽略） </li></ul></li><li>slave: <ul><li>读数据 </li><li>写数据（<strong>禁止</strong>） </li></ul></li></ul><h3 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h3><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力 </li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 </li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 </li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 </li></ul><h3 id="3、工作流程"><a href="#3、工作流程" class="headerlink" title="3、工作流程"></a>3、工作流程</h3><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a><strong>总述</strong></h4><ul><li>主从复制过程大体可以分为3个阶段 <ul><li>建立连接阶段（即准备阶段） </li><li>数据同步阶段 </li><li>命令传播阶段 </li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143046.png" srcset="/img/loading.gif" alt=""></p><h4 id="阶段一：建立连接"><a href="#阶段一：建立连接" class="headerlink" title="阶段一：建立连接"></a>阶段一：建立连接</h4><ul><li><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号  </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143102.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>*<em>主从连接（slave连接master） *</em></p><ul><li><p>方式一：客户端发送命令 </p><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre></li><li><p>方式二：启动服务器参数</p><pre><code class="hljs xml">redis-server -slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre></li><li><p>方式三：服务器配置 （常用）</p><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre><p><img src="C:%5CUsers%5C86183%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421083330289.png" srcset="/img/loading.gif" alt="image-20200421083330289"></p></li></ul><p><strong>主从断开连接</strong></p><ul><li><p><strong>客户端</strong>发送命令  </p><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one</code></pre><ul><li>说明： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据 </li></ul></li></ul><p><strong>授权访问</strong></p><ul><li><p>master客户端发送命令设置密码 </p><pre><code class="hljs xml">requirepass <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>master配置文件设置密码</p><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> requirepass &lt;password&gt; config <span class="hljs-builtin-name">get</span> requirepass</code></pre></li><li><p>slave客户端发送命令设置密码 </p><pre><code class="hljs xml">auth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>slave配置文件设置密码 </p><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>slave启动服务器设置密码 </p><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> –a &lt;<span class="hljs-keyword">password</span>&gt;</code></pre></li></ul><h4 id="阶段二：数据同步阶段"><a href="#阶段二：数据同步阶段" class="headerlink" title="阶段二：数据同步阶段"></a>阶段二：数据同步阶段</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143117.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>全量复制</strong><ul><li>将master执行bgsave之前，master中所有的数据同步到slave中</li></ul></li><li><strong>部分复制</strong>（增量复制）<ul><li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li></ul></li></ul><h5 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h5><ol><li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行 </li><li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。 </li></ol><pre><code class="hljs angelscript">repl-backlog-size <span class="hljs-number">1</span>mb</code></pre><ol start="3"><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li></ol><h5 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h5><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务 </li></ol><pre><code class="hljs coffeescript">slave-serve-stale-data <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span></code></pre><ol start="2"><li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li><li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰 </li><li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></li></ol><h4 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h4><ul><li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong> </li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 </li></ul><ul><li>主从复制过程大体可以分为3个阶段 <ul><li>建立连接阶段（即准备阶段） </li><li>数据同步阶段 </li><li>命令传播阶段 </li></ul></li></ul><h5 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h5><ul><li>命令传播阶段出现了断网现象 <ul><li>网络闪断闪连 </li><li>短时间网络中断 </li><li>长时间网络中断 </li></ul></li></ul><ul><li><p>部分复制的<strong>三个核心要素</strong> </p><ul><li><p>服务器的运行 id（run id） </p></li><li><p>主服务器的复制积压缓冲区 </p></li><li><p>主从服务器的复制偏移量 </p></li></ul></li></ul><h5 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h5><ul><li><p>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id </p></li><li><p>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如- - </p><ul><li>fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce </li></ul></li><li><p>作用：运行id被用于在服务器间进行传输，识别身份 </p><ul><li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 </li></ul></li><li><p>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid </p></li></ul><h5 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h5><ul><li><p>概念：复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 </p></li><li><p>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </p></li><li><p>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） </p></li><li><p>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 </p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143134.png" srcset="/img/loading.gif" alt=""></p><h5 id="复制缓冲区内部工作原理"><a href="#复制缓冲区内部工作原理" class="headerlink" title="复制缓冲区内部工作原理"></a>复制缓冲区内部工作原理</h5><ul><li><p>组成 </p><ul><li>偏移量 </li><li>字节值 </li></ul></li><li><p>工作原理 </p><ul><li>通过offset区分不同的slave当前数据传播的差异 </li><li>master记录<strong>已发送</strong>的信息对应的offset </li><li>slave记录<strong>已接收</strong>的信息对应的offset </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143149.png" srcset="/img/loading.gif" alt=""></p></li></ul><h5 id="主从服务器复制偏移量（offset）"><a href="#主从服务器复制偏移量（offset）" class="headerlink" title="主从服务器复制偏移量（offset）"></a>主从服务器复制偏移量（offset）</h5><ul><li><p>概念：一个数字，描述复制缓冲区中的指令字节位置 </p></li><li><p>分类： </p><ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） </li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） </li></ul></li><li><p>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次 </p></li><li><p>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用 </p></li></ul><h5 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143228.png" srcset="/img/loading.gif" alt=""></p><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><ul><li><p>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 </p></li><li><p>master心跳： </p><ul><li>指令：PING </li><li>周期：由repl-ping-slave-period决定，默认10秒 </li><li>作用：判断slave是否在线 </li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 </li></ul></li><li><p>slave心跳任务 </p><ul><li>指令：REPLCONF ACK {offset} </li><li>周期：1秒 </li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 </li><li>作用2：判断master是否在线 </li></ul></li></ul><h5 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h5><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span> <span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span></code></pre><ul><li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 </li></ul></li><li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认 </p></li><li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li></ul><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143241.png" srcset="/img/loading.gif" alt=""></p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143304.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143317.png" srcset="/img/loading.gif" alt=""></p><h4 id="频繁的网络中断"><a href="#频繁的网络中断" class="headerlink" title="频繁的网络中断"></a>频繁的网络中断</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143327.png" srcset="/img/loading.gif" alt=""></p><p><img src="D:%5C%E5%90%8E%E7%AB%AF%E8%B5%84%E6%96%99NEW%5C%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%5CRedis%5CRedis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3.assets%5Cimage-20200608143339306.png" srcset="/img/loading.gif" alt="image-20200608143339306"></p><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143352.png" srcset="/img/loading.gif" alt=""></p><h2 id="九、哨兵"><a href="#九、哨兵" class="headerlink" title="九、哨兵"></a>九、哨兵</h2><h3 id="1、简介-2"><a href="#1、简介-2" class="headerlink" title="1、简介"></a>1、简介</h3><p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的master并将所有slave连接到新的master。 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143401.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、作用-1"><a href="#2、作用-1" class="headerlink" title="2、作用"></a>2、作用</h3><ul><li>监控 <ul><li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测 </li></ul></li><li>通知（提醒）<ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 </li></ul></li><li>自动故障转移 <ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址 </li></ul></li></ul><p><strong>注意：</strong><br>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong> </p><h3 id="3、配置哨兵"><a href="#3、配置哨兵" class="headerlink" title="3、配置哨兵"></a>3、配置哨兵</h3><ul><li><p>配置一拖二的主从结构  </p></li><li><p>配置三个哨兵（配置相同，端口不同） </p><ul><li>参看sentinel.conf</li></ul></li><li><p>启动哨兵 </p><pre><code class="hljs css"><span class="hljs-selector-tag">redis-sentinel</span> <span class="hljs-selector-tag">sentinel</span>端口号 <span class="hljs-selector-class">.conf</span></code></pre></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143413.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、工作原理"><a href="#4、工作原理" class="headerlink" title="4、工作原理"></a>4、工作原理</h3><h4 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h4><ul><li>用于同步各个节点的状态信息 <ul><li>获取各个sentinel的状态（是否在线） </li></ul></li><li>获取master的状态 <ul><li>master属性 <ul><li>runid </li><li>role：master </li><li>各个slave的详细信息 </li></ul></li></ul></li><li>获取所有slave的状态（根据master中的slave信息） <ul><li>slave属性 <ul><li>runid </li><li>role：slave </li><li>master_host、master_port </li><li>offset</li><li>…</li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143539.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143602.png" srcset="/img/loading.gif" alt=""></p><h4 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h4><ul><li>各个哨兵将得到的信息相互同步（信息对称）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143614.png" srcset="/img/loading.gif" alt=""></p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><h5 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h5><ul><li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li><li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143633.png" srcset="/img/loading.gif" alt=""></p><h5 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h5><ul><li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li><li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143649.png" srcset="/img/loading.gif" alt=""></p><h5 id="具体处理"><a href="#具体处理" class="headerlink" title="具体处理"></a>具体处理</h5><ul><li>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：<ul><li>服务器列表中挑选备选master </li><li>在线的 </li><li>响应慢的 </li><li>与原master断开时间久的 </li><li>优先原则 <ul><li>优先级 </li><li>offset </li><li>runid </li></ul></li><li>发送指令（ sentinel ） <ul><li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li><li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li></ul></li></ul></li></ul><h2 id="十、集群"><a href="#十、集群" class="headerlink" title="十、集群"></a>十、集群</h2><h3 id="1、简介-3"><a href="#1、简介-3" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><ul><li>集群就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果 </li></ul><h4 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h4><ul><li>分散单台服务器的访问压力，实现<strong>负载均衡</strong> </li><li>分散单台服务器的存储压力，实现<strong>可扩展性</strong> </li><li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong> </li></ul><h3 id="2、Redis集群结构设计"><a href="#2、Redis集群结构设计" class="headerlink" title="2、Redis集群结构设计"></a>2、Redis集群结构设计</h3><h4 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h4><ul><li>通过算法设计，计算出key应该保存的位置 </li><li>将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143701.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143712.png" srcset="/img/loading.gif" alt=""></p><ul><li>增强可扩展性 ——槽</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143720.png" srcset="/img/loading.gif" alt=""></p><h4 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h4><ul><li>各个数据库互相连通，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143733.png" srcset="/img/loading.gif" alt=""></p><h2 id="十一、企业级解决方案"><a href="#十一、企业级解决方案" class="headerlink" title="十一、企业级解决方案"></a>十一、企业级解决方案</h2><h3 id="1、缓存预热"><a href="#1、缓存预热" class="headerlink" title="1、缓存预热"></a>1、缓存预热</h3><h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4><ul><li>请求数量较高 </li><li>主从之间数据吞吐量较大，数据同步操作频度较高 </li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>前置准备工作： <ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据 </li><li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合 </li></ul></li><li>准备工作： <ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据 </li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程 </li><li>热点数据主从同时预热 </li></ul></li><li>实施： <ul><li>使用脚本程序固定触发数据预热过程 </li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好 </li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ </p><h3 id="2、缓存雪崩"><a href="#2、缓存雪崩" class="headerlink" title="2、缓存雪崩"></a>2、缓存雪崩</h3><h4 id="数据库服务器崩溃（1）"><a href="#数据库服务器崩溃（1）" class="headerlink" title="数据库服务器崩溃（1）"></a>数据库服务器崩溃（1）</h4><ol><li>系统平稳运行过程中，忽然数据库连接量激增 </li><li>应用服务器无法及时处理请求 </li><li>大量408，500错误页面出现 </li><li>客户反复刷新页面获取数据 </li><li>数据库崩溃 </li><li>应用服务器崩溃 </li><li>重启应用服务器无效 </li><li>Redis服务器崩溃  </li><li>Redis集群崩溃 </li><li>重启数据库后再次被瞬间流量放倒 </li></ol><h4 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>在一个<strong>较短</strong>的时间内，缓存中较多的key<strong>集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据 </li><li>数据库同时接收到大量的请求无法及时处理 </li><li>Redis大量请求被积压，开始出现超时现象 </li><li>数据库流量激增，数据库崩溃 </li><li>重启后仍然面对缓存中无数据可用 </li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解 </li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想 </li></ol><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>短时间范围内</li><li>大量key集中过期 </li></ul><h4 id="解决方案（道）"><a href="#解决方案（道）" class="headerlink" title="解决方案（道）"></a>解决方案（道）</h4><ol><li>更多的页面静态化处理 </li><li>构建<strong>多级缓存架构</strong> Nginx缓存+redis缓存+ehcache缓存 </li><li>检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查：例如超时查询、耗时较高事务等 </li><li>灾难预警机制 监控redis服务器性能指标 <ul><li>CPU占用、CPU使用率 </li><li>内存容量</li><li>查询平均响应时间 </li><li>线程数 </li></ul></li><li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问 </li></ol><p>解决方案（术） </p><ol><li>LRU与LFU切换 </li><li>数据有效期策略调整 <ul><li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟 </li><li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量 </li></ul></li><li><strong>超热</strong>数据使用永久key</li><li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时 </li><li>加锁  <strong>慎用！</strong> </li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143749.png" srcset="/img/loading.gif" alt=""></p><h3 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a>3、缓存击穿</h3><h4 id="数据库服务器崩溃（2）"><a href="#数据库服务器崩溃（2）" class="headerlink" title="数据库服务器崩溃（2）"></a>数据库服务器崩溃（2）</h4><ol><li>系统平稳运行过程中 </li><li>数据库连接量<strong>瞬间激增</strong> </li><li>Redis服务器无大量key过期 </li><li>Redis内存平稳，无波动 </li><li>Redis服务器CPU正常</li><li><strong>数据库崩溃</strong> </li></ol><h4 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>Redis中<strong>某个key过期，该key访问量巨大</strong> </li><li>多个数据请求从服务器直接压到Redis后，均未命中 </li><li>Redis在短时间内发起了大量对数据库中同一数据的访问 </li></ol><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>单个key高热数据</li><li>key过期 </li></ul><h4 id="解决方案（术）"><a href="#解决方案（术）" class="headerlink" title="解决方案（术）"></a>解决方案（术）</h4><ol><li><p>预先设定 </p><p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong> </p><p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整 </p><ul><li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key </li></ul></li><li><p>后台刷新数据 </p><ul><li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失 </li></ul></li><li><p>二级缓存 </p><ul><li>设置不同的失效时间，保障不会被同时淘汰就行 </li></ul></li><li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong> </p></li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。 </p>]]></content>
    
    
    <categories>
      
      <category>后端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
