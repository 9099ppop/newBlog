<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM学习</title>
    <link href="/2020/06/08/JVM%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/06/08/JVM%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p>本博客是根据<strong>解密JVM【黑马程序员出品】</strong>教学视频学习时，所做的笔记</p><p><a href="https://www.bilibili.com/video/BV1yE411Z7AP" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yE411Z7AP</a></p><h2 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>JVM JRE JDK的区别</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150422.png" srcset="/img/loading.gif" alt=""></p><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150440.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>线程私有<ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li>不会存在内存溢出</li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>每个<strong>线程</strong>运行需要的内存空间，称谓<strong>虚拟机栈</strong></p></li><li><p>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</p></li><li><p>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></p></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;method1();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = a + b;<span class="hljs-keyword">return</span> c;&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150534.png" srcset="/img/loading.gif" alt=""></p><p>在控制台中可以看到，主类中的方法在进入虚拟机栈的时候，符合栈的特点</p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ul><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li><li>方法内的局部变量是否是线程安全的？<ul><li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</li><li>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li></ul></li></ul><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><p><strong>发生原因</strong></p><ul><li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li><li>每个栈帧<strong>所占用过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong>    通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong>  通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li><li>有垃圾回收机制</li></ul><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><p><strong>jps</strong></p><p><strong>jmap</strong></p><p><strong>jconsole</strong></p><p><strong>jvirsalvm</strong></p><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150547.png" srcset="/img/loading.gif" alt=""></p><h4 id="内存溢出-1"><a href="#内存溢出-1" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出</li><li>1.8以后会导致<strong>元空间</strong>内存溢出</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><ul><li><p>获得对应类的.class文件</p><ul><li><p>在JDK对应的bin目录下运行cmd，<strong>也可以在IDEA控制台输入</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150602.png" srcset="/img/loading.gif" alt=""></p></li><li><p>输入 <strong>javac 对应类的绝对路径</strong></p><pre><code class="hljs taggerscript">F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\b</span>in&gt;javac F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.java</code></pre><p>输入完成后，对应的目录下就会出现类的.class文件</p></li></ul></li><li><p>在控制台输入 javap -v 类的绝对路径</p><pre><code class="hljs taggerscript">javap -v F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.class</code></pre></li><li><p>然后能在控制台看到反编译以后类的信息了</p><ul><li><p>类的基本信息</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150618.png" srcset="/img/loading.gif" alt=""></p></li><li><p>常量池</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150630.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150641.png" srcset="/img/loading.gif" alt=""></p></li><li><p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，<strong>#号的内容需要在常量池中查找</strong>）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150653.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li>常量池<ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li>运行时常量池<ul><li>常量池是<em>.class文件中的，当该*</em>类被加载以后<strong>，它的常量池信息就会</strong>放入运行时常量池<strong>，并把里面的</strong>符号地址变为真实地址**</li></ul></li></ul><h4 id="常量池与串池的关系"><a href="#常量池与串池的关系" class="headerlink" title="常量池与串池的关系"></a>常量池与串池的关系</h4><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>; String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;&#125;&#125;</code></pre><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span><span class="hljs-number">2</span>: astore_1<span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span><span class="hljs-number">5</span>: astore_2<span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span><span class="hljs-number">8</span>: astore_3<span class="hljs-number">9</span>: <span class="hljs-keyword">return</span></code></pre><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>;String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;<span class="hljs-comment">//拼接字符串对象来创建新的字符串</span>String ab2 = a+b; &#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs angelscript"> Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span>         <span class="hljs-number">2</span>: astore_1         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span>         <span class="hljs-number">5</span>: astore_2         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>         <span class="hljs-number">8</span>: astore_3         <span class="hljs-number">9</span>: new           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>        <span class="hljs-number">12</span>: dup        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder."&lt;init&gt;":()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span>ing;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span></code></pre><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuffer().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><pre><code class="hljs java">String ab = <span class="hljs-string">"ab"</span>;String ab2 = a+b;<span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span>System.out.println(ab == ab2);</code></pre><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">"a"</span>;String b = <span class="hljs-string">"b"</span>;String ab = <span class="hljs-string">"ab"</span>;String ab2 = a+b;<span class="hljs-comment">//使用拼接字符串的方法创建字符串</span>String ab3 = <span class="hljs-string">"a"</span> + <span class="hljs-string">"b"</span>;&#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs angelscript">   Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String a</span>         <span class="hljs-number">2</span>: astore_1         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">3</span>                  <span class="hljs-comment">// String b</span>         <span class="hljs-number">5</span>: astore_2         <span class="hljs-number">6</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>         <span class="hljs-number">8</span>: astore_3         <span class="hljs-number">9</span>: new           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span>        <span class="hljs-number">12</span>: dup        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder."&lt;init&gt;":()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        <span class="hljs-number">21</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String</span>;)Ljava/lang/StringBuilder;        <span class="hljs-number">24</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/Str</span>ing;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span>        <span class="hljs-number">29</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String ab</span>        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuffer来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);<span class="hljs-comment">//调用str的intern方法，这时串池中没有"ab"，则会将该字符串对象放入到串池中，此时堆内存与串池中的"ab"是同一个对象</span>String st2 = str.intern();<span class="hljs-comment">//给str3赋值，因为此时串池中已有"ab"，则直接将串池中的内容返回</span>String str3 = <span class="hljs-string">"ab"</span>;<span class="hljs-comment">//因为堆内存与串池中的"ab"是同一个对象，所以以下两条语句打印的都为true</span>System.out.println(str == st2);System.out.println(str == str3);&#125;&#125;</code></pre><p><strong>例2</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//此处创建字符串对象"ab"，因为串池中还没有"ab"，所以将其放入串池中</span>String str3 = <span class="hljs-string">"ab"</span>;        <span class="hljs-comment">//"a" "b" 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"a"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"b"</span>);        <span class="hljs-comment">//此时因为在创建str3时，"ab"已存在与串池中，所以放入失败，但是会返回串池中的"ab"</span>String str2 = str.intern();        <span class="hljs-comment">//false</span>System.out.println(str == str2);        <span class="hljs-comment">//false</span>System.out.println(str == str3);        <span class="hljs-comment">//true</span>System.out.println(str2 == str3);&#125;&#125;</code></pre><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable调优"><a href="#StringTable调优" class="headerlink" title="StringTable调优"></a>StringTable调优</h4><ul><li><p>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</p><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">StringTableSize</span>=xxxx</code></pre><p>​    </p></li><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存"><a href="#6、直接内存" class="headerlink" title="6、直接内存"></a>6、直接内存</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150715.png" srcset="/img/loading.gif" alt=""></p><p><strong>使用了DirectBuffer</strong> </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150736.png" srcset="/img/loading.gif" alt=""></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><p><strong>allocateDirect的实现</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ByteBuffer <span class="hljs-title">allocateDirect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DirectByteBuffer(capacity);&#125;</code></pre><p>DirectByteBuffer类</p><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-keyword">int</span> cap) &#123;   <span class="hljs-comment">// package-private</span>       <span class="hljs-keyword">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);    <span class="hljs-keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();    <span class="hljs-keyword">int</span> ps = Bits.pageSize();    <span class="hljs-keyword">long</span> size = Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-keyword">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));    Bits.reserveMemory(size, cap);    <span class="hljs-keyword">long</span> base = <span class="hljs-number">0</span>;    <span class="hljs-keyword">try</span> &#123;        base = unsafe.allocateMemory(size); <span class="hljs-comment">//申请内存</span>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;        Bits.unreserveMemory(size, cap);        <span class="hljs-keyword">throw</span> x;    &#125;    unsafe.setMemory(base, size, (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;        <span class="hljs-comment">// Round up to page boundary</span>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        address = base;    &#125;    cleaner = Cleaner.create(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> Deallocator(base, size, cap)); <span class="hljs-comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span>    att = <span class="hljs-keyword">null</span>;&#125;</code></pre><p>这里调用了一个Cleaner的create方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean方法，来清除直接内存中占用的内存</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">if</span> (remove(<span class="hljs-keyword">this</span>)) &#123;           <span class="hljs-keyword">try</span> &#123;               <span class="hljs-keyword">this</span>.thunk.run(); <span class="hljs-comment">//调用run方法</span>           &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Throwable var2) &#123;               AccessController.doPrivileged(<span class="hljs-keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;                   <span class="hljs-function"><span class="hljs-keyword">public</span> Void <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                       <span class="hljs-keyword">if</span> (System.err != <span class="hljs-keyword">null</span>) &#123;                           (<span class="hljs-keyword">new</span> Error(<span class="hljs-string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();                       &#125;                       System.exit(<span class="hljs-number">1</span>);                       <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;                   &#125;               &#125;);           &#125;</code></pre><p>对应对象的run方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (address == <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// Paranoia</span>        <span class="hljs-keyword">return</span>;    &#125;    unsafe.freeMemory(address); <span class="hljs-comment">//释放直接内存中占用的内存</span>    address = <span class="hljs-number">0</span>;    Bits.unreserveMemory(size, capacity);&#125;</code></pre><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150750.png" srcset="/img/loading.gif" alt=""></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150800.png" srcset="/img/loading.gif" alt=""></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><h6 id="软引用的使用"><a href="#软引用的使用" class="headerlink" title="软引用的使用"></a>软引用的使用</h6><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);&#125;&#125;</code></pre><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span>ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span>Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span>list.remove(poll);<span class="hljs-comment">//移动到引用队列中的下一个元素</span>poll = queue.poll();&#125;&#125;&#125;</code></pre><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li><p>软引用和弱引用<strong>可以配合</strong>引用队列</p><ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li><p>虚引用和终结器引用<strong>必须配合</strong>引用队列</p><ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150813.png" srcset="/img/loading.gif" alt=""></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150827.png" srcset="/img/loading.gif" alt=""></p><p>标记-整理 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150842.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150856.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150907.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150919.png" srcset="/img/loading.gif" alt=""></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150931.png" srcset="/img/loading.gif" alt=""></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150939.png" srcset="/img/loading.gif" alt=""></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150946.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150955.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151002.png" srcset="/img/loading.gif" alt=""></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151010.png" srcset="/img/loading.gif" alt=""></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151018.png" srcset="/img/loading.gif" alt=""></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li>单线程</li><li>内存较小，个人电脑（CPU核数较少）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151027.png" srcset="/img/loading.gif" alt=""></p><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151039.png" srcset="/img/loading.gif" alt=""></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel  Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li><p>多线程</p></li><li><p>堆内存较大，多核CPU</p></li><li><p>尽可能让单次STW时间变短（尽量不影响其他线程运行）</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151052.png" srcset="/img/loading.gif" alt=""></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>一种以获取<strong>最短回收停顿时间</strong>为目标的收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p> CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151100.png" srcset="/img/loading.gif" alt=""></p><h5 id="G1垃圾回收阶段"><a href="#G1垃圾回收阶段" class="headerlink" title="G1垃圾回收阶段"></a>G1垃圾回收阶段</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151109.png" srcset="/img/loading.gif" alt=""></p><p>新生代伊甸园垃圾回收—–&gt;内存不足，新生代回收+并发标记—–&gt;回收新生代伊甸园、幸存区、老年代内存——&gt;新生代伊甸园垃圾回收(重新开始)</p><h5 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h5><p><strong>分区算法region</strong></p><p>分代是按对象的生命周期划分，分区则是将堆空间划分连续几个不同小区间，每一个小区间独立回收，可以控制一次回收多少个小区间，方便控制 GC 产生的停顿时间</p><p>E：伊甸园    S：幸存区    O：老年代</p><ul><li>会STW</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151119.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151129.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151140.png" srcset="/img/loading.gif" alt=""></p><h5 id="Young-Collection-CM"><a href="#Young-Collection-CM" class="headerlink" title="Young Collection + CM"></a>Young Collection + CM</h5><p>CM：并发标记</p><ul><li>在 Young GC 时会<strong>对 GC Root 进行初始标记</strong></li><li>在老年代<strong>占用堆内存的比例</strong>达到阈值时，对进行并发标记（不会STW），阈值可以根据用户来进行设定</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151150.png" srcset="/img/loading.gif" alt=""></p><h5 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h5><p> 会对E S O 进行<strong>全面的回收</strong></p><ul><li>最终标记</li><li><strong>拷贝</strong>存活</li></ul><p>-XX:MaxGCPauseMills:xxx    用于指定最长的停顿时间</p><p><strong>问</strong>：为什么有的老年代被拷贝了，有的没拷贝？</p><p>因为指定了最大停顿时间，如果对所有老年代都进行回收，耗时可能过高。为了保证时间不超过设定的停顿时间，会<strong>回收最有价值的老年代</strong>（回收后，能够得到更多内存）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151201.png" srcset="/img/loading.gif" alt=""></p><h5 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h5><p>G1在老年代内存不足时（老年代所占内存超过阈值）</p><ul><li>如果垃圾产生速度慢于垃圾回收速度，不会触发Full GC，还是并发地进行清理</li><li>如果垃圾产生速度快于垃圾回收速度，便会触发Full GC</li></ul><h5 id="Young-Collection-跨代引用"><a href="#Young-Collection-跨代引用" class="headerlink" title="Young Collection 跨代引用"></a>Young Collection 跨代引用</h5><ul><li>新生代回收的跨代引用（老年代引用新生代）问题</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151211.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>卡表与Remembered Set</p><ul><li>Remembered Set 存在于E中，用于保存新生代对象对应的脏卡<ul><li>脏卡：O被划分为多个区域（一个区域512K），如果该区域引用了新生代对象，则该区域被称为脏卡</li></ul></li></ul></li><li><p>在引用变更时通过post-write barried + dirty card queue</p></li><li><p>concurrent refinement threads  更新 Remembered Set</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151222.png" srcset="/img/loading.gif" alt=""></p><h5 id="Remark"><a href="#Remark" class="headerlink" title="Remark"></a>Remark</h5><p>重新标记阶段</p><p>在垃圾回收时，收集器处理对象的过程中</p><p>黑色：已被处理，需要保留的  灰色：正在处理中的 白色：还未处理的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151229.png" srcset="/img/loading.gif" alt=""></p><p>但是在<strong>并发标记过程中</strong>，有可能A被处理了以后未引用C，但该处理过程还未结束，在处理过程结束之前A引用了C，这时就会用到remark</p><p>过程如下</p><ul><li>之前C未被引用，这时A引用了C，就会给C加一个写屏障，写屏障的指令会被执行，将C放入一个队列当中，并将C变为 处理中 状态</li><li>在<strong>并发标记</strong>阶段结束以后，重新标记阶段会STW，然后将放在该队列中的对象重新处理，发现有强引用引用它，就会处理它</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151239.png" srcset="/img/loading.gif" alt=""></p><h5 id="JDK-8u20-字符串去重"><a href="#JDK-8u20-字符串去重" class="headerlink" title="JDK 8u20 字符串去重"></a>JDK 8u20 字符串去重</h5><p>过程</p><ul><li>将所有新分配的字符串（底层是char[]）放入一个队列</li><li>当新生代回收时，G1并发检查是否有重复的字符串</li><li>如果字符串的值一样，就让他们<strong>引用同一个字符串对象</strong></li><li>注意，其与String.intern的区别<ul><li>intern关注的是字符串对象</li><li>字符串去重关注的是char[]</li><li>在JVM内部，使用了不同的字符串标</li></ul></li></ul><p>优点与缺点</p><ul><li>节省了大量内存</li><li>新生代回收时间略微增加，导致略微多占用CPU</li></ul><h5 id="JDK-8u40-并发标记类卸载"><a href="#JDK-8u40-并发标记类卸载" class="headerlink" title="JDK 8u40 并发标记类卸载"></a>JDK 8u40 并发标记类卸载</h5><p>在并发标记阶段结束以后，就能知道哪些类不再被使用。如果一个类加载器的所有类都不在使用，则卸载它所加载的所有类</p><h5 id="JDK-8u60-回收巨型对象"><a href="#JDK-8u60-回收巨型对象" class="headerlink" title="JDK 8u60 回收巨型对象"></a>JDK 8u60 回收巨型对象</h5><ul><li>一个对象大于region的一半时，就称为巨型对象</li><li>G1不会对巨型对象进行拷贝</li><li>回收时被优先考虑</li><li>G1会跟踪老年代所有incoming引用，如果老年代incoming引用为0的巨型对象就可以在新生代垃圾回收时处理掉</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151249.png" srcset="/img/loading.gif" alt=""></p><h3 id="5、GC-调优"><a href="#5、GC-调优" class="headerlink" title="5、GC 调优"></a>5、GC 调优</h3><p>查看虚拟机参数命令</p><pre><code class="hljs taggerscript">"F:<span class="hljs-symbol">\J</span>AVA<span class="hljs-symbol">\J</span>DK8.0<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\j</span>ava" -XX:+PrintFlagsFinal -version | findstr "GC"</code></pre><p>可以根据参数去查询具体的信息</p><h4 id="调优领域"><a href="#调优领域" class="headerlink" title="调优领域"></a>调优领域</h4><ul><li><p>内存</p></li><li><p>锁竞争</p></li><li><p>CPU占用</p></li><li><p>IO</p></li><li><p>GC</p></li></ul><h4 id="确定目标"><a href="#确定目标" class="headerlink" title="确定目标"></a>确定目标</h4><p>低延迟/高吞吐量？ 选择合适的GC</p><ul><li><p>CMS G1 ZGC</p></li><li><p>ParallelGC</p></li><li><p>Zing</p></li></ul><h4 id="最快的GC是不发生GC"><a href="#最快的GC是不发生GC" class="headerlink" title="最快的GC是不发生GC"></a>最快的GC是不发生GC</h4><p>首先排除减少因为自身编写的代码而引发的内存问题 </p><ul><li>查看Full GC前后的内存占用，考虑以下几个问题<ul><li>数据是不是太多？</li><li>数据表示是否太臃肿<ul><li>对象图</li><li>对象大小</li></ul></li><li>是否存在内存泄漏</li></ul></li></ul><h4 id="新生代调优"><a href="#新生代调优" class="headerlink" title="新生代调优"></a>新生代调优</h4><ul><li><p>新生代的特点</p><ul><li>所有的new操作分配内存都是非常廉价的<ul><li>TLAB</li></ul></li><li>死亡对象回收零代价</li><li>大部分对象用过即死（朝生夕死）</li><li>MInor GC 所用时间远小于Full GC</li></ul></li><li><p>新生代内存越大越好么？</p><ul><li><p>不是</p><ul><li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li><li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li></ul></li><li><p>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</p></li></ul></li></ul><h4 id="幸存区调优"><a href="#幸存区调优" class="headerlink" title="幸存区调优"></a>幸存区调优</h4><ul><li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li><li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li></ul><h4 id="老年代调优"><a href="#老年代调优" class="headerlink" title="老年代调优"></a>老年代调优</h4><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151300.png" srcset="/img/loading.gif" alt=""></p><h3 id="1、类文件结构"><a href="#1、类文件结构" class="headerlink" title="1、类文件结构"></a>1、类文件结构</h3><p>首先获得.class字节码文件</p><p>方法：</p><ul><li>在文本文档里写入java代码（文件名与类名一致），将文件类型改为.java</li><li>在文件对应目录下运行cmd，执行javac XXX.java</li></ul><p>以下是字节码文件</p><pre><code class="hljs angelscript"><span class="hljs-number">0000000</span> ca fe ba be <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">34</span> <span class="hljs-number">00</span> <span class="hljs-number">23</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">09</span> <span class="hljs-number">0000020</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">17</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">18</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">19</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>a <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">07</span> <span class="hljs-number">0000040</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>c <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">3</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">3</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">28</span> <span class="hljs-number">29</span> <span class="hljs-number">0000060</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">43</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">4</span>c <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">65</span> <span class="hljs-number">4</span>e <span class="hljs-number">0000100</span> <span class="hljs-number">75</span> <span class="hljs-number">6</span>d <span class="hljs-number">62</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">4</span>c <span class="hljs-number">6f</span> <span class="hljs-number">63</span> <span class="hljs-number">0000120</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>c <span class="hljs-number">56</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">54</span> <span class="hljs-number">61</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">0000140</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">69</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">4</span>c <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">63</span> <span class="hljs-number">0000160</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">0000200</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">6</span>d <span class="hljs-number">61</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">16</span> <span class="hljs-number">0000220</span> <span class="hljs-number">28</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">0000240</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">0000260</span> <span class="hljs-number">5</span>b <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">0000300</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">68</span> <span class="hljs-number">6f</span> <span class="hljs-number">64</span> <span class="hljs-number">50</span> <span class="hljs-number">61</span> <span class="hljs-number">72</span> <span class="hljs-number">61</span> <span class="hljs-number">0000320</span> <span class="hljs-number">6</span>d <span class="hljs-number">65</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">72</span> <span class="hljs-number">73</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">53</span> <span class="hljs-number">6f</span> <span class="hljs-number">75</span> <span class="hljs-number">72</span> <span class="hljs-number">63</span> <span class="hljs-number">65</span> <span class="hljs-number">46</span> <span class="hljs-number">0000340</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span><span class="hljs-number">0000360</span> <span class="hljs-number">2</span>e <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>d <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">1</span>e <span class="hljs-number">0000400</span> <span class="hljs-number">00</span> <span class="hljs-number">1f</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">68</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">6f</span> <span class="hljs-number">20</span> <span class="hljs-number">77</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">0000420</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">20</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">22</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">1</span>b <span class="hljs-number">63</span> <span class="hljs-number">6</span>e <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">74</span> <span class="hljs-number">0000440</span> <span class="hljs-number">63</span> <span class="hljs-number">61</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>a <span class="hljs-number">76</span> <span class="hljs-number">6</span>d <span class="hljs-number">2f</span> <span class="hljs-number">74</span> <span class="hljs-number">35</span> <span class="hljs-number">2f</span> <span class="hljs-number">48</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>c <span class="hljs-number">0000460</span> <span class="hljs-number">6f</span> <span class="hljs-number">57</span> <span class="hljs-number">6f</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>c <span class="hljs-number">64</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">0000500</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">4f</span> <span class="hljs-number">62</span> <span class="hljs-number">6</span>a <span class="hljs-number">65</span> <span class="hljs-number">63</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">0000520</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">79</span> <span class="hljs-number">73</span> <span class="hljs-number">74</span> <span class="hljs-number">65</span> <span class="hljs-number">6</span>d <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">03</span> <span class="hljs-number">6f</span> <span class="hljs-number">0000540</span> <span class="hljs-number">75</span> <span class="hljs-number">74</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">0000560</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">3</span>b <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">6</span>a <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">0000600</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">69</span> <span class="hljs-number">6f</span> <span class="hljs-number">2f</span> <span class="hljs-number">50</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">65</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">0000620</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">70</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">74</span> <span class="hljs-number">6</span>c <span class="hljs-number">6</span>e <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">15</span> <span class="hljs-number">28</span> <span class="hljs-number">4</span>c <span class="hljs-number">6</span>a <span class="hljs-number">0000640</span> <span class="hljs-number">61</span> <span class="hljs-number">76</span> <span class="hljs-number">61</span> <span class="hljs-number">2f</span> <span class="hljs-number">6</span>c <span class="hljs-number">61</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">2f</span> <span class="hljs-number">53</span> <span class="hljs-number">74</span> <span class="hljs-number">72</span> <span class="hljs-number">69</span> <span class="hljs-number">6</span>e <span class="hljs-number">67</span> <span class="hljs-number">3</span>b <span class="hljs-number">0000660</span> <span class="hljs-number">29</span> <span class="hljs-number">56</span> <span class="hljs-number">00</span> <span class="hljs-number">21</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">0000700</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">2f</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">0000720</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">2</span>a b7 <span class="hljs-number">00</span> <span class="hljs-number">01</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">0000740</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0000760</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">0</span>d <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>e <span class="hljs-number">00</span> <span class="hljs-number">0001000</span> <span class="hljs-number">0f</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">37</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0001020</span> <span class="hljs-number">09</span> b2 <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">12</span> <span class="hljs-number">03</span> b6 <span class="hljs-number">00</span> <span class="hljs-number">04</span> b1 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">0001040</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>a <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>b <span class="hljs-number">0001060</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0001100</span> <span class="hljs-number">00</span> <span class="hljs-number">12</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">05</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">13</span> <span class="hljs-number">00</span> <span class="hljs-number">0001120</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">14</span></code></pre><p>根据 JVM 规范，<strong>类文件结构</strong>如下</p><pre><code class="hljs properties"><span class="hljs-attr">u4</span>  <span class="hljs-string">magic</span><span class="hljs-attr">u2</span> <span class="hljs-string">            minor_version;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            major_version;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            constant_pool_count;    </span><span class="hljs-attr">cp_info</span> <span class="hljs-string">       constant_pool[constant_pool_count-1];    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            access_flags;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            this_class;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            super_class;   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            interfaces_count;    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            interfaces[interfaces_count];   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            fields_count;    </span><span class="hljs-attr">field_info</span> <span class="hljs-string">    fields[fields_count];   </span><span class="hljs-attr">u2</span> <span class="hljs-string">            methods_count;    </span><span class="hljs-attr">method_info</span> <span class="hljs-string">   methods[methods_count];    </span><span class="hljs-attr">u2</span> <span class="hljs-string">            attributes_count;    </span><span class="hljs-attr">attribute_info</span> <span class="hljs-string">attributes[attributes_count];</span></code></pre><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>u4 magic </p><p>对应字节码文件的0~3个字节</p><p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>u2             minor_version;    </p><p>u2             major_version;</p><p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09 </p><p>34H = 52，代表JDK8</p><h4 id="常量池-1"><a href="#常量池-1" class="headerlink" title="常量池"></a>常量池</h4><p>见资料文件</p><p>…略</p><h3 id="2、字节码指令"><a href="#2、字节码指令" class="headerlink" title="2、字节码指令"></a>2、字节码指令</h3><p>可参考 </p><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5</a></p><h4 id="javap工具"><a href="#javap工具" class="headerlink" title="javap工具"></a>javap工具</h4><p>Oracle 提供了 <strong>javap</strong> 工具来反编译 class 文件</p><pre><code class="hljs taggerscript">javap -v F:<span class="hljs-symbol">\T</span>hread_study<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\c</span>om<span class="hljs-symbol">\n</span>yima<span class="hljs-symbol">\J</span>VM<span class="hljs-symbol">\d</span>ay01<span class="hljs-symbol">\M</span>ain.class</code></pre><pre><code class="hljs lasso">F:\Thread_study&gt;javap <span class="hljs-params">-v</span> F:\Thread_study\src\com\nyima\JVM\day5\Demo1.classClassfile /F:/Thread_study/src/com/nyima/JVM/day5/Demo1.class  Last modified <span class="hljs-number">2020</span><span class="hljs-number">-6</span><span class="hljs-number">-6</span>; size <span class="hljs-number">434</span> <span class="hljs-built_in">bytes</span>  MD5 checksum df1dce65bf6fb0b4c1de318051f4a67e  Compiled from <span class="hljs-string">"Demo1.java"</span><span class="hljs-keyword">public</span> class com.nyima.JVM.day5.Demo1  minor version: <span class="hljs-number">0</span>  major version: <span class="hljs-number">52</span>  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #6.#15         <span class="hljs-comment">// java/lang/Object."&lt;init&gt;":()V</span>   #2 = Fieldref           #16.#17        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span>   #3 = <span class="hljs-built_in">String</span>             #18            <span class="hljs-comment">// hello world</span>   #4 = Methodref          #19.#20        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span>   #5 = Class              #21            <span class="hljs-comment">// com/nyima/JVM/day5/Demo1</span>   #6 = Class              #22            <span class="hljs-comment">// java/lang/Object</span>   #7 = Utf8               &lt;init&gt;   #8 = Utf8               ()V   #9 = Utf8               Code  #10 = Utf8               LineNumberTable  #11 = Utf8               main  #12 = Utf8               (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V  #13 = Utf8               SourceFile  #14 = Utf8               Demo1.java  #15 = NameAndType        #7:#8          <span class="hljs-comment">// "&lt;init&gt;":()V</span>  #16 = Class              #23            <span class="hljs-comment">// java/lang/System</span>  #17 = NameAndType        #24:#25        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span>  #18 = Utf8               hello world  #19 = Class              #26            <span class="hljs-comment">// java/io/PrintStream</span>  #20 = NameAndType        #27:#28        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span>  #21 = Utf8               com/nyima/JVM/day5/Demo1  #22 = Utf8               java/lang/Object  #23 = Utf8               java/lang/System  #24 = Utf8               out  #25 = Utf8               Ljava/io/PrintStream;  #26 = Utf8               java/io/PrintStream  #27 = Utf8               println  #28 = Utf8               (Ljava/lang/<span class="hljs-built_in">String</span>;)V&#123;  <span class="hljs-keyword">public</span> com.nyima.JVM.day5.Demo1();    descriptor: ()V    flags: ACC_PUBLIC    Code:      <span class="hljs-built_in">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: aload_0         <span class="hljs-number">1</span>: invokespecial #1                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span>  <span class="hljs-keyword">public</span> static <span class="hljs-literal">void</span> main(java.lang.<span class="hljs-built_in">String</span><span class="hljs-meta">[</span><span class="hljs-meta">]</span>);    descriptor: (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      <span class="hljs-built_in">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: getstatic     #2                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>         <span class="hljs-number">3</span>: ldc           #3                  <span class="hljs-comment">// String hello world</span>         <span class="hljs-number">5</span>: invokevirtual #4                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span>      LineNumberTable:        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span>&#125;</code></pre><h4 id="图解方法执行流程"><a href="#图解方法执行流程" class="headerlink" title="图解方法执行流程"></a>图解方法执行流程</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3_1</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-keyword">int</span> b = Short.MAX_VALUE + <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> c = a + b;        System.out.println(c);       &#125; &#125;</code></pre><p><strong>常量池载入运行时常量池</strong></p><p>常量池也属于方法区，只不过这里单独提出来了</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151317.png" srcset="/img/loading.gif" alt=""></p><p><strong>方法字节码载入方法区</strong></p><p>（stack=2，locals=4） 对应操作数栈有2个空间（每个空间4个字节），局部变量表中有4个槽位</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151325.png" srcset="/img/loading.gif" alt=""></p><p><strong>执行引擎开始执行字节码</strong></p><p><strong>bipush 10</strong> </p><ul><li><strong>将一个 byte 压入操作数栈</strong>（其长度会补齐 4 个字节），类似的指令还有 <ul><li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li><li>ldc 将一个 int 压入操作数栈 </li><li>ldc2_w 将一个 long 压入操作数栈（<strong>分两次压入</strong>，因为 long 是 8 个字节）</li><li>这里小的数字都是和字节码指令存在一起，<strong>超过 short 范围的数字存入了常量池</strong></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151336.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 1</strong></p><p>将操作数栈栈顶元素弹出，放入局部变量表的slot 1中</p><p>对应代码中的 </p><pre><code class="hljs java">a = <span class="hljs-number">10</span></code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151346.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151412.png" srcset="/img/loading.gif" alt=""></p><p><strong>ldc #3</strong></p><p>读取运行时常量池中#3，即32768(超过short最大值范围的数会被放到运行时常量池中)，将其加载到操作数栈中</p><p>注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算好的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151421.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 2</strong></p><p>将操作数栈中的元素弹出，放到局部变量表的2号位置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151432.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151441.png" srcset="/img/loading.gif" alt=""></p><p><strong>iload1 iload2</strong></p><p>将局部变量表中1号位置和2号位置的元素放入操作数栈中</p><ul><li>因为只能在操作数栈中执行运算操作</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151450.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151459.png" srcset="/img/loading.gif" alt=""></p><p><strong>iadd</strong></p><p>将操作数栈中的两个元素<strong>弹出栈</strong>并相加，结果在压入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151508.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151523.png" srcset="/img/loading.gif" alt=""></p><p><strong>istore 3</strong></p><p>将操作数栈中的元素弹出，放入局部变量表的3号位置</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151547.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151555.png" srcset="/img/loading.gif" alt=""></p><p><strong>getstatic #4</strong></p><p>在运行时常量池中找到#4，发现是一个对象</p><p>在堆内存中找到该对象，并将其<strong>引用</strong>放入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151605.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151613.png" srcset="/img/loading.gif" alt=""></p><p><strong>iload 3</strong></p><p>将局部变量表中3号位置的元素压入操作数栈中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151624.png" srcset="/img/loading.gif" alt=""></p><p><strong>invokevirtual 5</strong></p><p>找到常量池 #5 项，定位到方法区 java/io/PrintStream.println:(I)V 方法 </p><p>生成新的栈帧（分配 locals、stack等） </p><p>传递参数，执行新栈帧中的字节码</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151632.png" srcset="/img/loading.gif" alt=""></p><p>执行完毕，弹出栈帧 </p><p>清除 main 操作数栈内容</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608151640.png" srcset="/img/loading.gif" alt=""></p><p>*<em>return *</em><br>完成 main 方法调用，弹出 main 栈帧，程序结束</p><h4 id="通过字节码指令来分析问题"><a href="#通过字节码指令来分析问题" class="headerlink" title="通过字节码指令来分析问题"></a>通过字节码指令来分析问题</h4><p>代码</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>) &#123;x = x++;i++;&#125;System.out.println(x); <span class="hljs-comment">//接过为0</span>&#125;&#125;</code></pre><p>为什么最终的x结果为0呢？ 通过分析字节码指令即可知晓</p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><span class="hljs-comment">//操作数栈分配2个空间，局部变量表分配3个空间</span>        <span class="hljs-number">0</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">1</span>: istore_1<span class="hljs-comment">//将常数0放入局部变量表的1号槽位 i=0</span>        <span class="hljs-number">2</span>: iconst_0<span class="hljs-comment">//准备一个常数0</span>        <span class="hljs-number">3</span>: istore_2<span class="hljs-comment">//将常数0放入局部变量的2号槽位 x=0</span>        <span class="hljs-number">4</span>: iload_1<span class="hljs-comment">//将局部变量表1号槽位的数放入操作数栈中</span>        <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><span class="hljs-comment">//将数字10放入操作数栈中，此时操作数栈中有2个数</span>        <span class="hljs-number">7</span>: if_icmpge     <span class="hljs-number">21</span><span class="hljs-comment">//比较操作数栈中的两个数，如果下面的数大于上面的数，就跳转到21。这里的比较是将两个数做减法。因为涉及运算操作，所以会将两个数弹出操作数栈来进行运算。运算结束后操作数栈为空</span>       <span class="hljs-number">10</span>: iload_2<span class="hljs-comment">//将局部变量2号槽位的数放入操作数栈中，放入的值是0</span>       <span class="hljs-number">11</span>: iinc          <span class="hljs-number">2</span>, <span class="hljs-number">1</span><span class="hljs-comment">//将局部变量2号槽位的数加1，自增后，槽位中的值为1</span>       <span class="hljs-number">14</span>: istore_2<span class="hljs-comment">//将操作数栈中的数放入到局部变量表的2号槽位，2号槽位的值又变为了1</span>       <span class="hljs-number">15</span>: iinc          <span class="hljs-number">1</span>, <span class="hljs-number">1</span> <span class="hljs-comment">//1号槽位的值自增1</span>       <span class="hljs-number">18</span>: goto          <span class="hljs-number">4</span> <span class="hljs-comment">//跳转到第4条指令</span>       <span class="hljs-number">21</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span>       <span class="hljs-number">24</span>: iload_2       <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span>       <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span></code></pre><h3 id="3、构造方法"><a href="#3、构造方法" class="headerlink" title="3、构造方法"></a>3、构造方法</h3><h4 id="cinit-V"><a href="#cinit-V" class="headerlink" title="cinit()V"></a>cinit()V</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">10</span>;<span class="hljs-keyword">static</span> &#123;i = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">static</span> &#123;i = <span class="hljs-number">30</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(i); <span class="hljs-comment">//结果为30</span>&#125;&#125;</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 static 静态代码块和静态成员赋值的代码，<strong>合并</strong>为一个特殊的方 法 <cinit>()V ：</p><pre><code class="hljs angelscript">stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span>         <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">20</span>         <span class="hljs-number">7</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">10</span>: bipush        <span class="hljs-number">30</span>        <span class="hljs-number">12</span>: putstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field i:I</span>        <span class="hljs-number">15</span>: <span class="hljs-keyword">return</span></code></pre><h4 id="init-V"><a href="#init-V" class="headerlink" title="init()V"></a>init()V</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-keyword">private</span> String a = <span class="hljs-string">"s1"</span>;&#123;b = <span class="hljs-number">20</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;&#123;a = <span class="hljs-string">"s2"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo4</span><span class="hljs-params">(String a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">this</span>.a = a;<span class="hljs-keyword">this</span>.b = b;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Demo4 d = <span class="hljs-keyword">new</span> Demo4(<span class="hljs-string">"s3"</span>, <span class="hljs-number">30</span>);System.out.println(d.a);System.out.println(d.b);&#125;&#125;</code></pre><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p><pre><code class="hljs angelscript">Code:     stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">3</span>        <span class="hljs-number">0</span>: aload_0        <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span>        <span class="hljs-number">4</span>: aload_0        <span class="hljs-number">5</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String s1</span>        <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-number">10</span>: aload_0       <span class="hljs-number">11</span>: bipush        <span class="hljs-number">20</span>       <span class="hljs-number">13</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">16</span>: aload_0       <span class="hljs-number">17</span>: bipush        <span class="hljs-number">10</span>       <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">22</span>: aload_0       <span class="hljs-number">23</span>: ldc           #<span class="hljs-number">5</span>                  <span class="hljs-comment">// String s2</span>       <span class="hljs-number">25</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-comment">//原始构造方法在最后执行</span>       <span class="hljs-number">28</span>: aload_0       <span class="hljs-number">29</span>: aload_1       <span class="hljs-number">30</span>: putfield      #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field a:Ljava/lang/String;</span>       <span class="hljs-number">33</span>: aload_0       <span class="hljs-number">34</span>: iload_2       <span class="hljs-number">35</span>: putfield      #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Field b:I</span>       <span class="hljs-number">38</span>: <span class="hljs-keyword">return</span></code></pre><h3 id="4、方法调用"><a href="#4、方法调用" class="headerlink" title="4、方法调用"></a>4、方法调用</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Demo5</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Demo5 demo5 = <span class="hljs-keyword">new</span> Demo5();demo5.test1();demo5.test2();demo5.test3();Demo5.test4();&#125;&#125;</code></pre><p>不同方法在调用时，对应的虚拟机指令有所区别</p><ul><li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li><li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li><li>静态方法在调用时使用invokestatic指令</li></ul><pre><code class="hljs angelscript">Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span>         <span class="hljs-number">0</span>: new           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class com/nyima/JVM/day5/Demo5 </span>         <span class="hljs-number">3</span>: dup<span class="hljs-comment">//将</span>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method "&lt;init&gt;":()V</span>         <span class="hljs-number">7</span>: astore_1         <span class="hljs-number">8</span>: aload_1         <span class="hljs-number">9</span>: invokespecial #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method test1:()V</span>        <span class="hljs-number">12</span>: aload_1        <span class="hljs-number">13</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method test2:()V</span>        <span class="hljs-number">16</span>: aload_1        <span class="hljs-number">17</span>: invokevirtual #<span class="hljs-number">6</span>                  <span class="hljs-comment">// Method test3:()V</span>        <span class="hljs-number">20</span>: invokestatic  #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method test4:()V</span>        <span class="hljs-number">23</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>new 是创建【对象】，给对象分配堆内存，执行成功会将【对象引用】压入操作数栈 </li><li>dup 是赋值操作数栈栈顶的内容，本例即为【对象引用】，为什么需要两份引用呢，一个是要配 合 invokespecial 调用该对象的构造方法 “<init>“:()V （会消耗掉栈顶一个引用），另一个要 配合 astore_1 赋值给局部变量 </li><li>终方法（ﬁnal），私有方法（private），构造方法都是由 invokespecial 指令来调用，属于静态绑定 </li><li>普通成员方法是由 invokevirtual 调用，属于动态绑定，即支持多态 成员方法与静态方法调用的另一个区别是，执行方法前是否需要【对象引用】 </li></ul><h3 id="5、多态原理"><a href="#5、多态原理" class="headerlink" title="5、多态原理"></a>5、多态原理</h3><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p><p>在执行invokevirtual指令时，经历了以下几个步骤</p><ul><li>先通过栈帧中对象的引用找到对象</li><li>分析对象头，找到对象实际的Class</li><li>Class结构中有<strong>vtable</strong></li><li>查询vtable找到方法的具体地址</li><li>执行方法的字节码</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并发编程</title>
    <link href="/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="并发编程笔记"><a href="#并发编程笔记" class="headerlink" title="并发编程笔记"></a>并发编程笔记</h1><p>本博客根据<strong>黑马java并发编程教程</strong>学习而做的笔记，链接如下</p><p><a href="https://www.bilibili.com/video/av81461839?from=search&amp;seid=8445102345230304010" target="_blank" rel="noopener">https://www.bilibili.com/video/av81461839?from=search&amp;seid=8445102345230304010</a></p><h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 </p><ul><li><p>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication） </p></li><li><p>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP </p></li></ul></li><li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p></li></ul><h2 id="2、并发与并行"><a href="#2、并发与并行" class="headerlink" title="2、并发与并行"></a>2、并发与并行</h2><p>并发是一个CPU在不同的时间去不同线程中执行指令。</p><p>并行是多个CPU同时处理不同的线程。</p><p>引用 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间<strong>应对</strong>（dealing with）多件事情的能力 </li><li>并行（parallel）是同一时间<strong>动手做</strong>（doing）多件事情的能力</li></ul><h3 id="3、应用"><a href="#3、应用" class="headerlink" title="3、应用"></a>3、应用</h3><h4 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h4><p>以调用方角度来讲，如果</p><ul><li><p>需要等待结果返回，才能继续运行就是同步 </p></li><li><p>不需要等待结果返回，就能继续运行就是异步</p></li></ul><p>1) 设计<br>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…<br>2) 结论 </p><ul><li><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p></li><li><p>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</p></li><li><p>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p></li></ul><p>结论 </p><ol><li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 </p></li><li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 </p><ul><li><p>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</p></li><li><p>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 </p></li></ul></li><li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p></li></ol><h1 id="二、线程的创建"><a href="#二、线程的创建" class="headerlink" title="二、线程的创建"></a>二、线程的创建</h1><h2 id="1、创建一个线程（非主线程）"><a href="#1、创建一个线程（非主线程）" class="headerlink" title="1、创建一个线程（非主线程）"></a>1、创建一个线程（非主线程）</h2><h3 id="方法一：直接使用Thread创建线程"><a href="#方法一：直接使用Thread创建线程" class="headerlink" title="方法一：直接使用Thread创建线程"></a>方法一：直接使用Thread创建线程</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程</span>Thread t1 = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"thread running..."</span>);&#125;&#125;;<span class="hljs-comment">//设置线程名</span>t1.setName(<span class="hljs-string">"t1"</span>);<span class="hljs-comment">//启动线程</span>t1.start();System.out.println(<span class="hljs-string">"main running..."</span>);&#125;&#125;</code></pre><h3 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程任务</span>Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"Runnable running"</span>);&#125;&#125;;<span class="hljs-comment">//将Runnable对象传给Thread</span>Thread t = <span class="hljs-keyword">new</span> Thread(r);<span class="hljs-comment">//启动线程</span>t.start();&#125;&#125;</code></pre><h4 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h4><p><strong>当一个接口带有@FunctionalInterface注解时，是可以使用lambda来简化操作的</strong></p><p>所以方法二中的代码可以被简化为</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//创建线程任务</span>Runnable r = () -&gt; &#123;            <span class="hljs-comment">//直接写方法体即可</span>System.out.println(<span class="hljs-string">"Runnable running"</span>);System.out.println(<span class="hljs-string">"Hello Thread"</span>);&#125;;<span class="hljs-comment">//将Runnable对象传给Thread</span>Thread t = <span class="hljs-keyword">new</span> Thread(r);<span class="hljs-comment">//启动线程</span>t.start();&#125;&#125;</code></pre><p>可以再Runnable上使用Alt+Enter</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144534.png" srcset="/img/loading.gif" alt=""></p><h4 id="原理之-Thread-与-Runnable-的关系"><a href="#原理之-Thread-与-Runnable-的关系" class="headerlink" title="原理之 Thread 与 Runnable 的关系"></a>原理之 Thread 与 Runnable 的关系</h4><p>分析 Thread 的源码，理清它与 Runnable 的关系<br><strong>小结</strong></p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了 </li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h3 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h3><p><strong>使用FutureTask可以用泛型指定线程的返回值类型（Runnable的run方法没有返回值）</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test3</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        <span class="hljs-comment">//需要传入一个Callable对象</span>FutureTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> FutureTask&lt;Integer&gt;(<span class="hljs-keyword">new</span> Callable&lt;Integer&gt;() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;System.out.println(<span class="hljs-string">"线程执行!"</span>);Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;&#125;&#125;);Thread r1 = <span class="hljs-keyword">new</span> Thread(task, <span class="hljs-string">"t2"</span>);r1.start();<span class="hljs-comment">//获取线程中方法执行后的返回结果</span>System.out.println(task.get());&#125;&#125;</code></pre><h2 id="2、原理之线程运行"><a href="#2、原理之线程运行" class="headerlink" title="2、原理之线程运行"></a>2、原理之线程运行</h2><h4 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h4><p>Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong> </li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h4 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h4><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能 </li></ul><h2 id="3、常用方法"><a href="#3、常用方法" class="headerlink" title="3、常用方法"></a>3、常用方法</h2><h3 id="1-start-vs-run"><a href="#1-start-vs-run" class="headerlink" title="(1)start() vs run()"></a>(1)start() vs run()</h3><p>  被创建的Thread对象直接调用重写的run方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。所以如果想要在所创建的线程中执行run方法，<strong>需要使用Thread对象的start方法。</strong></p><h3 id="2-sleep-与yield"><a href="#2-sleep-与yield" class="headerlink" title="(2)sleep()与yield()"></a>(2)sleep()与yield()</h3><h4 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h4><ol><li><p>调用 sleep 会让当前线程从 <strong>Running  进入 Timed Waiting 状态（阻塞）</strong>，可通过state()方法查看</p></li><li><p>其它线程可以使用  <strong>interrupt</strong> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行</p></li><li><p>建议用 <strong>TimeUnit 的 sleep</strong> 代替 Thread 的 sleep 来获得更好的可读性 。如：</p><pre><code class="hljs java"><span class="hljs-comment">//休眠一秒</span>TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">//休眠一分钟</span>TimeUnit.MINUTES.sleep(<span class="hljs-number">1</span>);</code></pre></li></ol><h4 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h4><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable  就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程 </li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h4 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h4><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 </p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><pre><code class="hljs java">thread1.setPriority(Thread.MAX_PRIORITY); <span class="hljs-comment">//设置为优先级最高</span></code></pre></li></ul><h3 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="(3)join()方法"></a>(3)join()方法</h3><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><pre><code class="hljs java">Thread thread = <span class="hljs-keyword">new</span> Thread();<span class="hljs-comment">//等待thread线程执行结束</span>thread.join();<span class="hljs-comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span>thread.join(<span class="hljs-number">1000</span>);</code></pre><h3 id="4-interrupt-方法"><a href="#4-interrupt-方法" class="headerlink" title="(4)interrupt()方法"></a>(4)interrupt()方法</h3><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于阻塞状态的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为true。 </li><li>如果是打断因sleep wait join方法而被阻塞的线程，会将打断标记置为false</li></ul><pre><code class="hljs java"><span class="hljs-comment">//用于查看打断标记，返回值被boolean类型</span>t1.isInterrupted();</code></pre><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;    <span class="hljs-keyword">if</span>(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.is<span class="hljs-constructor">Interrupted()</span>) &#123;        break;    &#125;&#125;</code></pre><h5 id="interrupt方法的应用——两阶段终止模式"><a href="#interrupt方法的应用——两阶段终止模式" class="headerlink" title="interrupt方法的应用——两阶段终止模式"></a><strong>interrupt方法的应用</strong>——两阶段终止模式</h5><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144553.png" srcset="/img/loading.gif" alt=""></p><p><strong>代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;                    <span class="hljs-comment">//判断当前线程是否被打断了</span><span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);                        <span class="hljs-comment">//终止线程执行</span><span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();<span class="hljs-comment">//如果是在休眠的时候被打断，不会将打断标记设置为true，这时要重新设置打断标记</span>Thread.currentThread().interrupt();&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();&#125;&#125;</code></pre><h3 id="5-不推荐使用的打断方法"><a href="#5-不推荐使用的打断方法" class="headerlink" title="(5)不推荐使用的打断方法"></a>(5)不推荐使用的打断方法</h3><ul><li>stop方法   停止线程运行（可能造成共享资源无法被释放，其他线程无法使用这些共享资源）</li><li>suspend（暂停线程）/resume（恢复线程）方法</li></ul><h3 id="6-守护线程"><a href="#6-守护线程" class="headerlink" title="(6)守护线程"></a>(6)守护线程</h3><p>当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。<strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong></p><pre><code class="hljs crmsh">//将线程设置为守护线程, 默认为<span class="hljs-literal">false</span><span class="hljs-literal">monitor</span>.setDaemon(<span class="hljs-literal">true</span>);</code></pre><p><strong>守护线程的应用</strong></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求</li></ul><h2 id="4、线程的状态"><a href="#4、线程的状态" class="headerlink" title="4、线程的状态"></a>4、线程的状态</h2><h3 id="1-五种状态"><a href="#1-五种状态" class="headerlink" title="(1)五种状态"></a>(1)五种状态</h3><p>这是从 <strong>操作系统</strong> 层面来描述的</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144606.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联（例如线程调用了start方法）</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 </p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态 </p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 </li></ul></li><li><p>【阻塞状态】</p><ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 </li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们 </li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><h3 id="2-六种状态"><a href="#2-六种状态" class="headerlink" title="(2)六种状态"></a>(2)六种状态</h3><p>这是从 <strong>Java API</strong> 层面来描述的<br>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144621.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>NEW</strong>  线程刚被创建，但是还没有调用 start() 方法</li><li><strong>RUNNABLE</strong> 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了操作系统层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） </li><li><strong>BLOCKED ， WAITING ， TIMED_WAITING</strong> 都是 <strong>Java API 层面</strong>对【阻塞状态】的细分，如sleep就位TIMED_WAITING， join为WAITING状态。后面会在状态转换一节详述。 </li><li><strong>TERMINATED</strong> 当线程代码运行结束</li></ul><h1 id="三、共享模型之管程"><a href="#三、共享模型之管程" class="headerlink" title="三、共享模型之管程"></a>三、共享模型之管程</h1><h2 id="1、共享带来的问题"><a href="#1、共享带来的问题" class="headerlink" title="1、共享带来的问题"></a>1、共享带来的问题</h2><h3 id="1-临界区-Critical-Section"><a href="#1-临界区-Critical-Section" class="headerlink" title="(1)临界区 Critical Section"></a>(1)临界区 Critical Section</h3><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源 <ul><li>多个线程读共享资源其实也没有问题 </li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题 </li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong><br>例如，下面代码中的临界区</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;       counter++; &#125; <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decrement</span><span class="hljs-params">()</span> </span><span class="hljs-function"><span class="hljs-comment">// 临界区 </span></span><span class="hljs-function"></span>&#123;     counter--; &#125;</code></pre><h3 id="2-竞态条件-Race-Condition"><a href="#2-竞态条件-Race-Condition" class="headerlink" title="(2)竞态条件 Race Condition"></a><strong>(2)竞态条件 Race Condition</strong></h3><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h2 id="2、synchronized-解决方案"><a href="#2、synchronized-解决方案" class="headerlink" title="2、synchronized 解决方案"></a>2、synchronized 解决方案</h2><h3 id="1-解决手段"><a href="#1-解决手段" class="headerlink" title="(1)解决手段"></a>(1)解决手段</h3><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock </li><li>非阻塞式的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h3 id="2-synchronized语法"><a href="#2-synchronized语法" class="headerlink" title="(2)synchronized语法"></a>(2)synchronized语法</h3><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象) &#123;<span class="hljs-comment">//临界区</span>&#125;</code></pre><p>例：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//创建一个公共对象，作为对象锁的对象</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object room = <span class="hljs-keyword">new</span> Object(); <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;    Thread t1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                    <span class="hljs-keyword">synchronized</span> (room) &#123;             counter++;                    &#125;           &#125;        &#125;, <span class="hljs-string">"t1"</span>);     Thread t2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;               <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;                     <span class="hljs-keyword">synchronized</span> (room) &#123;                        counter--;                      &#125;            &#125;     &#125;, <span class="hljs-string">"t2"</span>);     t1.start();        t2.start();     t1.join();       t2.join();        log.debug(<span class="hljs-string">"&#123;&#125;"</span>,counter); &#125;</code></pre><h3 id="3-synchronized加在方法上"><a href="#3-synchronized加在方法上" class="headerlink" title="(3)synchronized加在方法上"></a>(3)synchronized加在方法上</h3><ul><li><p>加在成员方法上</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<span class="hljs-comment">//在方法上加上synchronized关键字</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;&#125;&#125;&#125;</code></pre></li><li><p>加在静态方法上</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<span class="hljs-comment">//在静态方法上加上synchronized关键字</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">//等价于</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">synchronized</span>(Demo<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;&#125;&#125;&#125;</code></pre></li></ul><h2 id="3、变量的线程安全分析"><a href="#3、变量的线程安全分析" class="headerlink" title="3、变量的线程安全分析"></a>3、变量的线程安全分析</h2><h4 id="成员变量和静态变量是否线程安全？"><a href="#成员变量和静态变量是否线程安全？" class="headerlink" title="成员变量和静态变量是否线程安全？"></a>成员变量和静态变量是否线程安全？</h4><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li><p>如果只有读操作，则线程安全 </p></li><li><p>如果有读写操作，则这段代码是临界区，需要考虑线程安全</p></li></ul></li></ul><h4 id="局部变量是否线程安全？"><a href="#局部变量是否线程安全？" class="headerlink" title="局部变量是否线程安全？"></a>局部变量是否线程安全？</h4><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必 （要看该对象<strong>是否被共享</strong>且被执行了读写操作）<ul><li>如果该对象没有逃离方法的作用范围，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><ul><li>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144636.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果调用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144649.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果是局部变量，则会在堆中创建对应的对象，不会存在线程安全问题。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144702.png" srcset="/img/loading.gif" alt=""></p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuﬀer </li><li>Random</li><li>Vector （List的线程安全实现类）</li><li>Hashtable （Hash的线程安全实现类）</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们<strong>同一个实例的某个方法时</strong>，是线程安全的</p><ul><li><p>它们的每个方法是原子的（都被加上了synchronized）</p></li><li><p>但注意它们<strong>多个方法的组合不是原子的</strong>，所以可能会出现线程安全问题</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144903.png" srcset="/img/loading.gif" alt=""></p><h3 id="不可变类线程安全性"><a href="#不可变类线程安全性" class="headerlink" title="不可变类线程安全性"></a>不可变类线程安全性</h3><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 </p><p>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？</p><p>这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h2 id="4、Monitor概念"><a href="#4、Monitor概念" class="headerlink" title="4、Monitor概念"></a>4、Monitor概念</h2><h3 id="1-原理之Monitor"><a href="#1-原理之Monitor" class="headerlink" title="(1)原理之Monitor"></a>(1)原理之Monitor</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144917.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。</p><ul><li>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</li><li>如果<strong>已经绑定</strong>，则会去查询该Monitor是否已经有了Owner<ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li><p>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></p></li><li><p><strong>注意</strong>：</p><ul><li><p>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</p></li><li><p>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</p></li></ul></li></ul><h2 id="5、Synchronized原理进阶"><a href="#5、Synchronized原理进阶" class="headerlink" title="5、Synchronized原理进阶"></a>5、Synchronized原理进阶</h2><h3 id="对象头格式"><a href="#对象头格式" class="headerlink" title="对象头格式"></a>对象头格式</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144926.png" srcset="/img/loading.gif" alt=""></p><h3 id="1-轻量级锁（用于优化Monitor这类的重量级锁）"><a href="#1-轻量级锁（用于优化Monitor这类的重量级锁）" class="headerlink" title="(1)轻量级锁（用于优化Monitor这类的重量级锁）"></a>(1)轻量级锁（用于优化Monitor这类的重量级锁）</h3><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><ul><li><p>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word（不再一开始就使用Monitor）</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144942.png" srcset="/img/loading.gif" alt=""></p></li><li><p>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144950.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608144957.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-锁膨胀"><a href="#2-锁膨胀" class="headerlink" title="(2)锁膨胀"></a>(2)锁膨胀</h3><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145004.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>此时便会给对象加上重量级锁（使用Monitor）</p><ul><li><p>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</p></li><li><p>并且该线程放入入EntryList中，并进入阻塞状态(blocked)</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145148.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul><h3 id="3-自旋优化"><a href="#3-自旋优化" class="headerlink" title="(3)自旋优化"></a>(3)自旋优化</h3><p><strong>重量级锁</strong>竞争时，还可以使用自选来优化，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>），这时就可以避免线程进入阻塞状态。</p><ul><li>第一种情况</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145136.png" srcset="/img/loading.gif" alt=""></p><ul><li>第二种情况</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145125.png" srcset="/img/loading.gif" alt=""></p><h3 id="4-偏向锁-用于优化轻量级锁重入"><a href="#4-偏向锁-用于优化轻量级锁重入" class="headerlink" title="(4)偏向锁(用于优化轻量级锁重入)"></a>(4)偏向锁(用于优化轻量级锁重入)</h3><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145109.png" srcset="/img/loading.gif" alt=""></p><h4 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h4><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145101.png" srcset="/img/loading.gif" alt=""></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h4 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h4><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h3 id="5-批量重偏向"><a href="#5-批量重偏向" class="headerlink" title="(5)批量重偏向"></a>(5)批量重偏向</h3><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h3 id="6-批量撤销"><a href="#6-批量撤销" class="headerlink" title="(6)批量撤销"></a>(6)批量撤销</h3><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h2 id="6、Wait-Notify"><a href="#6、Wait-Notify" class="headerlink" title="6、Wait/Notify"></a>6、Wait/Notify</h2><h3 id="1-原理"><a href="#1-原理" class="headerlink" title="(1)原理"></a>(1)原理</h3><p>​    <img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145204.png" srcset="/img/loading.gif" alt=""></p><ul><li>锁对象调用wait方法（obj.wait），就会使当前线程进入WaitSet中，变为WAITING状态。</li><li>处于BLOCKED和WAITING状态的线程都为<strong>阻塞</strong>状态，CPU都不会分给他们时间片。但是有所区别：<ul><li>BLOCKED状态的线程是在竞争对象时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li>WAITING状态的线程是获得了对象的锁，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了wait方法而进入了WaitSet中，处于WAITING状态</li></ul></li><li>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于WAITING状态的线程只有被锁对象调用了notify方法(obj.notify/obj.notifyAll)，才会被唤醒。</li></ul><p><strong>注：只有当对象被锁以后，才能调用wait和notify方法</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//只有在对象被锁住后才能调用wait方法</span><span class="hljs-keyword">synchronized</span> (LOCK) &#123;LOCK.wait();&#125;&#125;&#125;</code></pre><h3 id="2-Wait与Sleep的区别"><a href="#2-Wait与Sleep的区别" class="headerlink" title="(2)Wait与Sleep的区别"></a>(2)Wait与Sleep的区别</h3><p><strong>不同点</strong></p><ul><li>Sleep是Thread类的静态方法，Wait是Object的方法，Object又是所有类的父类，所以所有类都有Wait方法。</li><li>Sleep在阻塞的时候不会释放锁，而Wait在阻塞的时候会释放锁</li><li>Sleep不需要与synchronized一起使用，而Wait需要与synchronized一起使用（对象被锁以后才能使用）</li></ul><p><strong>相同点</strong></p><ul><li>阻塞状态都为<strong>TIMED_WAITING</strong></li></ul><h3 id="3-优雅地使用wait-notify"><a href="#3-优雅地使用wait-notify" class="headerlink" title="(3)优雅地使用wait/notify"></a>(3)优雅地使用wait/notify</h3><p><strong>什么时候适合使用wait</strong></p><ul><li>当线程<strong>不满足某些条件</strong>，需要暂停运行时，可以使用wait。这样会将<strong>对象的锁释放</strong>，让其他线程能够继续运行。如果此时使用sleep，会导致所有线程都进入阻塞，导致所有线程都没法运行，直到当前线程sleep结束后，运行完毕，才能得到执行。</li></ul><p><strong>使用wait/notify需要注意什么</strong></p><ul><li>当有<strong>多个</strong>线程在运行时，对象调用了wait方法，此时这些线程都会进入WaitSet中等待。如果这时使用了<strong>notify</strong>方法，可能会造成<strong>虚假唤醒</strong>（唤醒的不是满足条件的等待线程），这时就需要使用<strong>notifyAll</strong>方法</li></ul><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-keyword">while</span>(<span class="hljs-comment">//不满足条件，一直等待，避免虚假唤醒) &#123;</span>LOCK.wait();&#125;<span class="hljs-comment">//满足条件后再运行</span>&#125;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-comment">//唤醒所有等待线程</span>LOCK.notifyAll();&#125;</code></pre><h2 id="7、模式之保护性暂停"><a href="#7、模式之保护性暂停" class="headerlink" title="7、模式之保护性暂停"></a>7、模式之保护性暂停</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="(1)定义"></a>(1)定义</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145223.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-举例"><a href="#2-举例" class="headerlink" title="(2)举例"></a>(2)举例</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String hello = <span class="hljs-string">"hello thread!"</span>;Guarded guarded = <span class="hljs-keyword">new</span> Guarded();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">"想要得到结果"</span>);<span class="hljs-keyword">synchronized</span> (guarded) &#123;System.out.println(<span class="hljs-string">"结果是："</span>+guarded.getResponse());&#125;System.out.println(<span class="hljs-string">"得到结果"</span>);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;System.out.println(<span class="hljs-string">"设置结果"</span>);<span class="hljs-keyword">synchronized</span> (guarded) &#123;guarded.setResponse(hello);&#125;&#125;).start();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Guarded</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 要返回的结果</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> Object response;    <span class="hljs-comment">//优雅地使用wait/notify</span><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//如果返回结果为空就一直等待，避免虚假唤醒</span><span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">this</span>.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span class="hljs-keyword">return</span> response;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setResponse</span><span class="hljs-params">(Object response)</span> </span>&#123;<span class="hljs-keyword">this</span>.response = response;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-comment">//唤醒休眠的线程</span><span class="hljs-keyword">this</span>.notifyAll();&#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Guarded&#123;"</span> +<span class="hljs-string">"response="</span> + response +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><p><strong>带超时判断的暂停</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getResponse</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time)</span> </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-comment">//获取开始时间</span><span class="hljs-keyword">long</span> currentTime = System.currentTimeMillis();<span class="hljs-comment">//用于保存已经等待了的时间</span><span class="hljs-keyword">long</span> passedTime = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span>(response == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//看经过的时间-开始时间是否超过了指定时间</span><span class="hljs-keyword">long</span> waitTime = time -passedTime;<span class="hljs-keyword">if</span>(waitTime &lt;= <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">break</span>;&#125;<span class="hljs-keyword">try</span> &#123;                   <span class="hljs-comment">//等待剩余时间</span><span class="hljs-keyword">this</span>.wait(waitTime);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//获取当前时间</span>passedTime = System.currentTimeMillis()-currentTime            &#125;&#125;<span class="hljs-keyword">return</span> response;&#125;</code></pre><h3 id="3-join源码——使用保护性暂停模式"><a href="#3-join源码——使用保护性暂停模式" class="headerlink" title="(3)join源码——使用保护性暂停模式"></a>(3)join源码——使用保护性暂停模式</h3><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">join</span><span class="hljs-params">(<span class="hljs-keyword">long</span> millis)</span></span><span class="hljs-function">    <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-keyword">long</span> base = System.currentTimeMillis();        <span class="hljs-keyword">long</span> now = <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"timeout value is negative"</span>);        &#125;        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                wait(<span class="hljs-number">0</span>);            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">while</span> (isAlive()) &#123;                <span class="hljs-keyword">long</span> delay = millis - now;                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">break</span>;                &#125;                wait(delay);                now = System.currentTimeMillis() - base;            &#125;        &#125;    &#125;</code></pre><h2 id="8、park-unpark"><a href="#8、park-unpark" class="headerlink" title="8、park/unpark"></a>8、park/unpark</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="(1)基本使用"></a>(1)基本使用</h3><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><pre><code class="hljs java"><span class="hljs-comment">//暂停线程运行</span>LockSupport.park;<span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread);</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"park"</span>);            <span class="hljs-comment">//暂停线程运行</span>LockSupport.park();System.out.println(<span class="hljs-string">"resume"</span>);&#125;, <span class="hljs-string">"t1"</span>);thread.start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"unpark"</span>);    <span class="hljs-comment">//恢复线程运行</span>LockSupport.unpark(thread);&#125;</code></pre><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="(2)特点"></a>(2)特点</h3><p><strong>与wait/notify的区别</strong></p><ul><li><p>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</p></li><li><p>park ，unpark 是以<strong>线程为单位</strong>来<strong>阻塞</strong>和<strong>唤醒</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么精确</p></li><li><p>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</p></li></ul><h3 id="3-原理"><a href="#3-原理" class="headerlink" title="(3)原理"></a>(3)原理</h3><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象<strong>_counter, _cond,__mutex</strong>组成</p><ul><li><p>先调用park再调用unpark时</p><ul><li><p>先调用park</p><ul><li>线程运行时，会将Park对象中的<strong>_counter的值设为0</strong>；</li><li>调用park时，会先查看counter的值是否为0，如果为0，则将线程放入阻塞队列cond中</li><li>放入阻塞队列中后，会<strong>再次</strong>将counter设置为0</li></ul></li><li><p>然后调用unpark</p><ul><li><p>调用unpark方法后，会将counter的值设置为1</p></li><li><p>去唤醒阻塞队列cond中的线程</p></li><li><p>线程继续运行并将counter的值设为0</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145250.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145303.png" srcset="/img/loading.gif" alt=""></p><ul><li>先调用unpark，再调用park<ul><li>调用unpark<ul><li>会将counter设置为1（运行时0）</li></ul></li><li>调用park方法<ul><li>查看counter是否为0</li><li>因为unpark已经把counter设置为1，所以此时将counter设置为0，但<strong>不放入</strong>阻塞队列cond中</li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145313.png" srcset="/img/loading.gif" alt=""></p><h2 id="9、线程中的状态转换"><a href="#9、线程中的状态转换" class="headerlink" title="9、线程中的状态转换"></a>9、线程中的状态转换</h2><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145330.png" srcset="/img/loading.gif" alt=""></p><h4 id="情况一：NEW-–-gt-RUNNABLE"><a href="#情况一：NEW-–-gt-RUNNABLE" class="headerlink" title="情况一：NEW –&gt; RUNNABLE"></a>情况一：NEW –&gt; RUNNABLE</h4><ul><li>当调用了t.start()方法时，由 NEW –&gt; RUNNABLE </li></ul><h4 id="情况二：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况二：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况二： RUNNABLE &lt;–&gt; WAITING"></a>情况二： RUNNABLE &lt;–&gt; WAITING</h4><ul><li>当调用了t 线程用 synchronized(obj) 获取了对象锁后<ul><li>调用 obj.wait() 方法时，t 线程从 RUNNABLE –&gt; WAITING</li><li>调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 <ul><li>竞争锁成功，t 线程从  WAITING –&gt; RUNNABLE </li><li>竞争锁失败，t 线程从  WAITING –&gt; BLOCKED </li></ul></li></ul></li></ul><h4 id="情况三：RUNNABLE-lt-–-gt-WAITING"><a href="#情况三：RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;–&gt; WAITING"></a>情况三：RUNNABLE &lt;–&gt; WAITING</h4><ul><li><strong>当前线程</strong>调用 t.join() 方法时，当前线程从 RUNNABLE –&gt; WAITING<ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 interrupt() 时，当前线程从 WAITING –&gt; RUNNABLE</li></ul><h4 id="情况四：-RUNNABLE-lt-–-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-–-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;–&gt; WAITING"></a>情况四： RUNNABLE &lt;–&gt; WAITING</h4><ul><li>当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE –&gt; WAITING</li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING –&gt; RUNNABLE</li></ul><h4 id="情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况五： RUNNABLE &lt;–&gt; TIMED_WAITING</h4><p>t 线程用 synchronized(obj) 获取了对象锁后</p><ul><li>调用 obj.wait(<strong>long n</strong>) 方法时，t 线程从 RUNNABLE –&gt; TIMED_WAITING</li><li>t 线程等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时<ul><li>竞争锁成功，t 线程从  TIMED_WAITING –&gt; RUNNABLE</li><li>竞争锁失败，t 线程从  TIMED_WAITING –&gt; BLOCKED </li></ul></li></ul><h4 id="情况六：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况六：RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 t.join<strong>(long n</strong>) 方法时，当前线程从 RUNNABLE –&gt; TIMED_WAITING <ul><li>注意是当前线程在t 线程对象的监视器上等待 </li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 TIMED_WAITING –&gt; RUNNABLE</li></ul><h4 id="情况七：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况七：RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE –&gt; TIMED_WAITING </li><li>当前线程等待时间超过了 n 毫秒，当前线程从  TIMED_WAITING –&gt; RUNNABLE</li></ul><h4 id="情况八：RUNNABLE-lt-–-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-–-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;–&gt; TIMED_WAITING"></a>情况八：RUNNABLE &lt;–&gt; TIMED_WAITING</h4><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 RUNNABLE –&gt; TIMED_WAITING </li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING–&gt; RUNNABLE</li></ul><h4 id="情况九：RUNNABLE-lt-–-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-–-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;–&gt; BLOCKED"></a>情况九：RUNNABLE &lt;–&gt; BLOCKED</h4><ul><li>t 线程用  synchronized(obj) 获取了对象锁时如果<strong>竞争失败</strong>，从  RUNNABLE –&gt; BLOCKED </li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED  的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它<strong>失败</strong>的线程仍然  BLOCKED </li></ul><h4 id="情况十：-RUNNABLE-lt-–-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-–-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;–&gt; TERMINATED"></a>情况十： RUNNABLE &lt;–&gt; TERMINATED</h4><p>当前线<strong>程所有代码运行完毕</strong>，进入 TERMINATED</p><h2 id="10、多把锁"><a href="#10、多把锁" class="headerlink" title="10、多把锁"></a>10、多把锁</h2><p><strong>将锁的粒度细分</strong></p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BigRoom</span> </span>&#123;    <span class="hljs-comment">//额外创建对象来作为锁</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object studyRoom = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bedRoom = <span class="hljs-keyword">new</span> Object();&#125;</code></pre><h2 id="11、活跃性"><a href="#11、活跃性" class="headerlink" title="11、活跃性"></a>11、活跃性</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1)定义"></a>(1)定义</h3><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性</p><h3 id="2-死锁"><a href="#2-死锁" class="headerlink" title="(2)死锁"></a>(2)死锁</h3><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：t1线程获得A对象 锁，接下来想获取B对象的锁t2线程获得B对象锁，接下来想获取A对象的锁 </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> Object A = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">final</span> Object B = <span class="hljs-keyword">new</span> Object();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (A) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">2000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">synchronized</span> (B) &#123;&#125;&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (B) &#123;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">synchronized</span> (A) &#123;&#125;&#125;&#125;).start();&#125;</code></pre><h4 id="定位死锁的方法"><a href="#定位死锁的方法" class="headerlink" title="定位死锁的方法"></a>定位死锁的方法</h4><ul><li><p>jps+jstack ThreadID</p><ul><li><p>在JAVA控制台中的Terminal中输入<strong>jps</strong>指令可以查看运行中的线程ID，使用<strong>jstack ThreadID</strong>可以查看线程状态。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145351.png" srcset="/img/loading.gif" alt=""></p></li></ul><pre><code class="hljs angelscript">F:\Thread_study&gt;jps<span class="hljs-number">20672</span> RemoteMavenServer36<span class="hljs-number">22880</span> Jps<span class="hljs-number">4432</span> Launcher<span class="hljs-number">5316</span> Test5<span class="hljs-number">20184</span> KotlinCompileDaemon<span class="hljs-number">11132</span>F:\Thread_study&gt;jstack <span class="hljs-number">5316</span></code></pre></li></ul><ul><li><p>打印的结果</p><pre><code class="hljs java"><span class="hljs-comment">//找到一个java级别的死锁</span>Found one Java-level deadlock:=============================<span class="hljs-string">"Thread-1"</span>:  waiting to lock monitor <span class="hljs-number">0x0000000017f40de8</span> (object <span class="hljs-number">0x00000000d6188880</span>, a java.lang.Object),  which is held by <span class="hljs-string">"Thread-0"</span><span class="hljs-string">"Thread-0"</span>:  waiting to lock monitor <span class="hljs-number">0x0000000017f43678</span> (object <span class="hljs-number">0x00000000d6188890</span>, a java.lang.Object),  which is held by <span class="hljs-string">"Thread-1"</span></code></pre></li></ul><ul><li><p>jconsole检测死锁</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145405.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145416.png" srcset="/img/loading.gif" alt=""></p></li></ul><h4 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145436.png" srcset="/img/loading.gif" alt=""></p><h4 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h4><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145450.png" srcset="/img/loading.gif" alt=""></p><h3 id="3-活锁"><a href="#3-活锁" class="headerlink" title="(3)活锁"></a>(3)活锁</h3><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h4 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h4><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h4 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h4><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h3 id="4-饥饿"><a href="#4-饥饿" class="headerlink" title="(4)饥饿"></a>(4)饥饿</h3><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>在使用顺序加锁时，可能会出现饥饿现象</p><h2 id="12、ReentrantLock"><a href="#12、ReentrantLock" class="headerlink" title="12、ReentrantLock"></a>12、ReentrantLock</h2><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可中断 </li><li>可以设置超时时间 </li><li>可以设置为公平锁  (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitset)</li></ul><p><strong>基本语法</strong></p><pre><code class="hljs java"><span class="hljs-comment">//获取ReentrantLock对象</span><span class="hljs-keyword">private</span> ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//加锁</span>lock.lock();<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//需要执行的代码</span>&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;</code></pre><h4 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><h4 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h4><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//加锁，可打断锁</span>lock.lockInterruptibly();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();                <span class="hljs-comment">//被打断，返回，不再向下执行</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;&#125;);lock.lock();<span class="hljs-keyword">try</span> &#123;t1.start();Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//打断</span>t1.interrupt();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h4 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h4><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：tryLock(long timeout, TimeUnit unit), 其中timeout为最长等待时间，TimeUnit为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>不设置等待时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;            <span class="hljs-comment">//未设置等待时间，一旦获取失败，直接返回false</span><span class="hljs-keyword">if</span>(!lock.tryLock()) &#123;System.out.println(<span class="hljs-string">"获取失败"</span>);                <span class="hljs-comment">//获取失败，不再向下执行，返回</span><span class="hljs-keyword">return</span>;&#125;System.out.println(<span class="hljs-string">"得到了锁"</span>);lock.unlock();&#125;);lock.lock();<span class="hljs-keyword">try</span>&#123;t1.start();Thread.sleep(<span class="hljs-number">3000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><p>设置等待时间</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();Thread t1 = <span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//判断获取锁是否成功，最多等待1秒</span><span class="hljs-keyword">if</span>(!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;System.out.println(<span class="hljs-string">"获取失败"</span>);<span class="hljs-comment">//获取失败，不再向下执行，直接返回</span><span class="hljs-keyword">return</span>;&#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();<span class="hljs-comment">//被打断，不再向下执行，直接返回</span><span class="hljs-keyword">return</span>;&#125;System.out.println(<span class="hljs-string">"得到了锁"</span>);<span class="hljs-comment">//释放锁</span>lock.unlock();&#125;);lock.lock();<span class="hljs-keyword">try</span>&#123;t1.start();<span class="hljs-comment">//打断等待</span>t1.interrupt();Thread.sleep(<span class="hljs-number">3000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;</code></pre><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。</p><pre><code class="hljs java"><span class="hljs-comment">//默认是不公平锁，需要在创建时指定为公平锁</span>ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);</code></pre><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比 </p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息 </li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒</li></ul><p>使用要点：</p><ul><li>await 前需要<strong>获得锁</strong></li><li>await 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁 </li><li>竞争 lock 锁成功后，从 await 后继续执</li></ul><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;ReentrantLock lock = <span class="hljs-keyword">new</span> ReentrantLock();<span class="hljs-comment">//获得条件变量</span>Condition condition = lock.newCondition();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;lock.lock();<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">while</span>(!judge) &#123;System.out.println(<span class="hljs-string">"不满足条件，等待..."</span>);<span class="hljs-comment">//等待</span>condition.await();&#125;&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;System.out.println(<span class="hljs-string">"执行完毕！"</span>);lock.unlock();&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;lock.lock();<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1</span>);judge = <span class="hljs-keyword">true</span>;<span class="hljs-comment">//释放</span>condition.signal();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;lock.unlock();&#125;&#125;).start();&#125;</code></pre><h2 id="13、同步模式之顺序控制"><a href="#13、同步模式之顺序控制" class="headerlink" title="13、同步模式之顺序控制"></a>13、同步模式之顺序控制</h2><h3 id="Wait-Notify版本"><a href="#Wait-Notify版本" class="headerlink" title="Wait/Notify版本"></a>Wait/Notify版本</h3><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object LOCK = <span class="hljs-keyword">new</span> Object();<span class="hljs-comment">//判断先执行的内容是否执行完毕</span><span class="hljs-keyword">static</span> Boolean judge = <span class="hljs-keyword">false</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;<span class="hljs-keyword">while</span> (!judge) &#123;<span class="hljs-keyword">try</span> &#123;LOCK.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;System.out.println(<span class="hljs-string">"2"</span>);&#125;&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">synchronized</span> (LOCK) &#123;System.out.println(<span class="hljs-string">"1"</span>);judge = <span class="hljs-keyword">true</span>;               <span class="hljs-comment">//执行完毕，唤醒所有等待线程</span>LOCK.notifyAll();&#125;&#125;).start();&#125;</code></pre><h3 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h3><p><strong>wait/notify版本</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test4</span> </span>&#123;<span class="hljs-keyword">static</span> Symbol symbol = <span class="hljs-keyword">new</span> Symbol();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;symbol.run(<span class="hljs-string">"a"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;symbol.run(<span class="hljs-string">"b"</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);&#125;).start();symbol.run(<span class="hljs-string">"c"</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;&#125;).start();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Symbol</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> flag, <span class="hljs-keyword">int</span> nextFlag)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;<span class="hljs-keyword">while</span>(flag != <span class="hljs-keyword">this</span>.flag) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">this</span>.wait();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;System.out.println(str);<span class="hljs-comment">//设置下一个运行的线程标记</span><span class="hljs-keyword">this</span>.flag = nextFlag;<span class="hljs-comment">//唤醒所有线程</span><span class="hljs-keyword">this</span>.notifyAll();&#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 线程的执行标记， 1-&gt;a 2-&gt;b 3-&gt;c</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getFlag</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> flag;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFlag</span><span class="hljs-params">(<span class="hljs-keyword">int</span> flag)</span> </span>&#123;<span class="hljs-keyword">this</span>.flag = flag;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> loopNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<span class="hljs-keyword">this</span>.loopNumber = loopNumber;&#125;&#125;</code></pre><p><strong>await/signal版本</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test5</span> </span>&#123;<span class="hljs-keyword">static</span> AwaitSignal awaitSignal = <span class="hljs-keyword">new</span> AwaitSignal();<span class="hljs-keyword">static</span> Condition conditionA = awaitSignal.newCondition();<span class="hljs-keyword">static</span> Condition conditionB = awaitSignal.newCondition();<span class="hljs-keyword">static</span> Condition conditionC = awaitSignal.newCondition();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"a"</span>, conditionA, conditionB);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"b"</span>, conditionB, conditionC);&#125;).start();<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;awaitSignal.run(<span class="hljs-string">"c"</span>, conditionC, conditionA);&#125;).start();<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;awaitSignal.lock();<span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//唤醒一个等待的线程</span>conditionA.signal();&#125;<span class="hljs-keyword">finally</span> &#123;awaitSignal.unlock();&#125;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String str, Condition thisCondition, Condition nextCondition)</span> </span>&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;loopNumber; i++) &#123;lock();<span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">//全部进入等待状态</span>thisCondition.await();System.out.print(str);nextCondition.signal();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">finally</span> &#123;unlock();&#125;&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loopNumber=<span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLoopNumber</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> loopNumber;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoopNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span> loopNumber)</span> </span>&#123;<span class="hljs-keyword">this</span>.loopNumber = loopNumber;&#125;&#125;</code></pre><h1 id="四、共享模型之内存"><a href="#四、共享模型之内存" class="headerlink" title="四、共享模型之内存"></a>四、共享模型之内存</h1><h2 id="1、JAVA内存模型（JMM）"><a href="#1、JAVA内存模型（JMM）" class="headerlink" title="1、JAVA内存模型（JMM）"></a>1、JAVA内存模型（JMM）</h2><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享共享）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 </p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><h4 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h4><p><strong>退出不出的循环</strong></p><pre><code class="hljs java"><span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">while</span> (run) &#123;<span class="hljs-comment">//如果run为真，则一直执行</span>&#125;&#125;).start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"改变run的值为false"</span>);run = <span class="hljs-keyword">false</span>;&#125;</code></pre><p><strong>为什么无法退出该循环</strong></p><ul><li>初始状态， t 线程刚开始从<strong>主内存</strong>读取了 run 的值到<strong>工作内存</strong>。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145505.png" srcset="/img/loading.gif" alt=""></p><ul><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值<strong>缓存至自己工作内存</strong>中的高速缓存中， 减少对主存中 run 的访问，提高效率</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145517.png" srcset="/img/loading.gif" alt=""></p><ul><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是<strong>旧值</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145529.png" srcset="/img/loading.gif" alt=""></p><p><strong>解决方法</strong></p><ul><li>使用<strong>volatile</strong>易变关键字</li><li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong> </li></ul><pre><code class="hljs java"><span class="hljs-comment">//使用易变关键字</span><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Boolean run = <span class="hljs-keyword">true</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<span class="hljs-keyword">while</span> (run) &#123;<span class="hljs-comment">//如果run为真，则一直执行</span>&#125;&#125;).start();Thread.sleep(<span class="hljs-number">1000</span>);System.out.println(<span class="hljs-string">"改变run的值为false"</span>);run = <span class="hljs-keyword">false</span>;&#125;</code></pre><h4 id="可见性与原子性"><a href="#可见性与原子性" class="headerlink" title="可见性与原子性"></a>可见性与原子性</h4><p>前面例子体现的实际就是<strong>可见性</strong>，它保证的是在多个线程之间，一个线程对<strong>volatile变量</strong>的修改对另一个线程可见， <strong>不能</strong>保证原子性，仅用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况</p><ul><li><p>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</p></li><li><p>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</p></li><li><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p><ul><li><p>因为使用了<strong>synchronized</strong>关键字</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">println</span><span class="hljs-params">(String x)</span> </span>&#123;<span class="hljs-comment">//使用了synchronized关键字</span>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;            print(x);            newLine();        &#125;    &#125;</code></pre></li></ul></li></ul><h4 id="两阶终止模式优化"><a href="#两阶终止模式优化" class="headerlink" title="两阶终止模式优化"></a>两阶终止模式优化</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">//设置标记，用于判断是否被终止了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span>(stop) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);<span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;System.out.println(<span class="hljs-string">"被打断了"</span>);&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();        <span class="hljs-comment">//修改标记</span>stop = <span class="hljs-keyword">true</span>;&#125;&#125;</code></pre><h4 id="同步模式之犹豫模式"><a href="#同步模式之犹豫模式" class="headerlink" title="同步模式之犹豫模式"></a>同步模式之犹豫模式</h4><p><strong>定义</strong> </p><p>Balking （犹豫）模式用在一个线程发现另一个线程或本线程<strong>已经做了某一件相同</strong>的事，那么本线程就无需再做 了，<strong>直接结束返回</strong> </p><ul><li>用一个标记来判断该任务是否已经被执行过了</li><li>需要避免线程安全问题<ul><li>加锁的代码块要尽量的小，以保证性能</li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.nyima.day1;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/3/26 16:11</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test7</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;Monitor monitor = <span class="hljs-keyword">new</span> Monitor();monitor.start();monitor.start();Thread.sleep(<span class="hljs-number">3500</span>);monitor.stop();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Monitor</span> </span>&#123;Thread monitor;<span class="hljs-comment">//设置标记，用于判断是否被终止了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> stop = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//设置标记，用于判断是否已经启动过了</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> starting = <span class="hljs-keyword">false</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 启动监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//上锁，避免多线程运行时出现线程安全问题</span><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<span class="hljs-keyword">if</span> (starting) &#123;<span class="hljs-comment">//已被启动，直接返回</span><span class="hljs-keyword">return</span>;&#125;<span class="hljs-comment">//启动监视器，改变标记</span>starting = <span class="hljs-keyword">true</span>;&#125;<span class="hljs-comment">//设置线控器线程，用于监控线程状态</span>monitor = <span class="hljs-keyword">new</span> Thread() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//开始不停的监控</span><span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span>(stop) &#123;System.out.println(<span class="hljs-string">"处理后续任务"</span>);<span class="hljs-keyword">break</span>;&#125;System.out.println(<span class="hljs-string">"监控器运行中..."</span>);<span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">//线程休眠</span>Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;System.out.println(<span class="hljs-string">"被打断了"</span>);&#125;&#125;&#125;&#125;;monitor.start();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用于停止监控器线程</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//打断线程</span>monitor.interrupt();stop = <span class="hljs-keyword">true</span>;&#125;&#125;</code></pre><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><h3 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h3><ul><li>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145546.png" srcset="/img/loading.gif" alt=""></p><p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p><h3 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h3><ul><li>事实上，现代处理器会设计为一个时钟周期完成一条执行时间长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 这5 个阶段</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145615.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过<strong>重排序</strong>和<strong>组合</strong>来实现<strong>指令级并行</strong></p></li><li><p>指令重排的前提是，重排指令<strong>不能影响结果</strong>，例如</p><pre><code class="hljs java"><span class="hljs-comment">// 可以重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>; System.out.println( a + b );<span class="hljs-comment">// 不能重排的例子 </span><span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> b = a - <span class="hljs-number">5</span>;</code></pre></li></ul><h3 id="支持流水线的处理器"><a href="#支持流水线的处理器" class="headerlink" title="支持流水线的处理器"></a>支持流水线的处理器</h3><p>现代 CPU 支持多级<strong>指令流水线</strong>，例如支持<strong>同时</strong>执行 <strong>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</strong> 的处理器，就可以称之为五级指令流水线。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间长的复杂指令），IPC = 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了指令地<strong>吞吐率</strong>。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145602.png" srcset="/img/loading.gif" alt=""></p><p><strong>在多线程环境下，指令重排序可能导致出现意料之外的结果</strong></p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p><strong>volatile</strong> 修饰的变量，可以<strong>禁用</strong>指令重排</p><ul><li>禁止的是加volatile关键字变量之前的代码被重排序</li></ul><h2 id="4、内存屏障"><a href="#4、内存屏障" class="headerlink" title="4、内存屏障"></a>4、内存屏障</h2><ul><li>可见性 <ul><li><strong>写屏障</strong>（sfence）保证在该屏障<strong>之前</strong>的，对共享变量的改动，都同步到主存当中 </li><li><strong>读屏障</strong>（lfence）保证在该屏障<strong>之后</strong>，对共享变量的读取，加载的是主存中新数据 </li></ul></li><li>有序性 <ul><li>写屏障会确保指令重排序时，不会将<strong>写屏障之前</strong>的代码排在写屏障之后 </li><li>读屏障会确保指令重排序时，不会将<strong>读屏障之后</strong>的代码排在读屏障之前</li></ul></li></ul><h2 id="5、volatile-原理"><a href="#5、volatile-原理" class="headerlink" title="5、volatile 原理"></a>5、volatile 原理</h2><p>volatile的底层实现原理是<strong>内存屏障</strong>，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障 </li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h3><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145630.png" srcset="/img/loading.gif" alt=""></p></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145713.png" srcset="/img/loading.gif" alt=""></p></li></ul><h3 id="如何保证有序性"><a href="#如何保证有序性" class="headerlink" title="如何保证有序性"></a>如何保证有序性</h3><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145723.png" srcset="/img/loading.gif" alt=""></p></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145729.png" srcset="/img/loading.gif" alt=""></p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145741.png" srcset="/img/loading.gif" alt=""></p><p><strong>但是不能解决指令交错问题</strong></p><ul><li>写屏障仅仅是保证之后的读能够读到新的结果，但不能保证读跑到它前面去 </li><li>而有序性的保证也只是保证了<strong>本线程内</strong>相关代码不被重排序</li></ul><h1 id="五、共享模型之无锁"><a href="#五、共享模型之无锁" class="headerlink" title="五、共享模型之无锁"></a>五、共享模型之无锁</h1><h2 id="1、无锁解决线程安全问题"><a href="#1、无锁解决线程安全问题" class="headerlink" title="1、无锁解决线程安全问题"></a>1、无锁解决线程安全问题</h2><ul><li><p>使用<strong>原子整数</strong></p><pre><code class="hljs ebnf"><span class="hljs-attribute">AtomicInteger balance</span> = new AtomicInteger();</code></pre></li></ul><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-function">Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(Account account)</span> </span>&#123;List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">long</span> start = System.nanoTime();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;account.withdraw(<span class="hljs-number">10</span>);&#125;));&#125;ts.forEach(Thread::start);ts.forEach(t -&gt; &#123;<span class="hljs-keyword">try</span> &#123;t.join();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);<span class="hljs-keyword">long</span> end = System.nanoTime();System.out.println(account.getBalance() + <span class="hljs-string">" cost: "</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">" ms"</span>);&#125;&#125;<span class="hljs-comment">//线程不安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-keyword">private</span> Integer balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountUnsafe</span><span class="hljs-params">(Integer balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = balance;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.balance;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;balance -= amount;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Account.demo(<span class="hljs-keyword">new</span> AccountUnsafe(<span class="hljs-number">10000</span>));Account.demo(<span class="hljs-keyword">new</span> AccountCas(<span class="hljs-number">10000</span>));&#125;&#125;<span class="hljs-comment">//线程安全的做法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Account</span> </span>&#123;<span class="hljs-comment">//使用原子整数</span><span class="hljs-keyword">private</span> AtomicInteger balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AccountCas</span><span class="hljs-params">(<span class="hljs-keyword">int</span> balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicInteger(balance);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//得到原子整数的值</span><span class="hljs-keyword">return</span> balance.get();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(Integer amount)</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<span class="hljs-comment">//获得修改前的值</span><span class="hljs-keyword">int</span> prev = balance.get();<span class="hljs-comment">//获得修改后的值</span><span class="hljs-keyword">int</span> next = prev-amount;<span class="hljs-comment">//比较并设值</span><span class="hljs-keyword">if</span>(balance.compareAndSet(prev, next)) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;</code></pre><h2 id="2、CAS与volatile"><a href="#2、CAS与volatile" class="headerlink" title="2、CAS与volatile"></a>2、CAS与volatile</h2><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><p>其中的<strong>关键是 compareAndSwap</strong>（比较并设置值），它的<strong>简称就是 CAS</strong> （也有 Compare And Swap 的说法），它必须是<strong>原子操作</strong>。</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145914.png" srcset="/img/loading.gif" alt=""></p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><ul><li>当一个线程要去修改Account对象中的值时，先获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法）。在调用cas方法时，会将pre与Account中的余额进行比较。<ul><li>如果<strong>两者相等</strong>，就说明该值还未被其他线程修改，此时便可以进行修改操作。</li><li>如果<strong>两者不相等</strong>，就不设置值，重新获取值pre（调用get方法），然后再将其设置为新的值next（调用cas方法），直到修改成功为止。</li></ul></li></ul><p><strong>注意</strong></p><ul><li><p>其实 CAS 的底层是 <strong>lock cmpxchg</strong> 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的<strong>原子性</strong>。</p></li><li><p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p></li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>获取共享变量时，为了保证该变量的<strong>可见性</strong>，需要使用 <strong>volatile</strong> 修饰。<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到<strong>主存中获取</strong> 它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。为2</p><p><strong>注意</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> 仅仅保证了共享变量的可见性，让其它线程能够看到新值，但不能解决指令交错问题（不能保证原子性）</code></pre><p><strong>CAS 必须借助 volatile</strong> 才能读取到共享变量的新值来实现【比较并交换】的效果 </p><h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p>一般情况下，使用无锁比使用加锁的<strong>效率更高。</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145931.png" srcset="/img/loading.gif" alt=""></p><p><strong>原因</strong></p><h3 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h3><p>结合 CAS 和 volatile 可以实现<strong>无锁并发</strong>，适用于<strong>线程数少、多核 CPU</strong> 的场景下。</p><ul><li>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。 </li><li>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。 </li><li>CAS 体现的是<strong>无锁并发、无阻塞并发</strong>，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 </li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h2 id="3、原子整数"><a href="#3、原子整数" class="headerlink" title="3、原子整数"></a>3、原子整数</h2><p>J.U.C 并发包提供了</p><ul><li>AtomicBoolean</li><li>AtomicInteger </li><li>AtomicLong</li></ul><p><strong>以 AtomicInteger 为例</strong></p><pre><code class="hljs java"> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++ System.out.println(i.getAndIncrement());</span> <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i System.out.println(i.incrementAndGet());</span> <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i System.out.println(i.decrementAndGet());</span> <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span>System.out.println(i.getAndDecrement()); <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0） </span>System.out.println(i.getAndAdd(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0） </span>System.out.println(i.addAndGet(-<span class="hljs-number">5</span>)); <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>)); <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 </span>System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>)); <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用 // getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的 </span><span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 </span><span class="hljs-keyword">final</span> System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x)); <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0） </span><span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span>System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));</code></pre><h2 id="4、原子引用"><a href="#4、原子引用" class="headerlink" title="4、原子引用"></a>4、原子引用</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<span class="hljs-function">BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span></span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作     * 如果初始余额为 10000 那么正确的结果应当是 0</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">demo</span><span class="hljs-params">(DecimalAccountImpl account)</span> </span>&#123;List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">long</span> start = System.nanoTime();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;ts.add(<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;account.withdraw(BigDecimal.TEN);&#125;));&#125;ts.forEach(Thread::start);ts.forEach(t -&gt; &#123;<span class="hljs-keyword">try</span> &#123;t.join();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;&#125;);<span class="hljs-keyword">long</span> end = System.nanoTime();System.out.println(account.getBalance() + <span class="hljs-string">" cost: "</span> + (end - start) / <span class="hljs-number">1000_000</span> + <span class="hljs-string">" ms"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecimalAccountImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DecimalAccount</span> </span>&#123;<span class="hljs-comment">//原子引用，泛型类型为小数类型</span>AtomicReference&lt;BigDecimal&gt; balance;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DecimalAccountImpl</span><span class="hljs-params">(BigDecimal balance)</span> </span>&#123;<span class="hljs-keyword">this</span>.balance = <span class="hljs-keyword">new</span> AtomicReference&lt;BigDecimal&gt;(balance);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">getBalance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> balance.get();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> </span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;BigDecimal pre = balance.get();BigDecimal next = pre.subtract(amount);<span class="hljs-keyword">if</span>(balance.compareAndSet(pre, next)) &#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;DecimalAccount.demo(<span class="hljs-keyword">new</span> DecimalAccountImpl(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"10000"</span>)));&#125;&#125;</code></pre><h2 id="5、ABA问题"><a href="#5、ABA问题" class="headerlink" title="5、ABA问题"></a>5、ABA问题</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">"A"</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.get();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C</span>System.out.println(<span class="hljs-string">"change A-&gt;C "</span> + str.compareAndSet(pre, <span class="hljs-string">"C"</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"change A-&gt;B "</span> + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>));&#125;).start();Thread.sleep(<span class="hljs-number">500</span>);<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;System.out.println(<span class="hljs-string">"change B-&gt;A "</span> + str.compareAndSet(<span class="hljs-string">"B"</span>, <span class="hljs-string">"A"</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608145952.png" srcset="/img/loading.gif" alt=""></p><p>主线程仅能判断出共享变量的值与初值 A <strong>是否相同</strong>，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程希望：<br>只要有其它线程【<strong>动过了</strong>】共享变量，那么自己的 <strong>cas 就算失败</strong>，这时，仅比较值是不够的，需要再加一个<strong>版本号</strong></p><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a><strong>AtomicStampedReference</strong></h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;<span class="hljs-comment">//指定版本号</span><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-string">"A"</span>, <span class="hljs-number">0</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.getReference();<span class="hljs-comment">//获得版本号</span><span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>System.out.println(<span class="hljs-string">"change A-&gt;C stamp "</span> + stamp + str.compareAndSet(pre, <span class="hljs-string">"C"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change A-&gt;B stamp "</span> + stamp + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();Thread.sleep(<span class="hljs-number">500</span>);<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<span class="hljs-keyword">int</span> stamp = str.getStamp();System.out.println(<span class="hljs-string">"change B-&gt;A stamp "</span> + stamp +  str.compareAndSet(<span class="hljs-string">"B"</span>, <span class="hljs-string">"A"</span>, stamp, stamp+<span class="hljs-number">1</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150003.png" srcset="/img/loading.gif" alt=""></p><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <strong>AtomicMarkableReference</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;<span class="hljs-comment">//指定版本号</span><span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; str = <span class="hljs-keyword">new</span> AtomicMarkableReference&lt;&gt;(<span class="hljs-string">"A"</span>, <span class="hljs-keyword">true</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;String pre = str.getReference();System.out.println(<span class="hljs-string">"change"</span>);<span class="hljs-keyword">try</span> &#123;other();&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span> &#123;Thread.sleep(<span class="hljs-number">1000</span>);&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;e.printStackTrace();&#125;<span class="hljs-comment">//把str中的A改为C,并比对版本号，如果版本号相同，就执行替换，并让版本号+1</span>System.out.println(<span class="hljs-string">"change A-&gt;C mark "</span> +  str.compareAndSet(pre, <span class="hljs-string">"C"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));&#125;).start();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">other</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<span class="hljs-keyword">new</span> Thread(() -&gt; &#123;System.out.println(<span class="hljs-string">"change A-&gt;A mark "</span> + str.compareAndSet(<span class="hljs-string">"A"</span>, <span class="hljs-string">"A"</span>, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>));&#125;).start();&#125;&#125;</code></pre><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150017.png" srcset="/img/loading.gif" alt=""></p><h2 id="6、原子数组"><a href="#6、原子数组" class="headerlink" title="6、原子数组"></a>6、原子数组</h2><ul><li>AtomicIntegerArray</li><li>AtomicLongArray </li><li>AtomicReferenceArray</li></ul><h2 id="7、原子更新器"><a href="#7、原子更新器" class="headerlink" title="7、原子更新器"></a>7、原子更新器</h2><ul><li>AtomicReferenceFieldUpdater // 域  字段 </li><li>AtomicIntegerFieldUpdater </li><li>AtomicLongFieldUpdate</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo5</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Student student = <span class="hljs-keyword">new</span> Student();AtomicReferenceFieldUpdater updater = AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, "name");updater.compareAndSet(student, <span class="hljs-keyword">null</span>, <span class="hljs-string">"张三"</span>);System.out.println(student);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<span class="hljs-comment">//cas操作需要搭配volatile一起使用</span><span class="hljs-keyword">volatile</span> String name;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +<span class="hljs-string">'&#125;'</span>;&#125;&#125;</code></pre><h2 id="8、原子累加器"><a href="#8、原子累加器" class="headerlink" title="8、原子累加器"></a>8、原子累加器</h2><h2 id="9、LongAdder原理"><a href="#9、LongAdder原理" class="headerlink" title="9、LongAdder原理"></a>9、LongAdder原理</h2><h3 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h3><p>​    <img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150037.png" srcset="/img/loading.gif" alt=""></p><p>缓存行伪共享得从缓存说起<br>缓存与内存的速度比较</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150051.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150102.png" srcset="/img/loading.gif" alt=""></p><p>因为 CPU 与 内存的速度差异很大，需要靠预读数据至<strong>缓存</strong>来提升效率。<br>而缓存以<strong>缓存行</strong>为单位，每个缓存行对应着一块内存，一般是 <strong>64 byte</strong>（8 个 long）<br>缓存的加入会造成数据副本的产生，即同一份数据会缓存在不同核心的缓存行中<br>CPU 要保证数据的<strong>一致性</strong>，如果某个 CPU 核心<strong>更改</strong>了数据，其它 CPU 核心对应的整个缓存行必须<strong>失效</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150111.png" srcset="/img/loading.gif" alt=""></p><p>因为 Cell 是数组形式，在内存中是连续存储的，一个 Cell 为 24 字节（16 字节的对象头和 8 字节的 value），因 此缓存行可以存下 2 个的 Cell 对象。这样问题来了：</p><ul><li>Core-0 要修改 Cell[0]</li><li>Core-1 要修改 Cell[1] </li></ul><p>无论谁修改成功，都会导致对方 Core 的缓存行失效，</p><p>比如 Core-0 中 Cell[0]=6000, Cell[1]=8000 要累加 Cell[0]=6001, Cell[1]=8000 ，这时会让 Core-1 的缓存行失效</p><p>@sun.misc.Contended 用来解决这个问题，它的原理是在使用此注解的对象或字段的<strong>前后各增加 128 字节大小的 padding</strong>（空白），从而让 CPU 将对象预读至缓存时<strong>占用不同的缓存行</strong>，这样，不会造成对方缓存行的失效</p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150119.png" srcset="/img/loading.gif" alt=""></p><p><strong>累加主要调用以下方法</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">long</span> x)</span> </span>&#123;       Cell[] as; <span class="hljs-keyword">long</span> b, v; <span class="hljs-keyword">int</span> m; Cell a;       <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-keyword">null</span> || !casBase(b = base, b + x)) &#123;           <span class="hljs-keyword">boolean</span> uncontended = <span class="hljs-keyword">true</span>;           <span class="hljs-keyword">if</span> (as == <span class="hljs-keyword">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||               (a = as[getProbe() &amp; m]) == <span class="hljs-keyword">null</span> ||               !(uncontended = a.cas(v = a.value, v + x)))               longAccumulate(x, <span class="hljs-keyword">null</span>, uncontended);       &#125;   &#125;</code></pre><p><strong>累加流程图</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608150129.png" srcset="/img/loading.gif" alt=""></p><h2 id="10、Unsafe"><a href="#10、Unsafe" class="headerlink" title="10、Unsafe"></a>10、Unsafe</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过<strong>反射</strong>获得</p><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> &#123;</span><span class="hljs-keyword">static</span> Unsafe unsafe;<span class="hljs-keyword">static</span> &#123;Field theUnsafe = Unsafe.class.getDeclaredField(<span class="hljs-string">"theUnsafe"</span>);theUnsafe.setAccessible(<span class="hljs-literal">true</span>);unsafe = (Unsafe)theUnsafe.<span class="hljs-built_in">get</span>(null);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> unsafe;&#125;&#125;</code></pre><h1 id="六、共享模型之不可变"><a href="#六、共享模型之不可变" class="headerlink" title="六、共享模型之不可变"></a>六、共享模型之不可变</h1><h3 id="1、不可变"><a href="#1、不可变" class="headerlink" title="1、不可变"></a>1、不可变</h3><p>如果一个对象在<strong>不能够修</strong>改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改。</p><h3 id="2、不可变设计"><a href="#2、不可变设计" class="headerlink" title="2、不可变设计"></a>2、不可变设计</h3><h4 id="String类中不可变的体现"><a href="#String类中不可变的体现" class="headerlink" title="String类中不可变的体现"></a>String类中不可变的体现</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span></span><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;    <span class="hljs-comment">/** The value is used for character storage. */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];    <span class="hljs-comment">/** Cache the hash code for the string */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash; <span class="hljs-comment">// Default to 0</span>       <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre><p><strong>ﬁnal 的使用 **<br>发现该类、类中所有属性都是 **ﬁnal</strong> 的</p><ul><li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改 </li><li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，<strong>防止子类无意间破坏不可变性</strong></li></ul><p>*<em>保护性拷贝 *</em></p><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是 如何实现的，就以 substring 为例</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex)</span> </span>&#123;        <span class="hljs-keyword">if</span> (beginIndex &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(beginIndex);        &#125;        <span class="hljs-keyword">int</span> subLen = value.length - beginIndex;        <span class="hljs-keyword">if</span> (subLen &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(subLen);        &#125;    <span class="hljs-comment">//返回的是一个新的对象</span>        <span class="hljs-keyword">return</span> (beginIndex == <span class="hljs-number">0</span>) ? <span class="hljs-keyword">this</span> : <span class="hljs-keyword">new</span> String(value, beginIndex, subLen);    &#125;</code></pre><p>发现其内部是调用 String 的构造方法<strong>创建了一个新字符串</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> count)</span> </span>&#123;        <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset);        &#125;        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(count);            &#125;            <span class="hljs-keyword">if</span> (offset &lt;= value.length) &#123;                <span class="hljs-keyword">this</span>.value = <span class="hljs-string">""</span>.value;                <span class="hljs-keyword">return</span>;            &#125;        &#125;        <span class="hljs-comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span>        <span class="hljs-keyword">if</span> (offset &gt; value.length - count) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> StringIndexOutOfBoundsException(offset + count);        &#125;        <span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);    &#125;</code></pre><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【<strong>保护性拷贝</strong>（defensive copy）】</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis学习文档</title>
    <link href="/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/"/>
    <url>/2020/06/07/Redis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h1><p>本博客根据<strong>黑马Redis教程</strong>学习而做的笔记，链接如下</p><p><a href="https://www.bilibili.com/video/BV1CJ411m7Gc?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1CJ411m7Gc?p=2</a></p><h2 id="一、Redis常用指令"><a href="#一、Redis常用指令" class="headerlink" title="一、Redis常用指令"></a>一、Redis常用指令</h2><pre><code class="hljs awk"><span class="hljs-regexp">//</span>启动容器docker run -d -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -it   --name=<span class="hljs-string">"myredis"</span>  redis输入密码：auth 密码<span class="hljs-regexp">//</span>进入redis容器docker exec -it myredis  redis-cli<span class="hljs-regexp">//</span>退出quit<span class="hljs-keyword">exit</span><span class="hljs-regexp">//</span>清屏clear<span class="hljs-regexp">//</span>获取帮助, 可以使用Tab键来切换help 命令名称help @组名</code></pre><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><p><strong>所有的key都为String类型，讨论数据类型是说的value的类型</strong></p><h3 id="1、String"><a href="#1、String" class="headerlink" title="1、String"></a>1、String</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs q"><span class="hljs-comment">//设置String</span><span class="hljs-built_in">set</span> <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span>mset key1 value1 key2 value2...<span class="hljs-comment">//设置生命周期</span>setex <span class="hljs-built_in">key</span> seconds <span class="hljs-built_in">value</span> <span class="hljs-comment">//得到String</span><span class="hljs-built_in">get</span> <span class="hljs-built_in">key</span> mget key1 key2...<span class="hljs-comment">//删除String</span>del <span class="hljs-built_in">key</span><span class="hljs-comment">//向字符串的后面追加字符，如果有就补在后面，如果没有就新建</span>append <span class="hljs-built_in">key</span> <span class="hljs-built_in">value</span></code></pre><h4 id="string-类型数据的扩展操作"><a href="#string-类型数据的扩展操作" class="headerlink" title="string 类型数据的扩展操作"></a>string 类型数据的扩展操作</h4><p> <strong>String作为数值的操作</strong></p><pre><code class="hljs gauss"><span class="hljs-comment">//增长指令，只有当value为数字时才能增长</span>incr <span class="hljs-built_in">key</span>  incrby <span class="hljs-built_in">key</span> increment  incrbyfloat <span class="hljs-built_in">key</span> increment <span class="hljs-comment">//减少指令，有当value为数字时才能减少</span>decr <span class="hljs-built_in">key</span>  decrby <span class="hljs-built_in">key</span> increment</code></pre><ul><li>string在redis内部存储默认就是一个<strong>字符串</strong>，当遇到增减类操作incr，decr时会<strong>转成数值型</strong>进行计算。 </li><li>redis所有的操作都是<strong>原子性</strong>的，采用<strong>单线程</strong>处理所有业务，命令是一个一个执行的，因此无需考虑并发带来的数据影响。 </li><li>注意：按数值进行操作的数据，如果原始数据不能转成数值，或超越了redis 数值上限范围，将报错。                 9223372036854775807（java中long型数据最大值，Long.MAX_VALUE）</li></ul><p><strong>tips：</strong></p><ul><li>redis用于控制数据库表主键id，为数据库表主键<strong>提供生成策略</strong>，保障数据库表的主键<strong>唯一性</strong> </li><li>此方案适用于所有数据库，且支持数据库集群</li></ul><p><strong>指定生命周期</strong></p><pre><code class="hljs q"><span class="hljs-comment">//设置数据的生命周期，单位 秒</span>setex <span class="hljs-built_in">key</span> seconds <span class="hljs-built_in">value</span><span class="hljs-comment">//设置数据的生命周期，单位 毫秒</span>psetex <span class="hljs-built_in">key</span> milliseconds <span class="hljs-built_in">value</span></code></pre><p><strong>tips</strong></p><ul><li>redis 控制数据的生命周期，通过数据是否失效控制业务行为，适用于所有具有时效性限定控制的操作 </li></ul><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142355.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、Hash"><a href="#2、Hash" class="headerlink" title="2、Hash"></a>2、Hash</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142425.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs q"><span class="hljs-comment">//插入（如果已存在同名的field，会被覆盖）</span>hset <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span>hmset <span class="hljs-built_in">key</span> field1 value1 field2 value2...<span class="hljs-comment">//插入（如果已存在同名的field，不会被覆盖）</span>hsetnx <span class="hljs-built_in">key</span> field <span class="hljs-built_in">value</span><span class="hljs-comment">//取出</span>hget <span class="hljs-built_in">key</span> fieldhgetall <span class="hljs-built_in">key</span><span class="hljs-comment">//删除</span><span class="hljs-built_in">hdel</span> <span class="hljs-built_in">key</span> field1 field2...<span class="hljs-comment">//获取field数量</span>hlen <span class="hljs-built_in">key</span><span class="hljs-comment">//查看是否存在</span>hexists <span class="hljs-built_in">key</span> field<span class="hljs-comment">//获取哈希表中所有的字段名或字段值 </span>hkeys <span class="hljs-built_in">key</span>hvals <span class="hljs-built_in">key</span><span class="hljs-comment">//设置指定字段的数值数据增加指定范围的值 </span>hincrby <span class="hljs-built_in">key</span> field increment hdecrby <span class="hljs-built_in">key</span> field increment</code></pre><h4 id="hash-类型数据操作的注意事项"><a href="#hash-类型数据操作的注意事项" class="headerlink" title="hash 类型数据操作的注意事项"></a>hash 类型数据操作的注意事项</h4><ul><li>hash类型下的value<strong>只能存储字符串</strong>，不允许存储其他数据类型，<strong>不存在嵌套现象</strong>。如果数据未获取到， 对应的值为（nil）</li><li>每个 hash 可以存储 2^32 - 1 个键值</li><li>hash类型十分贴近对象的数据存储形式，并且可以灵活添加删除对象属性。但hash设计初衷不是为了存储大量对象而设计的，<strong>切记不可滥用</strong>，更<strong>不可以将hash作为对象列表使用</strong> </li><li>hgetall 操作可以获取全部属性，如果内部field过多，遍历整体<strong>数据效率就很会低</strong>，有可能成为数据访问瓶颈 </li></ul><h3 id="3、List"><a href="#3、List" class="headerlink" title="3、List"></a>3、List</h3><ul><li>数据存储需求：存储多个数据，并对数据进入存储空间的顺序进行区分 </li><li>需要的存储结构：一个存储空间保存多个数据，且通过数据可以体现进入顺序 </li><li>list类型：保存多个数据，底层使用双向链表存储结构实现 </li><li><strong>元素有序，且可重</strong></li></ul><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs tcl">//添加修改数据,lpush为从左边添加，rpush为从右边添加lpush key value1 value2 value3...rpush key value1 value2 value3...//查看数据, 从左边开始向右查看. 如果不知道<span class="hljs-keyword">list</span>有多少个元素，end的值可以为<span class="hljs-number">-1</span>,代表倒数第一个元素//lpush先进的元素放在最后,rpush先进的元素放在最前面<span class="hljs-keyword">lrange</span> key start end//得到长度llen key//取出对应索引的元素<span class="hljs-keyword">lindex</span> key index//获取并移除元素（从<span class="hljs-keyword">list</span>左边或者右边移除）lpop keyrpop key</code></pre><h4 id="拓展操作"><a href="#拓展操作" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs gams"><span class="hljs-comment">//规定时间内获取并移除数据,b=block,给定一个时间，如果在指定时间内放入了元素，就移除</span><span class="hljs-function"><span class="hljs-title">blpop</span></span> key1 key2... timeout<span class="hljs-function"><span class="hljs-title">brpop</span></span> key1 key2... timeout<span class="hljs-comment">//移除指定元素 count:移除的个数 value:移除的值。 移除多个相同元素时，从左边开始移除</span>lrem key count value</code></pre><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>list中保存的数据都是string类型的，数据总容量是有限的，最多2^32 - 1 个元素 (4294967295)。 </li><li>list具有索引的概念，但是操作数据时通常以<strong>队列</strong>的形式进行入队出队(rpush, rpop)操作，或以<strong>栈</strong>的形式进行入栈出栈(lpush, lpop)操作 </li><li>获取全部数据操作结束索引设置为-1 (倒数第一个元素)</li><li>list可以对数据进行分页操作，通常第一页的信息来自于list，第2页及更多的信息通过数据库的形式加载 </li></ul><h3 id="4、Set"><a href="#4、Set" class="headerlink" title="4、Set"></a>4、Set</h3><ul><li><strong>不重复且无需</strong></li></ul><h4 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs gauss"><span class="hljs-comment">//添加元素</span>sadd <span class="hljs-built_in">key</span> member1 member2...<span class="hljs-comment">//查看元素</span>smembers <span class="hljs-built_in">key</span><span class="hljs-comment">//移除元素</span>srem <span class="hljs-built_in">key</span> member<span class="hljs-comment">//查看元素个数</span>scard <span class="hljs-built_in">key</span><span class="hljs-comment">//查看某个元素是否存在</span>sismember <span class="hljs-built_in">key</span> member</code></pre><h4 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h4><pre><code class="hljs gams"><span class="hljs-comment">//从set中任意选出count个元素</span>srandmember key count<span class="hljs-comment">//从set中任意选出count个元素并移除</span>spop key count<span class="hljs-comment">//求两个集合的交集、并集、差集</span><span class="hljs-function"><span class="hljs-title">sinter</span></span> key1 key2...<span class="hljs-function"><span class="hljs-title">sunion</span></span> key1 key2...<span class="hljs-function"><span class="hljs-title">sdiff</span></span> key1 key2...<span class="hljs-comment">//求两个set的交集、并集、差集，并放入另一个set中</span><span class="hljs-function"><span class="hljs-title">sinterstore</span></span> destination key1 key2...<span class="hljs-function"><span class="hljs-title">sunionstore</span></span> destination key1 key2...<span class="hljs-function"><span class="hljs-title">sdiffstore</span></span> destination key1 key2...<span class="hljs-comment">//求指定元素从原集合放入目标集合中</span>smove source destination key</code></pre><h3 id="5、sorted-set"><a href="#5、sorted-set" class="headerlink" title="5、sorted_set"></a>5、sorted_set</h3><ul><li><p><strong>不重但有序（score）</strong></p></li><li><p>新的存储需求：数据排序有利于数据的有效展示，需要提供一种可以根据自身特征进行<strong>排序</strong>的方式 </p></li><li><p>需要的存储结构：新的存储模型，可以保存<strong>可排序</strong>的数据 </p></li><li><p>sorted_set类型：在set的存储结构基础上添加可排序字段 </p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142442.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs sql">//插入元素, 需要指定score(用于排序)zadd key score1 member1 score2 member2//查看元素(score升序), 当末尾添加withscore时，会将元素的score一起打印出来zrange key <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)//查看元素(score降序), 当末尾添加withscore时，会将元素的score一起打印出来zrevrange <span class="hljs-keyword">key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span> (withscore)//移除元素zrem <span class="hljs-keyword">key</span> member1 member2...//按条件获取数据, 其中<span class="hljs-keyword">offset</span>为索引开始位置，<span class="hljs-keyword">count</span>为获取的数目zrangebyscore <span class="hljs-keyword">key</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span> [withscore] [<span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span> <span class="hljs-keyword">count</span>]zrevrangebyscore <span class="hljs-keyword">key</span> <span class="hljs-keyword">max</span> <span class="hljs-keyword">min</span> [withscore] [<span class="hljs-keyword">limit</span> <span class="hljs-keyword">offset</span> <span class="hljs-keyword">count</span>]//按条件移除元素zremrangebyrank <span class="hljs-keyword">key</span> <span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>zremrangebysocre <span class="hljs-keyword">key</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span>//按照从大到小的顺序移除<span class="hljs-keyword">count</span>个值zpopmax <span class="hljs-keyword">key</span> [<span class="hljs-keyword">count</span>]//按照从小到大的顺序移除<span class="hljs-keyword">count</span>个值zpopmin <span class="hljs-keyword">key</span> [<span class="hljs-keyword">count</span>]//获得元素个数zcard <span class="hljs-keyword">key</span>//获得元素在范围内的个数zcount <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span>//求交集、并集并放入destination中, 其中numkey1为要去交集或并集集合的数目zinterstore destination numkeys key1 key2...zunionstore destination numkeys key1 key2...</code></pre><p><strong>注意</strong></p><ul><li>min与max用于限定搜索查询的<strong>条件</strong> </li><li>start与stop用于限定<strong>查询范围</strong>，作用于索引，表示开始和结束索引 </li><li>offset与count用于限定查询范围，作用于查询结果，表示<strong>开始位置</strong>和<strong>数据总量</strong> </li></ul><h4 id="拓展操作-1"><a href="#拓展操作-1" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs maxima">//查看某个元素的索引(排名)zrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>zrevrank <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>//查看某个元素索引的值zscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span>//增加某个元素索引的值zincrby <span class="hljs-built_in">key</span> increment <span class="hljs-built_in">member</span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>score保存的数据存储空间是64位，如果是整数范围是-9007199254740992~9007199254740992 </li><li>score保存的数据也可以是一个双精度的double值，基于双精度浮点数的特征，<strong>可能会丢失精度</strong>，使用时候要<strong>慎重</strong> </li><li>sorted_set 底层存储还是<strong>基于set</strong>结构的，因此数据<strong>不能重复</strong>，如果重复添加相同的数据，score值将被反复覆盖，<strong>保留最后一次</strong>修改的结果 </li></ul><h2 id="三、通用指令"><a href="#三、通用指令" class="headerlink" title="三、通用指令"></a>三、通用指令</h2><h3 id="1、Key的特征"><a href="#1、Key的特征" class="headerlink" title="1、Key的特征"></a>1、Key的特征</h3><ul><li>key是一个<strong>字符串</strong>，通过key获取redis中保存的数据 </li></ul><h3 id="2、Key的操作"><a href="#2、Key的操作" class="headerlink" title="2、Key的操作"></a>2、Key的操作</h3><h4 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs gauss"><span class="hljs-comment">//查看key是否存在</span>exists <span class="hljs-built_in">key</span><span class="hljs-comment">//删除key</span>del <span class="hljs-built_in">key</span><span class="hljs-comment">//查看key的类型</span><span class="hljs-built_in">type</span> <span class="hljs-built_in">key</span></code></pre><h4 id="拓展操作（时效性操作）"><a href="#拓展操作（时效性操作）" class="headerlink" title="拓展操作（时效性操作）"></a>拓展操作（时效性操作）</h4><pre><code class="hljs gauss"><span class="hljs-comment">//设置生命周期</span>expire <span class="hljs-built_in">key</span> secondspexpire <span class="hljs-built_in">key</span> milliseconds<span class="hljs-comment">//查看有效时间, 如果有有效时间则返回剩余有效时间, 如果为永久有效，则返回-1, 如果Key不存在则返回-2</span>ttl <span class="hljs-built_in">key</span>pttl <span class="hljs-built_in">key</span><span class="hljs-comment">//将有时限的数据设置为永久有效</span>persist <span class="hljs-built_in">key</span></code></pre><h4 id="拓展操作（查询操作）"><a href="#拓展操作（查询操作）" class="headerlink" title="拓展操作（查询操作）"></a>拓展操作（查询操作）</h4><pre><code class="hljs q"><span class="hljs-comment">//根据key查询符合条件的数据</span><span class="hljs-built_in">keys</span> pattern</code></pre><p><strong>查询规则</strong></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142500.png" srcset="/img/loading.gif" alt=""></p><h4 id="拓展操作（其他操作）"><a href="#拓展操作（其他操作）" class="headerlink" title="拓展操作（其他操作）"></a>拓展操作（其他操作）</h4><pre><code class="hljs haxe"><span class="hljs-comment">//重命名key，为了避免覆盖已有数据，尽量少去修改已有key的名字，如果要使用最好使用renamenx</span>rename key <span class="hljs-keyword">new</span><span class="hljs-type">Key</span><span class="hljs-type">renamenx</span> key <span class="hljs-keyword">new</span><span class="hljs-type">Key</span><span class="hljs-type"></span><span class="hljs-type"></span>//查看所有关于key的操作, 可以使用Tab快速切换help @generic</code></pre><h3 id="3、数据库通用操作"><a href="#3、数据库通用操作" class="headerlink" title="3、数据库通用操作"></a>3、数据库通用操作</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>Redis为每个服务提供有16个数据库，编号从0到15 </li><li>每个数据库之间的数据相互独立 </li></ul><h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>切换数据库 0~15select index<span class="hljs-string">//</span>其他操作<span class="hljs-keyword">quit</span>ping<span class="hljs-keyword">echo</span> massage</code></pre><h4 id="拓展操作-2"><a href="#拓展操作-2" class="headerlink" title="拓展操作"></a>拓展操作</h4><pre><code class="hljs stata"><span class="hljs-comment">//移动数据, 必须保证目的数据库中没有该数据</span><span class="hljs-keyword">mov</span> key <span class="hljs-keyword">db</span><span class="hljs-comment">//查看该库中数据总量</span>dbsize</code></pre><h2 id="三、Jedis"><a href="#三、Jedis" class="headerlink" title="三、Jedis"></a>三、Jedis</h2><p><strong>JAVA</strong>操作Redis需要导入jar或引入Maven依赖</p><h3 id="1、Java操作redis的步骤"><a href="#1、Java操作redis的步骤" class="headerlink" title="1、Java操作redis的步骤"></a>1、Java操作redis的步骤</h3><ul><li>连接Redis</li></ul><pre><code class="hljs java"><span class="hljs-comment">//参数为Redis所在的ip地址和端口号</span>Jedis jedis = <span class="hljs-keyword">new</span> Jedis(String host, <span class="hljs-keyword">int</span> port)</code></pre><ul><li>操作Redis</li></ul><pre><code class="hljs java"><span class="hljs-comment">//操作redis的指令和redis本身的指令几乎一致</span>jedis.set(String key, String value);</code></pre><ul><li>断开连接</li></ul><pre><code class="hljs java">jedis.close();</code></pre><h3 id="2、配置工具"><a href="#2、配置工具" class="headerlink" title="2、配置工具"></a>2、配置工具</h3><ul><li>配置文件</li></ul><pre><code class="hljs properties"><span class="hljs-meta">redis.host</span>=<span class="hljs-string">47.103.10.63</span><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><span class="hljs-meta">redis.maxTotal</span>=<span class="hljs-string">30</span><span class="hljs-meta">redis.maxIdle</span>=<span class="hljs-string">10</span></code></pre><ul><li>工具类</li></ul><pre><code class="hljs java"><span class="hljs-keyword">import</span> redis.clients.jedis.Jedis;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPool;<span class="hljs-keyword">import</span> redis.clients.jedis.JedisPoolConfig;<span class="hljs-keyword">import</span> java.util.ResourceBundle;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chen Panwen</span><span class="hljs-comment"> * <span class="hljs-doctag">@data</span> 2020/4/6 16:24</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisUtil</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Jedis jedis = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String host = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> port;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxTotal;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> maxIdle;<span class="hljs-comment">//使用静态代码块，只加载一次</span><span class="hljs-keyword">static</span> &#123;<span class="hljs-comment">//读取配置文件</span>ResourceBundle resourceBundle = ResourceBundle.getBundle(<span class="hljs-string">"redis"</span>);<span class="hljs-comment">//获取配置文件中的数据</span>host = resourceBundle.getString(<span class="hljs-string">"redis.host"</span>);port = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.port"</span>));<span class="hljs-comment">//读取最大连接数</span>maxTotal = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.maxTotal"</span>));<span class="hljs-comment">//读取最大活跃数</span>maxIdle = Integer.parseInt(resourceBundle.getString(<span class="hljs-string">"redis.maxIdle"</span>));JedisPoolConfig jedisPoolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();jedisPoolConfig.setMaxTotal(maxTotal);jedisPoolConfig.setMaxIdle(maxIdle);<span class="hljs-comment">//获取连接池</span>JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool(jedisPoolConfig, host, port);jedis = jedisPool.getResource();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> jedis;&#125;&#125;</code></pre><h2 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h2><h3 id="Redis容器配置redis-conf"><a href="#Redis容器配置redis-conf" class="headerlink" title="Redis容器配置redis.conf"></a>Redis容器配置redis.conf</h3><ul><li><p>redis容器里边的配置文件是需要在<strong>创建容器时映射</strong>进来的 </p><pre><code class="hljs axapta">停止容器：docker <span class="hljs-keyword">container</span> stop myredis删除容器：docker <span class="hljs-keyword">container</span> rm myredis</code></pre></li><li><p>重新开始创建容器</p><pre><code class="hljs groovy"><span class="hljs-number">1.</span> 创建docker统一的外部配置文件mkdir -p docker<span class="hljs-regexp">/redis/</span>&#123;conf,data&#125;<span class="hljs-number">2.</span> 在conf目录创建redis.conf的配置文件touch <span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<span class="hljs-number">3.</span> redis.conf文件的内容需要自行去下载，网上很多<span class="hljs-number">4.</span> 创建启动容器，加载配置文件并持久化数据docker run -d --privileged=<span class="hljs-literal">true</span> -p <span class="hljs-number">6379</span>:<span class="hljs-number">6379</span> -v <span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.<span class="hljs-string">conf:</span><span class="hljs-regexp">/etc/</span>redis<span class="hljs-regexp">/redis.conf -v /</span>docker<span class="hljs-regexp">/redis/</span><span class="hljs-string">data:</span><span class="hljs-regexp">/data --name myredis redis redis-server /</span>etc<span class="hljs-regexp">/redis/</span>redis.conf --appendonly yes</code></pre></li><li><p>文件目录</p><pre><code class="hljs awk"><span class="hljs-regexp">/docker/</span>redis</code></pre></li></ul><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="什么是持久化？"><a href="#什么是持久化？" class="headerlink" title="什么是持久化？"></a>什么是持久化？</h4><p>利用<strong>永久性</strong>存储介质将数据进行保存，在特定的时间将保存的数据进行恢复的工作机制称为持久化。 </p><h4 id="为什么要持久化"><a href="#为什么要持久化" class="headerlink" title="为什么要持久化"></a>为什么要持久化</h4><p><strong>防止</strong>数据的意外<strong>丢失</strong>，确保数据<strong>安全性</strong> </p><h4 id="持久化过程保存什么"><a href="#持久化过程保存什么" class="headerlink" title="持久化过程保存什么"></a>持久化过程保存什么</h4><ul><li>将当前<strong>数据状态</strong>进行保存，<strong>快照</strong>形式，存储数据结果，存储格式简单，关注点在<strong>数据</strong> </li><li>将数据的<strong>操作过程</strong>进行保存，<strong>日志</strong>形式，存储操作过程，存储格式复杂，关注点在数据的操作<strong>过程</strong> </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142523.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、RDB"><a href="#2、RDB" class="headerlink" title="2、RDB"></a>2、RDB</h3><h4 id="RDB启动方式——save"><a href="#RDB启动方式——save" class="headerlink" title="RDB启动方式——save"></a>RDB启动方式——save</h4><ul><li><p>命令</p><pre><code class="hljs ebnf"><span class="hljs-attribute">save</span></code></pre></li><li><p>作用</p><p>手动执行一次保存操作</p></li></ul><h4 id="RDB配置相关命令"><a href="#RDB配置相关命令" class="headerlink" title="RDB配置相关命令"></a>RDB配置相关命令</h4><ul><li>dbfilename dump.rdb <ul><li>说明：设置本地数据库文件名，默认值为 dump.rdb </li><li>经验：通常设置为dump-端口号.rdb</li></ul></li><li>dir<ul><li>说明：设置存储.rdb文件的路径 </li><li>经验：通常设置成存储空间较大的目录中，目录名称data </li></ul></li><li>rdbcompression yes <ul><li>说明：设置存储至本地数据库时是否压缩数据，默认为 yes，采用 LZF 压缩 </li><li>经验：通常默认为开启状态，如果设置为no，可以节省 CPU 运行时间，但会使存储的文件变大（巨大） </li></ul></li><li>rdbchecksum yes<ul><li>说明：设置是否进行RDB文件格式校验，该校验过程在写文件和读文件过程均进行 </li><li>经验：通常默认为开启状态，如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险 </li></ul></li></ul><h4 id="RDB启动方式——save指令工作原理"><a href="#RDB启动方式——save指令工作原理" class="headerlink" title="RDB启动方式——save指令工作原理"></a>RDB启动方式——save指令工作原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142541.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：<strong>save指令</strong>的执行会<strong>阻塞</strong>当前Redis服务器，直到当前RDB过程完成为止，有可能会造成<strong>长时间阻塞</strong>，线上环境<strong>不建议使用</strong>。   </p><h4 id="RDB启动方式——bgsave"><a href="#RDB启动方式——bgsave" class="headerlink" title="RDB启动方式——bgsave"></a>RDB启动方式——bgsave</h4><ul><li><p>命令</p><pre><code class="hljs ebnf"><span class="hljs-attribute">bgsave</span></code></pre></li><li><p>作用</p><p>手动启动后台保存操作，但<strong>不是立即执行</strong> </p></li></ul><h4 id="RDB启动方式-——-bgsave指令工作原理"><a href="#RDB启动方式-——-bgsave指令工作原理" class="headerlink" title="RDB启动方式 —— bgsave指令工作原理"></a>RDB启动方式 —— bgsave指令工作原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142558.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>： <strong>bgsave命令</strong>是针对save阻塞问题做的<strong>优化</strong>。Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用，推荐使用bgsave</p><p><strong>bgsave的保存操作可以通过redis的日志查看</strong></p><pre><code class="hljs ebnf"><span class="hljs-attribute">docker logs myredis</span></code></pre><h4 id="RDB启动方式-——save配置"><a href="#RDB启动方式-——save配置" class="headerlink" title="RDB启动方式 ——save配置"></a>RDB启动方式 ——save配置</h4><ul><li><p>配置</p><pre><code class="hljs maxima"><span class="hljs-built_in">save</span> <span class="hljs-built_in">second</span> changes</code></pre></li><li><p>作用</p><p>满足<strong>限定时间</strong>范围内key的变化数量达到<strong>指定数量</strong>即进行持久化 </p></li><li><p>参数</p><ul><li>second：监控时间范围 </li><li>changes：监控key的变化量 </li></ul></li><li><p>配置位置</p><p>在<strong>conf文件</strong>中进行配置 </p></li></ul><h4 id="RDB启动方式-——save配置原理"><a href="#RDB启动方式-——save配置原理" class="headerlink" title="RDB启动方式 ——save配置原理"></a>RDB启动方式 ——save配置原理</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142617.png" srcset="/img/loading.gif" alt=""></p><p><strong>注意</strong>：</p><ul><li>save配置要根据实际业务情况进行设置，频度过高或过低都会出现性能问题，结果可能是灾难性的 </li><li>save配置中对于second与changes设置通常具有<strong>互补对应</strong>关系（一个大一个小），尽量不要设置成包含性关系 </li><li>save配置启动后执行的是<strong>bgsave操作</strong> </li></ul><h4 id="RDB启动方式对比"><a href="#RDB启动方式对比" class="headerlink" title="RDB启动方式对比"></a>RDB启动方式对比</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142629.png" srcset="/img/loading.gif" alt=""></p><h4 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h4><ul><li>优点<ul><li>RDB是一个紧凑压缩的二进制文件，<strong>存储效率较高</strong> </li><li>RDB内部存储的是redis在某个时间点的数据快照，非常适合用于<strong>数据备份，全量复制</strong>等场景 </li><li>RDB恢复数据的<strong>速度</strong>要比AOF<strong>快</strong>很多</li><li>应用：服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，<strong>用于灾难恢复</strong></li></ul></li><li>缺点<ul><li>RDB方式无论是执行指令还是利用配置，<strong>无法做到实时持久化</strong>，具有较大的可能性丢失数据</li><li>bgsave指令每次运行要执行fork操作<strong>创建子进程</strong>，要<strong>牺牲</strong>掉一些<strong>性能</strong> </li><li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各版本服务之间数据格式<strong>无法兼容</strong>现象 </li></ul></li></ul><h3 id="3、AOF"><a href="#3、AOF" class="headerlink" title="3、AOF"></a>3、AOF</h3><h4 id="AOF概念"><a href="#AOF概念" class="headerlink" title="AOF概念"></a>AOF概念</h4><ul><li>AOF(append only file)持久化：以独立日志的方式记录<strong>每次</strong>写命令，重启时再重新执行AOF文件中命令，以达到恢复数据的目的。与RDB相比可以简单描述为改记录数据为记录数据产生的过程  </li><li>AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的<strong>主流</strong>方式 </li></ul><h4 id="AOF写数据过程"><a href="#AOF写数据过程" class="headerlink" title="AOF写数据过程"></a>AOF写数据过程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142645.png" srcset="/img/loading.gif" alt=""></p><h4 id="AOF写数据三种策略-appendfsync"><a href="#AOF写数据三种策略-appendfsync" class="headerlink" title="AOF写数据三种策略(appendfsync)"></a>AOF写数据三种策略(appendfsync)</h4><ul><li>always<ul><li>每次写入操作均同步到AOF文件中，数据零误差，<strong>性能较低</strong>,<strong>不建议使用</strong></li></ul></li><li>everysec<ul><li>每秒将缓冲区中的指令同步到AOF文件中，数据准确性较高，<strong>性能较高</strong> ，<strong>建议使用</strong>，也是默认配置 </li><li>在系统突然宕机的情况下丢失1秒内的数据 </li></ul></li><li>no<ul><li>由操作系统控制每次同步到AOF文件的周期，整体过程<strong>不可控</strong> </li></ul></li></ul><h4 id="AOF功能开启"><a href="#AOF功能开启" class="headerlink" title="AOF功能开启"></a>AOF功能开启</h4><ul><li><p>配置</p><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span></code></pre><ul><li>​    作用<ul><li>是否开启AOF持久化功能，<strong>默认为不开启状态</strong> </li></ul></li></ul></li><li><p>配置</p><pre><code class="hljs coq">appendfsync always|<span class="hljs-type">everysec</span>|<span class="hljs-type">no</span></code></pre><ul><li>作用<ul><li>AOF写数据策略 </li></ul></li></ul></li></ul><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ul><li>降低磁盘占用量，提高磁盘利用率 </li><li>提高持久化效率，降低持久化写时间，提高IO性能 </li><li>降低数据恢复用时，提高数据恢复效率 </li></ul><h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul><li>进程内已超时的数据不再写入文件 </li><li>忽略<strong>无效指令</strong>，重写时使用进程内数据直接生成，这样新的AOF文件<strong>只保留最终数据的写入命令</strong><ul><li>如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 </li></ul></li><li>对同一数据的多条写命令合并为一条命令 <ul><li>如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c</li><li>为防止数据量过大造成客户端缓冲区溢出，对list、set、hash、zset等类型，每条指令最多写入64个元素 </li></ul></li></ul><h5 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h5><ul><li><p>手动重写</p><pre><code class="hljs ebnf"><span class="hljs-attribute">bgrewriteaof</span></code></pre></li><li><p>自动重写</p><pre><code class="hljs arduino"><span class="hljs-keyword">auto</span>-aof-rewrite-<span class="hljs-built_in">min</span>-<span class="hljs-built_in">size</span> <span class="hljs-built_in">size</span> <span class="hljs-keyword">auto</span>-aof-rewrite-percentage percentage</code></pre></li></ul><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142657.png" srcset="/img/loading.gif" alt=""></p><h5 id="AOF自动重写"><a href="#AOF自动重写" class="headerlink" title="AOF自动重写"></a>AOF自动重写</h5><ul><li><p>自动重写触发条件设置 </p><pre><code class="hljs arduino"><span class="hljs-comment">//触发重写的最小大小</span><span class="hljs-keyword">auto</span>-aof-rewrite-<span class="hljs-built_in">min</span>-<span class="hljs-built_in">size</span> <span class="hljs-built_in">size</span> <span class="hljs-comment">//触发重写须达到的最小百分比</span><span class="hljs-keyword">auto</span>-aof-rewrite-percentage percent</code></pre></li><li><p>自动重写触发比对参数（ 运行指令info Persistence获取具体信息 ） </p><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span>当前<span class="hljs-string">.aof</span>的文件大小aof_current_size <span class="hljs-string">//</span>基础文件大小aof_base_size</code></pre></li><li><p>自动重写触发条件 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142715.png" srcset="/img/loading.gif" alt=""></p></li></ul><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142734.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142755.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142814.png" srcset="/img/loading.gif" alt=""></p><h5 id="缓冲策略"><a href="#缓冲策略" class="headerlink" title="缓冲策略"></a>缓冲策略</h5><p> AOF缓冲区同步文件策略，由参数<strong>appendfsync</strong>控制 </p><ul><li>write操作会触发延迟写（delayed write）机制，Linux在内核提供页缓冲区用 来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依 赖于系统调度机制，列如：缓冲区页空间写满或达到特定时间周期。同步文件之 前，如果此时系统故障宕机，缓冲区内数据将丢失。 </li><li>fsync针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞知道 写入硬盘完成后返回，保证了数据持久化。 </li></ul><h4 id="4、RDB-VS-AOF"><a href="#4、RDB-VS-AOF" class="headerlink" title="4、RDB VS AOF"></a>4、RDB VS AOF</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142837.png" srcset="/img/loading.gif" alt=""></p><h5 id="RDB与AOF的选择之惑"><a href="#RDB与AOF的选择之惑" class="headerlink" title="RDB与AOF的选择之惑"></a>RDB与AOF的选择之惑</h5><ul><li>对数据非常<strong>敏感</strong>，建议使用默认的<strong>AOF</strong>持久化方案  <ul><li>AOF持久化策略使用<strong>everysecond</strong>，每秒钟fsync一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据。 </li><li>注意：由于AOF文件<strong>存储体积较大</strong>，且<strong>恢复速度较慢</strong> </li></ul></li><li>数据呈现<strong>阶段有效性</strong>，建议使用RDB持久化方案<ul><li>数据可以良好的做到阶段内无丢失（该阶段是开发者或运维人员手工维护的），且<strong>恢复速度较快</strong>，阶段 点数据恢复通常采用RDB方案 </li><li>注意：利用RDB实现紧凑的数据持久化会使Redis降的很低</li></ul></li><li>综合比对 <ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊 </li><li>如不能承受数分钟以内的数据丢失，对业务数据非常<strong>敏感</strong>，选用<strong>AOF</strong> </li><li>如能承受数分钟以内的数据丢失，且追求大数据集的<strong>恢复速度</strong>，选用<strong>RDB</strong> </li><li><strong>灾难恢复选用RDB</strong> </li><li>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据</li></ul></li></ul><h2 id="五、Redis事务"><a href="#五、Redis事务" class="headerlink" title="五、Redis事务"></a>五、Redis事务</h2><h3 id="1、Redis事务的定义"><a href="#1、Redis事务的定义" class="headerlink" title="1、Redis事务的定义"></a>1、Redis事务的定义</h3><p>redis事务就是一个命令执行的队列，将一系列预定义命令<strong>包装成一个整体</strong>（一个队列）。当执行时，<strong>一次性按照添加顺序依次执行</strong>，中间不会被打断或者干扰</p><h3 id="2、事务的基本操作"><a href="#2、事务的基本操作" class="headerlink" title="2、事务的基本操作"></a>2、事务的基本操作</h3><ul><li><p>开启事务</p><pre><code class="hljs ebnf"><span class="hljs-attribute">multi</span></code></pre><ul><li>作用<ul><li>作设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中 </li></ul></li></ul></li><li><p>取消事务</p><pre><code class="hljs ebnf"><span class="hljs-attribute">discard</span></code></pre><ul><li>作用<ul><li>终止当前事务的定义，发生在multi之后，exec之前 </li></ul></li></ul></li><li><p>执行事务</p><pre><code class="hljs bash"><span class="hljs-built_in">exec</span></code></pre><ul><li>作用<ul><li>设定事务的结束位置，同时执行事务。<strong>与multi成对出现</strong>，成对使用 </li></ul></li></ul></li></ul><h3 id="3、事务操作的基本流程"><a href="#3、事务操作的基本流程" class="headerlink" title="3、事务操作的基本流程"></a>3、事务操作的基本流程</h3><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142857.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、事务操作的注意事项"><a href="#4、事务操作的注意事项" class="headerlink" title="4、事务操作的注意事项"></a>4、事务操作的注意事项</h3><p><strong>定义事务的过程中，命令格式输入错误怎么办？</strong></p><ul><li>语法错误 <ul><li>指命令书写格式有误  例如执行了一条不存在的指令</li></ul></li><li>处理结果 <ul><li>如果定义的事务中所包含的命令存在语法错误，整体事务中<strong>所有命令均不会执行</strong>。包括那些语法正确的命令</li></ul></li></ul><p><strong>定义事务的过程中，命令执行出现错误怎么办？</strong> </p><ul><li>运行错误 <ul><li>指命令<strong>格式正确</strong>，但是<strong>无法正确的执行</strong>。例如对list进行incr操作 </li></ul></li><li>处理结果 <ul><li>能够正确运行的命令会执行，运行错误的命令不会被执行 </li></ul></li></ul><p><strong>注意</strong>：已经执行完毕的命令对应的数据<strong>不会自动回滚</strong>，需要程序员自己在代码中实现回滚。 </p><h3 id="5、基于特定条件的事务执行"><a href="#5、基于特定条件的事务执行" class="headerlink" title="5、基于特定条件的事务执行"></a>5、基于特定条件的事务执行</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul><li><p>对 key 添加监视锁，在执行exec前如果key发生了变化，终止事务执行</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">watch</span></span> key1, key2....</code></pre></li><li><p>取消对<strong>所有</strong>key的监视</p><pre><code class="hljs ebnf"><span class="hljs-attribute">unwatch</span></code></pre></li></ul><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><ul><li><p>使用 setnx 设置一个公共锁 </p><pre><code class="hljs cs"><span class="hljs-comment">//上锁</span>setnx <span class="hljs-keyword">lock</span>-key <span class="hljs-keyword">value</span><span class="hljs-comment">//释放锁</span>del <span class="hljs-keyword">lock</span>-key</code></pre><ul><li>利用setnx命令的返回值特征，有值（被上锁了）则返回设置失败，无值（没被上锁）则返回设置成功</li><li>操作完毕通过del操作释放锁 </li></ul></li></ul><p><strong>注意</strong>：上述解决方案是一种<strong>设计概念</strong>，依赖规范保障，具有风险性 </p><h4 id="分布式锁加强"><a href="#分布式锁加强" class="headerlink" title="分布式锁加强"></a>分布式锁加强</h4><ul><li><p>使用 expire 为锁key添加<strong>时间限定</strong>，到时不释放，放弃锁 </p><pre><code class="hljs sql">expire <span class="hljs-keyword">lock</span>-<span class="hljs-keyword">key</span> <span class="hljs-keyword">seconds</span>pexpire <span class="hljs-keyword">lock</span>-<span class="hljs-keyword">key</span> milliseconds</code></pre></li><li><p>由于操作通常都是微秒或毫秒级，因此该锁定时间<strong>不宜设置过大</strong>。具体时间需要业务测试后确认。 </p><ul><li>例如：持有锁的操作最长执行时间127ms，最短执行时间7ms。 </li><li>测试百万次最长执行时间对应命令的最大耗时，测试百万次网络延迟平均耗时 </li><li>锁时间设定推荐：最大耗时<em>120%+平均网络延迟</em>110% </li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可 </li></ul></li></ul><h2 id="六、删除策略"><a href="#六、删除策略" class="headerlink" title="六、删除策略"></a>六、删除策略</h2><h3 id="1、数据删除策略"><a href="#1、数据删除策略" class="headerlink" title="1、数据删除策略"></a>1、数据删除策略</h3><ul><li>定时删除</li><li>惰性删除</li><li>定期删除</li></ul><h4 id="时效性数据的存储结构"><a href="#时效性数据的存储结构" class="headerlink" title="时效性数据的存储结构"></a>时效性数据的存储结构</h4><ul><li>Redis中的数据，在expire中以哈希的方式保存在其中。其value是数据在内存中的地址，filed是对应的生命周期</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142921.png" srcset="/img/loading.gif" alt=""></p><h4 id="数据删除策略的目标"><a href="#数据删除策略的目标" class="headerlink" title="数据删除策略的目标"></a>数据删除策略的目标</h4><p>在内存占用与CPU占用之间寻找一种<strong>平衡</strong>，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄露 </p><h3 id="2、三种删除策略"><a href="#2、三种删除策略" class="headerlink" title="2、三种删除策略"></a>2、三种删除策略</h3><h4 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h4><ul><li><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务<strong>立即执行</strong>对键的删除操作</p></li><li><p>优点：<strong>节约内存</strong>，到时就删除，快速释放掉不必要的内存占用  </p></li><li><p>缺点：<strong>CPU压力很大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量 </p></li><li><p>总结：用处理器性能换取存储空间 （<strong>拿时间换空间</strong>）</p></li></ul><h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><ul><li>数据到达过期时间，不做处理。等下次访问该数据时 <ul><li>如果未过期，返回数据 </li><li>发现已过期，删除，返回不存在 </li></ul></li><li>优点：<strong>节约CPU性能</strong>，发现必须删除的时候才删除 </li><li>缺点：<strong>内存压力很大</strong>，出现长期占用内存的数据 </li><li>总结：用存储空间换取处理器性能 （拿空间换时间） </li></ul><h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142941.png" srcset="/img/loading.gif" alt=""></p><ul><li>周期性轮询redis库中的时效性数据，采用<strong>随机抽取的策略</strong>，利用过期数据占比的方式控制删除频度 </li><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置 </li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理 </li><li>总结：周期性抽查存储空间 （随机抽查，重点抽查） </li></ul><h3 id="3、逐出算法"><a href="#3、逐出算法" class="headerlink" title="3、逐出算法"></a>3、逐出算法</h3><p>*<em>当新数据进入redis时，如果内存不足怎么办？ *</em></p><ul><li>Redis使用内存存储数据，在执行每一个命令前，会调用<strong>freeMemoryIfNeeded()</strong>检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为<strong>逐出算法</strong></li><li><strong>注意</strong>：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现错误信息。 </li></ul><h4 id="影响数据逐出的相关配置"><a href="#影响数据逐出的相关配置" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><ul><li><p>最大可使用内存 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory</span></code></pre><p>占用物理内存的比例，默认值为0，表示不限制。生产环境中根据需求设定，通常设置在50%以上。 </p></li><li><p>每次选取待删除数据的个数 </p><pre><code class="hljs ebnf"><span class="hljs-attribute">maxmemory-samples</span></code></pre><p>选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据 </p></li><li><p>删除策略</p><pre><code class="hljs cmake">maxmemory-<span class="hljs-keyword">policy</span></code></pre><p>达到最大内存后的，对被挑选出来的数据进行删除的策略 </p></li></ul><h4 id="影响数据逐出的相关配置-1"><a href="#影响数据逐出的相关配置-1" class="headerlink" title="影响数据逐出的相关配置"></a>影响数据逐出的相关配置</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608142953.png" srcset="/img/loading.gif" alt=""></p><p><strong>LRU</strong>：最长时间没被使用的数据</p><p><strong>LFU</strong>：一段时间内使用次数最少的数据</p><h4 id="数据逐出策略配置依据"><a href="#数据逐出策略配置依据" class="headerlink" title="数据逐出策略配置依据"></a><strong>数据逐出策略配置依据</strong></h4><ul><li>使用<strong>INFO命令</strong>输出监控信息，查询缓存 <strong>hit 和 miss</strong> 的次数，根据业务需求调优Redis配置 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143004.png" srcset="/img/loading.gif" alt=""></p><h2 id="七、高级数据类型"><a href="#七、高级数据类型" class="headerlink" title="七、高级数据类型"></a>七、高级数据类型</h2><h3 id="1、Bitmaps"><a href="#1、Bitmaps" class="headerlink" title="1、Bitmaps"></a>1、Bitmaps</h3><h4 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h4><ul><li><p>获取指定key对应偏移量上的bit值 </p><pre><code class="hljs applescript">getbit key <span class="hljs-built_in">offset</span></code></pre></li><li><p>设置指定key对应偏移量上的bit值，value只能是1或0 </p><pre><code class="hljs excel">setbit key <span class="hljs-built_in">offset</span> <span class="hljs-built_in">value</span></code></pre></li></ul><h4 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h4><ul><li><p>对指定key按位进行交、并、非、异或操作，并将结果<strong>保存到destKey</strong>中 </p><pre><code class="hljs apache"><span class="hljs-attribute">bitop</span> op destKey key1<span class="hljs-meta"> [key2...]</span></code></pre><ul><li>and：交 </li><li>or：并 </li><li>not：非 </li><li>xor：异或</li></ul></li><li><p>统计指定key中1的数量 </p><pre><code class="hljs xquery">bitcount<span class="hljs-built_in"> key</span> [<span class="hljs-keyword">start</span> <span class="hljs-keyword">end</span>]</code></pre></li></ul><h3 id="2、HyperLogLog"><a href="#2、HyperLogLog" class="headerlink" title="2、HyperLogLog"></a>2、HyperLogLog</h3><h4 id="基数"><a href="#基数" class="headerlink" title="基数"></a>基数</h4><ul><li>基数是数据集<strong>去重后元素个数</strong> </li><li>HyperLogLog 是用来做基数统计的，运用了LogLog的算法 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143020.png" srcset="/img/loading.gif" alt=""></p><h4 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加数据</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfadd</span></span> key element1, element2...</code></pre></li><li><p>统计数据</p><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">pfcount</span></span> key1 key2....</code></pre></li><li><p>合并数据</p><pre><code class="hljs apache"><span class="hljs-attribute">pfmerge</span> destkey sourcekey<span class="hljs-meta"> [sourcekey...]</span></code></pre></li></ul><h4 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h4><ul><li>用于进行基数统计，<strong>不是集合，不保存数据</strong>，只记录数量而不是具体数据 </li><li>核心是基数估算算法，最终数值<strong>存在一定误差</strong> </li><li>误差范围：基数估计的结果是一个带有 0.81% 标准错误的近似值</li><li><strong>耗空间极小</strong>，每个hyperloglog key占用了12K的内存用于标记基数 </li><li>pfadd命令不是一次性分配12K内存使用，会随着基数的增加内存<strong>逐渐增大</strong> </li><li>Pfmerge命令<strong>合并后占用</strong>的存储空间为<strong>12K</strong>，无论合并之前数据量多少 </li></ul><h3 id="3、GEO"><a href="#3、GEO" class="headerlink" title="3、GEO"></a>3、GEO</h3><h4 id="基本操作-8"><a href="#基本操作-8" class="headerlink" title="基本操作"></a>基本操作</h4><ul><li><p>添加坐标点</p><pre><code class="hljs routeros">geoadd key longitude latitude member [longitude latitude member <span class="hljs-built_in">..</span>.] georadius key longitude latitude<span class="hljs-built_in"> radius </span>m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code></pre></li><li><p>获取坐标点</p><pre><code class="hljs routeros">geopos key member [member <span class="hljs-built_in">..</span>.] georadiusbymember key member<span class="hljs-built_in"> radius </span>m|km|ft|mi [withcoord] [withdist] [withhash] [count count]</code></pre></li><li><p>计算坐标点距离 </p><pre><code class="hljs maxima">geodist <span class="hljs-built_in">key</span> member1 member2 [unit] geohash <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span> [<span class="hljs-built_in">member</span> ...]</code></pre></li></ul><h2 id="八、主从复制"><a href="#八、主从复制" class="headerlink" title="八、主从复制"></a>八、主从复制</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="多台服务器连接方案"><a href="#多台服务器连接方案" class="headerlink" title="多台服务器连接方案"></a>多台服务器连接方案</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143033.png" srcset="/img/loading.gif" alt=""></p><ul><li>提供数据方：master <ul><li>主服务器，主节点，主库</li><li>主客户端</li></ul></li><li>接收数据的方：slave<ul><li>从服务器，从节点，从库</li><li>从客户端</li></ul></li><li>需要解决的问题<ul><li><strong>数据同步</strong></li></ul></li><li>核心工作<ul><li>master的数据<strong>复制</strong>到slave中 </li></ul></li></ul><h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p>主从复制即将master中的数据即时、有效的<strong>复制</strong>到slave中 </p><p>特征：一个master可以拥有多个slave，一个slave只对应一个master </p><p>职责： </p><ul><li>master: <ul><li>写数据 </li><li>执行写操作时，将出现变化的数据自动<strong>同步</strong>到slave </li><li>读数据（可忽略） </li></ul></li><li>slave: <ul><li>读数据 </li><li>写数据（<strong>禁止</strong>） </li></ul></li></ul><h3 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h3><ul><li>读写分离：master写、slave读，提高服务器的读写负载能力 </li><li>负载均衡：基于主从结构，配合读写分离，由slave分担master负载，并根据需求的变化，改变slave的数量，通过多个从节点分担数据读取负载，大大提高Redis服务器并发量与数据吞吐量</li><li>故障恢复：当master出现问题时，由slave提供服务，实现快速的故障恢复 </li><li>数据冗余：实现数据热备份，是持久化之外的一种数据冗余方式 </li><li>高可用基石：基于主从复制，构建哨兵模式与集群，实现Redis的高可用方案 </li></ul><h3 id="3、工作流程"><a href="#3、工作流程" class="headerlink" title="3、工作流程"></a>3、工作流程</h3><h4 id="总述"><a href="#总述" class="headerlink" title="总述"></a><strong>总述</strong></h4><ul><li>主从复制过程大体可以分为3个阶段 <ul><li>建立连接阶段（即准备阶段） </li><li>数据同步阶段 </li><li>命令传播阶段 </li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143046.png" srcset="/img/loading.gif" alt=""></p><h4 id="阶段一：建立连接"><a href="#阶段一：建立连接" class="headerlink" title="阶段一：建立连接"></a>阶段一：建立连接</h4><ul><li><p>建立slave到master的连接，使master能够识别slave，并保存slave端口号  </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143102.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>*<em>主从连接（slave连接master） *</em></p><ul><li><p>方式一：客户端发送命令 </p><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre></li><li><p>方式二：启动服务器参数</p><pre><code class="hljs xml">redis-server -slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre></li><li><p>方式三：服务器配置 （常用）</p><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span></code></pre><p><img src="C:%5CUsers%5C86183%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200421083330289.png" srcset="/img/loading.gif" alt="image-20200421083330289"></p></li></ul><p><strong>主从断开连接</strong></p><ul><li><p><strong>客户端</strong>发送命令  </p><pre><code class="hljs nginx"><span class="hljs-attribute">slaveof</span> <span class="hljs-literal">no</span> one</code></pre><ul><li>说明： slave断开连接后，<strong>不会删除已有数据</strong>，只是不再接受master发送的数据 </li></ul></li></ul><p><strong>授权访问</strong></p><ul><li><p>master客户端发送命令设置密码 </p><pre><code class="hljs xml">requirepass <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>master配置文件设置密码</p><pre><code class="hljs routeros">config <span class="hljs-builtin-name">set</span> requirepass &lt;password&gt; config <span class="hljs-builtin-name">get</span> requirepass</code></pre></li><li><p>slave客户端发送命令设置密码 </p><pre><code class="hljs xml">auth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>slave配置文件设置密码 </p><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span></code></pre></li><li><p>slave启动服务器设置密码 </p><pre><code class="hljs pgsql">redis-<span class="hljs-keyword">server</span> –a &lt;<span class="hljs-keyword">password</span>&gt;</code></pre></li></ul><h4 id="阶段二：数据同步阶段"><a href="#阶段二：数据同步阶段" class="headerlink" title="阶段二：数据同步阶段"></a>阶段二：数据同步阶段</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143117.png" srcset="/img/loading.gif" alt=""></p><ul><li><strong>全量复制</strong><ul><li>将master执行bgsave之前，master中所有的数据同步到slave中</li></ul></li><li><strong>部分复制</strong>（增量复制）<ul><li>将master执行bgsave操作中，新加入的数据（复制缓冲区中的数据）传给slave，slave通过bgrewriteaof指令来恢复数据</li></ul></li></ul><h5 id="数据同步阶段master说明"><a href="#数据同步阶段master说明" class="headerlink" title="数据同步阶段master说明"></a>数据同步阶段master说明</h5><ol><li>如果master数据量巨大，数据同步阶段应<strong>避开流量高峰期</strong>，<strong>避免</strong>造成master<strong>阻塞</strong>，影响业务正常执行 </li><li>复制缓冲区大小设定不合理，会导致数据溢出。如进行全量复制周期太长，进行部分复制时发现数据已经存在丢失的情况，必须进行第二次全量复制，致使slave陷入<strong>死循环</strong>状态。 </li></ol><pre><code class="hljs angelscript">repl-backlog-size <span class="hljs-number">1</span>mb</code></pre><ol start="3"><li>master单机内存占用主机内存的比例不应过大，建议使用50%-70%的内存，留下30%-50%的内存用于执 行bgsave命令和创建复制缓冲区</li></ol><h5 id="数据同步阶段slave说明"><a href="#数据同步阶段slave说明" class="headerlink" title="数据同步阶段slave说明"></a>数据同步阶段slave说明</h5><ol><li>为避免slave进行全量复制、部分复制时服务器响应阻塞或数据不同步，<strong>建议关闭</strong>此期间的对外服务 </li></ol><pre><code class="hljs coffeescript">slave-serve-stale-data <span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span></code></pre><ol start="2"><li>数据同步阶段，master发送给slave信息可以理解master是slave的一个客户端，主动向slave发送命令</li><li>多个slave同时对master请求数据同步，master发送的RDB文件增多，会对带宽造成巨大冲击，如果master带宽不足，因此数据同步需要根据业务需求，适量错峰 </li><li>slave过多时，建议调整拓扑结构，由一主多从结构变为树状结构，中间的节点既是master，也是 slave。注意使用树状结构时，由于层级深度，导致深度越高的slave与最顶层master间数据同步延迟较大，<strong>数据一致性变差，应谨慎选择</strong></li></ol><h4 id="阶段三：命令传播阶段"><a href="#阶段三：命令传播阶段" class="headerlink" title="阶段三：命令传播阶段"></a>阶段三：命令传播阶段</h4><ul><li>当master数据库状态被修改后，导致主从服务器数据库状态不一致，此时需要让主从数据同步到一致的状态，<strong>同步</strong>的动作称为<strong>命令传播</strong> </li><li>master将接收到的数据变更命令发送给slave，slave接收命令后执行命令 </li></ul><ul><li>主从复制过程大体可以分为3个阶段 <ul><li>建立连接阶段（即准备阶段） </li><li>数据同步阶段 </li><li>命令传播阶段 </li></ul></li></ul><h5 id="命令传播阶段的部分复制"><a href="#命令传播阶段的部分复制" class="headerlink" title="命令传播阶段的部分复制"></a>命令传播阶段的部分复制</h5><ul><li>命令传播阶段出现了断网现象 <ul><li>网络闪断闪连 </li><li>短时间网络中断 </li><li>长时间网络中断 </li></ul></li></ul><ul><li><p>部分复制的<strong>三个核心要素</strong> </p><ul><li><p>服务器的运行 id（run id） </p></li><li><p>主服务器的复制积压缓冲区 </p></li><li><p>主从服务器的复制偏移量 </p></li></ul></li></ul><h5 id="服务器运行ID（runid）"><a href="#服务器运行ID（runid）" class="headerlink" title="服务器运行ID（runid）"></a>服务器运行ID（runid）</h5><ul><li><p>概念：服务器运行ID是每一台服务器每次运行的身份识别码，一台服务器多次运行可以生成多个运行id </p></li><li><p>组成：运行id由40位字符组成，是一个随机的十六进制字符 例如- - </p><ul><li>fdc9ff13b9bbaab28db42b3d50f852bb5e3fcdce </li></ul></li><li><p>作用：运行id被用于在服务器间进行传输，识别身份 </p><ul><li>如果想两次操作均对同一台服务器进行，必须每次操作携带对应的运行id，用于对方识别 </li></ul></li><li><p>实现方式：运行id在每台服务器启动时自动生成的，master在首次连接slave时，会将自己的运行ID发送给slave，slave保存此ID，通过<strong>info Server</strong>命令，可以查看节点的runid </p></li></ul><h5 id="复制缓冲区"><a href="#复制缓冲区" class="headerlink" title="复制缓冲区"></a>复制缓冲区</h5><ul><li><p>概念：复制缓冲区，又名复制积压缓冲区，是一个<strong>先进先出（FIFO）的队列</strong>，用于存储服务器执行过的命 令，每次传播命令，master都会将传播的命令记录下来，并存储在复制缓冲区 </p></li><li><p>由来：每台服务器启动时，如果开启有AOF或被连接成为master节点，即创建复制缓冲区 </p></li><li><p>作用：用于保存master收到的所有指令（仅影响数据变更的指令，例如set，select） </p></li><li><p>数据来源：当master接收到主客户端的指令时，除了将指令执行，会将该指令存储到缓冲区中 </p></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143134.png" srcset="/img/loading.gif" alt=""></p><h5 id="复制缓冲区内部工作原理"><a href="#复制缓冲区内部工作原理" class="headerlink" title="复制缓冲区内部工作原理"></a>复制缓冲区内部工作原理</h5><ul><li><p>组成 </p><ul><li>偏移量 </li><li>字节值 </li></ul></li><li><p>工作原理 </p><ul><li>通过offset区分不同的slave当前数据传播的差异 </li><li>master记录<strong>已发送</strong>的信息对应的offset </li><li>slave记录<strong>已接收</strong>的信息对应的offset </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143149.png" srcset="/img/loading.gif" alt=""></p></li></ul><h5 id="主从服务器复制偏移量（offset）"><a href="#主从服务器复制偏移量（offset）" class="headerlink" title="主从服务器复制偏移量（offset）"></a>主从服务器复制偏移量（offset）</h5><ul><li><p>概念：一个数字，描述复制缓冲区中的指令字节位置 </p></li><li><p>分类： </p><ul><li>master复制偏移量：记录发送给所有slave的指令字节对应的位置（多个） </li><li>slave复制偏移量：记录slave接收master发送过来的指令字节对应的位置（一个） </li></ul></li><li><p>数据来源： master端：发送一次记录一次 slave端：接收一次记录一次 </p></li><li><p>作用：<strong>同步信息</strong>，比对master与slave的差异，当slave断线后，恢复数据使用 </p></li></ul><h5 id="数据同步-命令传播阶段工作流程"><a href="#数据同步-命令传播阶段工作流程" class="headerlink" title="数据同步+命令传播阶段工作流程"></a>数据同步+命令传播阶段工作流程</h5><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143228.png" srcset="/img/loading.gif" alt=""></p><h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><ul><li><p>进入<strong>命令传播阶段候</strong>，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线 </p></li><li><p>master心跳： </p><ul><li>指令：PING </li><li>周期：由repl-ping-slave-period决定，默认10秒 </li><li>作用：判断slave是否在线 </li><li>查询：INFO replication 获取slave最后一次连接时间间隔，lag项维持在0或1视为正常 </li></ul></li><li><p>slave心跳任务 </p><ul><li>指令：REPLCONF ACK {offset} </li><li>周期：1秒 </li><li>作用1：汇报slave自己的复制偏移量，获取最新的数据变更指令 </li><li>作用2：判断master是否在线 </li></ul></li></ul><h5 id="心跳阶段注意事项"><a href="#心跳阶段注意事项" class="headerlink" title="心跳阶段注意事项"></a>心跳阶段注意事项</h5><ul><li><p>当slave多数掉线，或延迟过高时，master为保障数据稳定性，将拒绝所有信息同步操作 </p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">to</span>-<span class="hljs-built_in">write</span> <span class="hljs-number">2</span> <span class="hljs-built_in">min</span>-slaves-<span class="hljs-built_in">max</span>-lag <span class="hljs-number">8</span></code></pre><ul><li>slave数量少于2个，或者所有slave的延迟都大于等于10秒时，强制关闭master写功能，停止数据同步 </li></ul></li><li><p>slave数量由slave发送<strong>REPLCONF ACK</strong>命令做确认 </p></li><li><p>slave延迟由slave发送<strong>REPLCONF ACK</strong>命令做确认</p></li></ul><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143241.png" srcset="/img/loading.gif" alt=""></p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143304.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143317.png" srcset="/img/loading.gif" alt=""></p><h4 id="频繁的网络中断"><a href="#频繁的网络中断" class="headerlink" title="频繁的网络中断"></a>频繁的网络中断</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143327.png" srcset="/img/loading.gif" alt=""></p><p><img src="D:%5C%E5%90%8E%E7%AB%AF%E8%B5%84%E6%96%99NEW%5C%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3%5CRedis%5CRedis%E5%AD%A6%E4%B9%A0%E6%96%87%E6%A1%A3.assets%5Cimage-20200608143339306.png" srcset="/img/loading.gif" alt="image-20200608143339306"></p><h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143352.png" srcset="/img/loading.gif" alt=""></p><h2 id="九、哨兵"><a href="#九、哨兵" class="headerlink" title="九、哨兵"></a>九、哨兵</h2><h3 id="1、简介-2"><a href="#1、简介-2" class="headerlink" title="1、简介"></a>1、简介</h3><p>哨兵(sentinel) 是一个<strong>分布式系统</strong>，用于对主从结构中的每台服务器进行<strong>监控</strong>，当出现故障时通过投票机制<strong>选择</strong>新的master并将所有slave连接到新的master。 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143401.png" srcset="/img/loading.gif" alt=""></p><h3 id="2、作用-1"><a href="#2、作用-1" class="headerlink" title="2、作用"></a>2、作用</h3><ul><li>监控 <ul><li>不断的检查master和slave是否正常运行。 master存活检测、master与slave运行情况检测 </li></ul></li><li>通知（提醒）<ul><li>当被监控的服务器出现问题时，向其他（哨兵间，客户端）发送通知。 </li></ul></li><li>自动故障转移 <ul><li>断开master与slave连接，选取一个slave作为master，将其他slave连接到新的master，并告知客户端新的服务器地址 </li></ul></li></ul><p><strong>注意：</strong><br>哨兵也是一台<strong>redis服务器</strong>，只是不提供数据服务 通常哨兵配置数量为<strong>单数</strong> </p><h3 id="3、配置哨兵"><a href="#3、配置哨兵" class="headerlink" title="3、配置哨兵"></a>3、配置哨兵</h3><ul><li><p>配置一拖二的主从结构  </p></li><li><p>配置三个哨兵（配置相同，端口不同） </p><ul><li>参看sentinel.conf</li></ul></li><li><p>启动哨兵 </p><pre><code class="hljs css"><span class="hljs-selector-tag">redis-sentinel</span> <span class="hljs-selector-tag">sentinel</span>端口号 <span class="hljs-selector-class">.conf</span></code></pre></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143413.png" srcset="/img/loading.gif" alt=""></p><h3 id="4、工作原理"><a href="#4、工作原理" class="headerlink" title="4、工作原理"></a>4、工作原理</h3><h4 id="监控阶段"><a href="#监控阶段" class="headerlink" title="监控阶段"></a>监控阶段</h4><ul><li>用于同步各个节点的状态信息 <ul><li>获取各个sentinel的状态（是否在线） </li></ul></li><li>获取master的状态 <ul><li>master属性 <ul><li>runid </li><li>role：master </li><li>各个slave的详细信息 </li></ul></li></ul></li><li>获取所有slave的状态（根据master中的slave信息） <ul><li>slave属性 <ul><li>runid </li><li>role：slave </li><li>master_host、master_port </li><li>offset</li><li>…</li></ul></li></ul></li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143539.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143602.png" srcset="/img/loading.gif" alt=""></p><h4 id="通知阶段"><a href="#通知阶段" class="headerlink" title="通知阶段"></a>通知阶段</h4><ul><li>各个哨兵将得到的信息相互同步（信息对称）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143614.png" srcset="/img/loading.gif" alt=""></p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><h5 id="确认master下线"><a href="#确认master下线" class="headerlink" title="确认master下线"></a>确认master下线</h5><ul><li>当某个哨兵发现主服务器挂掉了，会将master中的SentinelRedistance中的master改为<strong>SRI_S_DOWN</strong>（主观下线），并通知其他哨兵，告诉他们发现master挂掉了。</li><li>其他哨兵在接收到该哨兵发送的信息后，也会尝试去连接master，如果超过半数（配置文件中设置的）确认master挂掉后，会将master中的SentinelRedistance中的master改为<strong>SRI_O_DOWN</strong>（客观下线）</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143633.png" srcset="/img/loading.gif" alt=""></p><h5 id="推选哨兵进行处理"><a href="#推选哨兵进行处理" class="headerlink" title="推选哨兵进行处理"></a>推选哨兵进行处理</h5><ul><li>在确认master挂掉以后，会推选出一个哨兵来进行故障转移工作（由该哨兵来指定哪个slave来做新的master）。</li><li>筛选方式是哨兵互相发送消息，并且参与投票，票多者当选。</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143649.png" srcset="/img/loading.gif" alt=""></p><h5 id="具体处理"><a href="#具体处理" class="headerlink" title="具体处理"></a>具体处理</h5><ul><li>由推选出来的哨兵对当前的slave进行筛选，筛选条件有：<ul><li>服务器列表中挑选备选master </li><li>在线的 </li><li>响应慢的 </li><li>与原master断开时间久的 </li><li>优先原则 <ul><li>优先级 </li><li>offset </li><li>runid </li></ul></li><li>发送指令（ sentinel ） <ul><li>向新的master发送<strong>slaveof no one</strong>(断开与原master的连接)</li><li>向其他slave发送slaveof 新masterIP端口（让其他slave与新的master相连）</li></ul></li></ul></li></ul><h2 id="十、集群"><a href="#十、集群" class="headerlink" title="十、集群"></a>十、集群</h2><h3 id="1、简介-3"><a href="#1、简介-3" class="headerlink" title="1、简介"></a>1、简介</h3><h4 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h4><ul><li>集群就是使用网络将若干台计算机<strong>联通</strong>起来，并提供<strong>统一的管理方式</strong>，使其对外呈现单机的服务效果 </li></ul><h4 id="集群作用"><a href="#集群作用" class="headerlink" title="集群作用"></a>集群作用</h4><ul><li>分散单台服务器的访问压力，实现<strong>负载均衡</strong> </li><li>分散单台服务器的存储压力，实现<strong>可扩展性</strong> </li><li><strong>降低</strong>单台服务器宕机带来的<strong>业务灾难</strong> </li></ul><h3 id="2、Redis集群结构设计"><a href="#2、Redis集群结构设计" class="headerlink" title="2、Redis集群结构设计"></a>2、Redis集群结构设计</h3><h4 id="数据存储设计"><a href="#数据存储设计" class="headerlink" title="数据存储设计"></a>数据存储设计</h4><ul><li>通过算法设计，计算出key应该保存的位置 </li><li>将所有的存储空间计划切割成16384份，每台主机保存一部分 每份代表的是一个存储空间，不是一个key的保存空间</li><li>将key按照计算出的结果放到对应的存储空间 </li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143701.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143712.png" srcset="/img/loading.gif" alt=""></p><ul><li>增强可扩展性 ——槽</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143720.png" srcset="/img/loading.gif" alt=""></p><h4 id="集群内部通讯设计"><a href="#集群内部通讯设计" class="headerlink" title="集群内部通讯设计"></a>集群内部通讯设计</h4><ul><li>各个数据库互相连通，保存各个库中槽的编号数据</li><li>一次命中，直接返回</li><li>一次未命中，告知具体的位置，key再直接去找对应的库保存数据</li></ul><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143733.png" srcset="/img/loading.gif" alt=""></p><h2 id="十一、企业级解决方案"><a href="#十一、企业级解决方案" class="headerlink" title="十一、企业级解决方案"></a>十一、企业级解决方案</h2><h3 id="1、缓存预热"><a href="#1、缓存预热" class="headerlink" title="1、缓存预热"></a>1、缓存预热</h3><h4 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h4><ul><li>请求数量较高 </li><li>主从之间数据吞吐量较大，数据同步操作频度较高 </li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>前置准备工作： <ul><li>日常例行统计数据访问记录，统计访问频度较高的热点数据 </li><li>利用LRU数据删除策略，构建数据留存队列 例如：storm与kafka配合 </li></ul></li><li>准备工作： <ul><li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据 </li><li>利用分布式多服务器同时进行数据读取，提速数据加载过程 </li><li>热点数据主从同时预热 </li></ul></li><li>实施： <ul><li>使用脚本程序固定触发数据预热过程 </li><li>如果条件允许，使用了CDN（内容分发网络），效果会更好 </li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！ </p><h3 id="2、缓存雪崩"><a href="#2、缓存雪崩" class="headerlink" title="2、缓存雪崩"></a>2、缓存雪崩</h3><h4 id="数据库服务器崩溃（1）"><a href="#数据库服务器崩溃（1）" class="headerlink" title="数据库服务器崩溃（1）"></a>数据库服务器崩溃（1）</h4><ol><li>系统平稳运行过程中，忽然数据库连接量激增 </li><li>应用服务器无法及时处理请求 </li><li>大量408，500错误页面出现 </li><li>客户反复刷新页面获取数据 </li><li>数据库崩溃 </li><li>应用服务器崩溃 </li><li>重启应用服务器无效 </li><li>Redis服务器崩溃  </li><li>Redis集群崩溃 </li><li>重启数据库后再次被瞬间流量放倒 </li></ol><h4 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>在一个<strong>较短</strong>的时间内，缓存中较多的key<strong>集中过期</strong></li><li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据 </li><li>数据库同时接收到大量的请求无法及时处理 </li><li>Redis大量请求被积压，开始出现超时现象 </li><li>数据库流量激增，数据库崩溃 </li><li>重启后仍然面对缓存中无数据可用 </li><li>Redis服务器资源被严重占用，Redis服务器崩溃</li><li>Redis集群呈现崩塌，集群瓦解 </li><li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li><li>应用服务器，redis，数据库全部重启，效果不理想 </li></ol><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>短时间范围内</li><li>大量key集中过期 </li></ul><h4 id="解决方案（道）"><a href="#解决方案（道）" class="headerlink" title="解决方案（道）"></a>解决方案（道）</h4><ol><li>更多的页面静态化处理 </li><li>构建<strong>多级缓存架构</strong> Nginx缓存+redis缓存+ehcache缓存 </li><li>检测Mysql严重耗时业务进行优化 对数据库的瓶颈排查：例如超时查询、耗时较高事务等 </li><li>灾难预警机制 监控redis服务器性能指标 <ul><li>CPU占用、CPU使用率 </li><li>内存容量</li><li>查询平均响应时间 </li><li>线程数 </li></ul></li><li>限流、降级 短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问 </li></ol><p>解决方案（术） </p><ol><li>LRU与LFU切换 </li><li>数据有效期策略调整 <ul><li>根据业务数据有效期进行<strong>分类错峰</strong>，A类90分钟，B类80分钟，C类70分钟 </li><li>过期时间使用固定时间+随机值的形式，<strong>稀释</strong>集中到期的key的数量 </li></ul></li><li><strong>超热</strong>数据使用永久key</li><li>定期维护（自动+人工） 对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时 </li><li>加锁  <strong>慎用！</strong> </li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>缓存雪崩就是<strong>瞬间过期数据量太大</strong>，导致对数据库服务器造成压力。如能够<strong>有效避免过期时间集中</strong>，可以有效解决雪崩现象的出现 （约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。 </p><p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200608143749.png" srcset="/img/loading.gif" alt=""></p><h3 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a>3、缓存击穿</h3><h4 id="数据库服务器崩溃（2）"><a href="#数据库服务器崩溃（2）" class="headerlink" title="数据库服务器崩溃（2）"></a>数据库服务器崩溃（2）</h4><ol><li>系统平稳运行过程中 </li><li>数据库连接量<strong>瞬间激增</strong> </li><li>Redis服务器无大量key过期 </li><li>Redis内存平稳，无波动 </li><li>Redis服务器CPU正常</li><li><strong>数据库崩溃</strong> </li></ol><h4 id="问题排查-2"><a href="#问题排查-2" class="headerlink" title="问题排查"></a>问题排查</h4><ol><li>Redis中<strong>某个key过期，该key访问量巨大</strong> </li><li>多个数据请求从服务器直接压到Redis后，均未命中 </li><li>Redis在短时间内发起了大量对数据库中同一数据的访问 </li></ol><h4 id="问题分析-1"><a href="#问题分析-1" class="headerlink" title="问题分析"></a>问题分析</h4><ul><li>单个key高热数据</li><li>key过期 </li></ul><h4 id="解决方案（术）"><a href="#解决方案（术）" class="headerlink" title="解决方案（术）"></a>解决方案（术）</h4><ol><li><p>预先设定 </p><p>以电商为例，每个商家根据店铺等级，指定若干款主打商品，在购物节期间，<strong>加大</strong>此类信息key的<strong>过期时长</strong> </p><p>注意：购物节不仅仅指当天，以及后续若干天，访问峰值呈现逐渐降低的趋势</p></li><li><p>现场调整 </p><ul><li>监控访问量，对自然流量激增的数据延长过期时间或设置为永久性key </li></ul></li><li><p>后台刷新数据 </p><ul><li>启动定时任务，高峰期来临之前，刷新数据有效期，确保不丢失 </li></ul></li><li><p>二级缓存 </p><ul><li>设置不同的失效时间，保障不会被同时淘汰就行 </li></ul></li><li><p>加锁 分布式锁，防止被击穿，但是要注意也是性能瓶颈，<strong>慎重！</strong> </p></li></ol><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>缓存击穿就是<strong>单个高热数据过期的瞬间</strong>，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库问，导致对数据库服务器造成压力。应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略，毕竟单个key的过期监控难度较高，配合雪崩处理策略即可。 </p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
