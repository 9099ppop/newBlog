<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" type="image/png" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>集合源码 - Nyima&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Nyima</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/3.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-09-10 18:59">
      September 10, 2020 pm
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      102
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="集合源码"><a href="#集合源码" class="headerlink" title="集合源码"></a>集合源码</h1><p>工欲善其事必先利其器</p>
<p><a href="https://www.bilibili.com/video/BV1V7411U78L" target="_blank" rel="noopener"><strong>CodeSheep——Java源码盘起来！演示搭建JDK源码阅读环境，利用IDEA搭建Java源码阅读环境视频教程</strong></a></p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><h2 id="一、ArrayList底层数据结构"><a href="#一、ArrayList底层数据结构" class="headerlink" title="一、ArrayList底层数据结构"></a>一、ArrayList底层数据结构</h2><h3 id="1、ArrayList集合介绍"><a href="#1、ArrayList集合介绍" class="headerlink" title="1、ArrayList集合介绍"></a>1、ArrayList集合介绍</h3><p>ArrayList是<strong>List</strong>集合<strong>可变大小</strong>的数组的实现</p>
<h3 id="2、数组"><a href="#2、数组" class="headerlink" title="2、数组"></a>2、数组</h3><p>数组大小一旦确定，就无法改变</p>
<p><strong>增删慢</strong>：每次添加或删除元素，都需要更改数组长度、拷贝以及移动元素位置</p>
<p><strong>查询快</strong>：由于数组在内存中是一块连续空间，因此可以根据地址+索引的方式快速获取对应位置上的元素</p>
<h2 id="二、ArrayList继承关系"><a href="#二、ArrayList继承关系" class="headerlink" title="二、ArrayList继承关系"></a>二、ArrayList继承关系</h2><h3 id="1、Serializable标记性接口"><a href="#1、Serializable标记性接口" class="headerlink" title="1、Serializable标记性接口"></a>1、Serializable标记性接口</h3><p>此处可以查看<a href="https://www.bilibili.com/read/cv6257046" target="_blank" rel="noopener"><strong>CodeSheep——《序列化/反序列化，我忍你很久了！》</strong></a></p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><ul>
<li>类的序列化由实现<strong>java.io.Serializable</strong>接口的类启用</li>
<li>不实现此接口的类将不会使任何状态序列化或反序列化</li>
<li>可序列化类的所有子类型都是可序列化的</li>
<li>序列化接口没有方法或字段，仅<strong>用于标识可串行化的语义</strong></li>
</ul>
<p>序列化：将对象的数据写入到文件(写对象) </p>
<p>反序列化：将文件中对象的数据读取出来(读对象)</p>
<p>如果<strong>不想对某些变量进行序列化</strong>（如密码等），可以在前面加上 <strong>transient</strong> 关键字，表示该字段不想被序列化</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Serializable</span> </span>&#123;
&#125;</code></pre>



<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h4><p>Student类</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;
	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7515669154157983943L</span>;

	String name;
	<span class="hljs-keyword">int</span> age;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.name = name;
		<span class="hljs-keyword">this</span>.age = age;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> name;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.name = name;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> age;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.age = age;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">"Student&#123;"</span> +
				<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
				<span class="hljs-string">", age="</span> + age +
				<span class="hljs-string">'&#125;'</span>;
	&#125;
&#125;</code></pre>



<p>测试类</p>
<pre><code class="hljs java"><span class="hljs-comment">//不使用集合</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;
		write();
		read();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
		<span class="hljs-comment">//创建对象操作流，进行序列化操作</span>
		ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"student.txt"</span>));
		<span class="hljs-comment">//创建Student类的对象</span>
		Student student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Nyima"</span>, <span class="hljs-number">12</span>);
		<span class="hljs-comment">//调用操作流写对象的方法，将对象的数据写入文件中</span>
		objectOutputStream.writeObject(student);
		<span class="hljs-comment">//关闭输出流</span>
		objectOutputStream.close();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;
		ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"student.txt"</span>));

		Student student = (Student) objectInputStream.readObject();
		System.out.println(student);

		objectInputStream.close();
	&#125;
&#125;

<span class="hljs-comment">//使用集合</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;
		Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Chen"</span>, <span class="hljs-number">1</span>);
		Student student2 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Pan"</span>, <span class="hljs-number">1</span>);
		Student student3 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"Wen"</span>, <span class="hljs-number">1</span>);

		ArrayList&lt;Student&gt; lists = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
		lists.add(student1);
		lists.add(student2);
		lists.add(student3);

		ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"stu.txt"</span>));

        <span class="hljs-comment">//通过集合进行序列化</span>
		oos.writeObject(lists);

		oos.close();

		ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"stu.txt"</span>));

		lists = (ArrayList&lt;Student&gt;) ois.readObject();

		<span class="hljs-keyword">for</span>(Student student : lists) &#123;
			System.out.println(student);
		&#125;

		ois.close();
	&#125;
&#125;</code></pre>



<h3 id="2、Cloneable标记性接口"><a href="#2、Cloneable标记性接口" class="headerlink" title="2、Cloneable标记性接口"></a>2、Cloneable标记性接口</h3><p>此处可以查看<a href="https://www.bilibili.com/read/cv7349900" target="_blank" rel="noopener"><strong>CodeSheep——《一个工作三年的同事，居然还搞不清深拷贝/浅拷贝，被老大批了》</strong></a></p>
<h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>一个类<strong>实现 Cloneable 接口</strong>来指示 <strong>Object.clone()</strong> 方法，该方法对于该类的实例进行字段的复制是合法的。在不实现 Cloneable 接口的实例上调用对象的克隆方法会导致异常 CloneNotSupportedException 被抛出。</p>
<p>简言之：<strong>克隆就是依据已经有的数据，创造一份新的完全一样的数据拷贝</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cloneable</span> </span>&#123;
&#125;</code></pre>



<h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><ul>
<li><p>被克隆对象所在的类必须<strong>实现Cloneable接口</strong></p>
</li>
<li><p><strong>重写clone()方法</strong></p>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>基本使用</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
		list.add(<span class="hljs-string">"Hello"</span>);
		list.add(<span class="hljs-string">"World"</span>);

		Object o = list.clone();

		System.out.println(o == list);
		System.out.println(list.toString());
		System.out.println(o.toString());
	&#125;
&#125;</code></pre>

<p><strong>运行结果</strong></p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200908194627.png" srcset="/img/loading.gif" alt=""></p>
<h4 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h4><p>在调用clone方法的地方打上断点</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200908195654.png" srcset="/img/loading.gif" alt=""></p>
<p>ArrayList实现clone()方法<strong>源码解析</strong></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">//此处调用了Object的clone()方法</span>
            <span class="hljs-comment">//Object的clone()方法，此处调用了本地方法(native)</span>
            <span class="hljs-comment">//protected native Object clone() throws CloneNotSupportedException;</span>
            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();
            
            <span class="hljs-comment">//elementData先保存了我们被复制的集合的数据，其中elementData对象为无法被序列化的Object类型的数组</span>
            <span class="hljs-comment">//size为被复制数组的大小</span>
            <span class="hljs-comment">//transient Object[] elementData; </span>
            <span class="hljs-comment">//然后调用Arrays类的copyOf方法给elementData对象赋值</span>
            <span class="hljs-comment">//copyOf()方法的调用见下面</span>
            v.elementData = Arrays.copyOf(elementData, size);
            
            <span class="hljs-comment">//用于记录此列表被记录修改的次数</span>
            v.modCount = <span class="hljs-number">0</span>;
            
            <span class="hljs-comment">//返回拷贝对象</span>
            <span class="hljs-keyword">return</span> v;
        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;
            <span class="hljs-comment">// this shouldn't happen, since we are Cloneable</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);
        &#125;
&#125;


<span class="hljs-comment">//copyOf()方法</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="hljs-keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;
        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
    	<span class="hljs-comment">//创建一个和原集合相同大小的集合copy</span>
        T[] copy = ((Object)newType == (Object)Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
            ? (T[]) new Object[newLength]
            : (T[]) Array.newInstance(newType.getComponentType(), newLength);
    	<span class="hljs-comment">//调用System的arraycopy方法进行复制</span>
        System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,
                         Math.min(original.length, newLength));
    	<span class="hljs-comment">//返回copy集合</span>
        <span class="hljs-keyword">return</span> copy;
&#125;</code></pre>

<p><strong>图解</strong></p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200908201550.png" srcset="/img/loading.gif" alt=""></p>
<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;

		Skill skill = <span class="hljs-keyword">new</span> Skill(<span class="hljs-string">"Foot Attack"</span>);
		Hero hero1 = <span class="hljs-keyword">new</span> Hero(<span class="hljs-string">"LiQing"</span>, <span class="hljs-number">25</span>, skill);

		<span class="hljs-comment">//调用hero1对象的克隆方法</span>
		Hero hero2 = hero1.clone();

		<span class="hljs-comment">//打印结果</span>
		System.out.println(hero1 == hero2);
		System.out.println(hero1);
		System.out.println(hero2);

		<span class="hljs-comment">//更改hero2的年龄和技能</span>
		hero2.setName(<span class="hljs-string">"Kasa"</span>);
		skill.setSkillName(<span class="hljs-string">"Fly in the Sky"</span>);
       	hero2.setSkill(skill);

		<span class="hljs-comment">//打印结果</span>
		System.out.println(hero1 == hero2);
		System.out.println(hero1);
		System.out.println(hero2);
	&#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;
	String name;
	<span class="hljs-keyword">int</span> age;
    <span class="hljs-comment">//技能类</span>
	Skill skill;

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 *</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> 克隆后的对象</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@throws</span> CloneNotSupportedException</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> Hero <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
		<span class="hljs-keyword">return</span> (Hero) <span class="hljs-keyword">super</span>.clone();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hero</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, Skill skill)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.name = name;
		<span class="hljs-keyword">this</span>.age = age;
		<span class="hljs-keyword">this</span>.skill = skill;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> name;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.name = name;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> age;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.age = age;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> Skill <span class="hljs-title">getSkill</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> skill;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkill</span><span class="hljs-params">(Skill skill)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.skill = skill;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">"Hero&#123;"</span> +
				<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
				<span class="hljs-string">", age='"</span> + age + <span class="hljs-string">'\''</span> +
				<span class="hljs-string">", skill="</span> + skill +
				<span class="hljs-string">'&#125;'</span>;
	&#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Skill</span> </span>&#123;
	String skillName;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Skill</span><span class="hljs-params">(String skillName)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.skillName = skillName;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSkillName</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> skillName;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkillName</span><span class="hljs-params">(String skillName)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.skillName = skillName;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">"Skill&#123;"</span> +
				<span class="hljs-string">"skillName='"</span> + skillName + <span class="hljs-string">'\''</span> +
				<span class="hljs-string">'&#125;'</span>;
	&#125;
&#125;</code></pre>

<p><strong>运行结果</strong></p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909140608.png" srcset="/img/loading.gif" alt=""></p>
<p>说明：</p>
<p>创建了一个Hero对象hero1，然后通过其clone()方法克隆了一个hero2对象。然后<strong>我们修改hero2对象的姓名和技能</strong>，其中技能是Skill类构成的。修改后发现。hero1的name没有收到波及，但是<strong>hero1的Skill被改变了</strong></p>
<p>这就是浅拷贝存在的问题：<strong>基本数据类型可以达到完全复制，引用数据类型则不可以</strong>。这是因为在hero1被克隆的时候，其属性skill(引用数据类型)<strong>仅仅是拷贝了一份引用</strong>，因此当skill的值发生改 变时，被克隆对象hero1的属性skill也将跟随改变</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo4</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;

		Skill skill = <span class="hljs-keyword">new</span> Skill(<span class="hljs-string">"Foot Attack"</span>);
		Hero hero1 = <span class="hljs-keyword">new</span> Hero(<span class="hljs-string">"LiQing"</span>, <span class="hljs-number">25</span>, skill);

		<span class="hljs-comment">//调用hero1对象的克隆方法</span>
		Hero hero2 = hero1.clone();

		<span class="hljs-comment">//打印结果</span>
		System.out.println(hero1 == hero2);
		System.out.println(hero1);
		System.out.println(hero2);

		<span class="hljs-comment">//更改hero2的年龄和技能</span>
		hero2.setName(<span class="hljs-string">"Kasa"</span>);
		skill.setSkillName(<span class="hljs-string">"Fly in the Sky"</span>);
		hero2.setSkill(skill);

		<span class="hljs-comment">//打印结果</span>
		System.out.println(hero1 == hero2);
		System.out.println(hero1);
		System.out.println(hero2);
	&#125;
&#125;


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;
	String name;
	<span class="hljs-keyword">int</span> age;
	Skill skill;

	<span class="hljs-comment">/**</span>
<span class="hljs-comment">	 *</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> 克隆后的对象</span>
<span class="hljs-comment">	 * <span class="hljs-doctag">@throws</span> CloneNotSupportedException</span>
<span class="hljs-comment">	 */</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> Hero <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
		<span class="hljs-comment">//克隆个英雄对象</span>
		Hero hero =  (Hero) <span class="hljs-keyword">super</span>.clone();
		
		<span class="hljs-comment">//调用Skill的clone()方法，克隆出一个skill对象，并赋值给Hero对象</span>
		<span class="hljs-keyword">this</span>.skill = <span class="hljs-keyword">this</span>.skill.clone();
	
		<span class="hljs-keyword">return</span> hero;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hero</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age, Skill skill)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.name = name;
		<span class="hljs-keyword">this</span>.age = age;
		<span class="hljs-keyword">this</span>.skill = skill;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> name;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.name = name;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> age;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.age = age;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> Skill <span class="hljs-title">getSkill</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> skill;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkill</span><span class="hljs-params">(Skill skill)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.skill = skill;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">"Hero&#123;"</span> +
				<span class="hljs-string">"name='"</span> + name + <span class="hljs-string">'\''</span> +
				<span class="hljs-string">", age='"</span> + age + <span class="hljs-string">'\''</span> +
				<span class="hljs-string">", skill="</span> + skill +
				<span class="hljs-string">'&#125;'</span>;
	&#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Skill</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span></span>&#123;
	String skillName;

	<span class="hljs-comment">//重写克隆方法</span>
	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">protected</span> Skill <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;
		<span class="hljs-keyword">return</span> (Skill)<span class="hljs-keyword">super</span>.clone();
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Skill</span><span class="hljs-params">(String skillName)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.skillName = skillName;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSkillName</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> skillName;
	&#125;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSkillName</span><span class="hljs-params">(String skillName)</span> </span>&#123;
		<span class="hljs-keyword">this</span>.skillName = skillName;
	&#125;

	<span class="hljs-meta">@Override</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
		<span class="hljs-keyword">return</span> <span class="hljs-string">"Skill&#123;"</span> +
				<span class="hljs-string">"skillName='"</span> + skillName + <span class="hljs-string">'\''</span> +
				<span class="hljs-string">'&#125;'</span>;
	&#125;
&#125;</code></pre>

<p><strong>运行结果</strong></p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909143253.png" srcset="/img/loading.gif" alt=""></p>
<p>深拷贝与浅拷贝的不同是：若被拷贝对象中引用了其他类，<strong>被引用类也需要实现Cloneable接口，并重写clone()方法</strong></p>
<p>同时被拷贝对象的clone()方法<strong>不能只是调用父类的clone()方法，需要重写</strong>，规则如下</p>
<ul>
<li><p>先调用父类的clone()方法，克隆出一个被拷贝对象</p>
<pre><code class="hljs java">Hreo hero = (Hero)<span class="hljs-keyword">super</span>.clone();</code></pre>
</li>
<li><p>调用被引用类的clone()方法，克隆出一个被引用对象</p>
<pre><code class="hljs java">Skill skill = (Skill) <span class="hljs-keyword">this</span>.skill.clone()</code></pre>
</li>
<li><p>将克隆的<strong>被引用</strong>对象赋值给<strong>被拷贝</strong>对象</p>
<pre><code class="hljs ini"><span class="hljs-attr">this.skill</span> = skill<span class="hljs-comment">;</span></code></pre>



</li>
</ul>
<h3 id="3、-RandomAccess标记性接口"><a href="#3、-RandomAccess标记性接口" class="headerlink" title="3、 RandomAccess标记性接口"></a>3、 RandomAccess标记性接口</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>标记接口由 <strong>List</strong> 实现使用，以表明它们<strong>支持快速（通常为恒定时间）随机访问</strong></p>
<p>此接口的主要目的是<strong>允许通用算法更改其行为</strong>，以便在应用于随机访问列表或顺序访问列表时提供良好的性能</p>
<h4 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong>实现了RandomAccess接口，随机访问速度比顺序访问更快</strong></p>
<p>注意ArrayList<strong>底层为数组</strong>，所以随机访问的效率高。RandomAccess接口<strong>只是用来标识其是否支持随机访问</strong>，而<strong>不是实现了该接口就能使随机访问效率更高</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">//使用ArrayList</span>
		ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
		<span class="hljs-comment">//向list中添加十万条数据</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;
			list.add(<span class="hljs-string">"a"</span>);
		&#125;

		<span class="hljs-comment">//随机访问，并计算访问用时</span>
		<span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;
			list.get(i);
		&#125;

		<span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();
		System.out.println(<span class="hljs-string">"随机访问时间："</span> + (endTime - startTime));

		<span class="hljs-comment">//顺序访问</span>
		startTime = System.currentTimeMillis();
		<span class="hljs-keyword">for</span>(Iterator iterator = list.iterator(); iterator.hasNext();) &#123;
			iterator.next();
		&#125;

		endTime = System.currentTimeMillis();
		System.out.println(<span class="hljs-string">"顺序访问时间："</span> + (endTime - startTime));

	&#125;
&#125;</code></pre>

<p><strong>运行结果</strong></p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909151646.png" srcset="/img/loading.gif" alt=""></p>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedLis随机访问比顺序访问更慢</strong>。因为LinkedList底层为链表，随机访问效率低，所以没有实现RandomAccess接口。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;</span>
<span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;</span>
<span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></code></pre>

<p><strong>代码</strong></p>
<pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Demo2 &#123;
	public static void main(String<span class="hljs-literal">[]</span> args) &#123;
		<span class="hljs-comment">//使用LinkedList</span>
		LinkedList&lt;String&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;<span class="hljs-literal">()</span>;
		<span class="hljs-comment">//向list中添加十万条数据</span>
		for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;
			<span class="hljs-built_in">list</span>.add(<span class="hljs-string">"a"</span>);
		&#125;

		<span class="hljs-comment">//随机访问，并计算访问用时</span>
		long startTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;
		for (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;
			<span class="hljs-built_in">list</span>.get(i);
		&#125;

		long endTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;
		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"随机访问时间："</span> + (endTime - startTime));

		<span class="hljs-comment">//顺序访问</span>
		startTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;
		for (Iterator iterator = <span class="hljs-built_in">list</span>.iterator<span class="hljs-literal">()</span>; iterator.has<span class="hljs-constructor">Next()</span>; ) &#123;
			iterator.next<span class="hljs-literal">()</span>;
		&#125;

		endTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;
		<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"顺序访问时间："</span> + (endTime - startTime));

	&#125;
&#125;</code></pre>

<p><strong>运行结果</strong></p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200909151730.png" srcset="/img/loading.gif" alt=""></p>
<p><strong>为什么LinkedList随机访问的效率这么低呢</strong></p>
<ul>
<li><p>随机访问的时候源码底层<strong>每次都需要进行折半的动作</strong>，再经过判断是从头还是从尾部一个个寻找</p>
</li>
<li><p>顺序访问只会在获取迭代器的时候<strong>进行一次折半的动作</strong>，以后每次都是在上一次的基础上获取下一个元素</p>
<p>因此顺序访问要比随机访问快得多</p>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>遍历集合前使用 <strong>instanceof</strong> 关键字来判断集合<strong>是否实现了 RandomAccess 接口</strong></p>
<ul>
<li>如果实现了，就使用随机访问</li>
<li>如果没实现，就使用顺序访问</li>
</ul>
<p><strong>代码</strong></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		<span class="hljs-comment">//链表</span>
		LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();
		<span class="hljs-comment">//数组</span>
		ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

		<span class="hljs-comment">//向集合中添加十万条数据</span>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;
			arrayList.add(<span class="hljs-string">"a"</span>);
			linkedList.add(<span class="hljs-string">"b"</span>);
		&#125;

		<span class="hljs-comment">//通过判断集合是否实现了RandomAccess接口，来选择适当的遍历方法</span>
		<span class="hljs-keyword">if</span> (arrayList <span class="hljs-keyword">instanceof</span> RandomAccess) &#123;
			System.out.println(<span class="hljs-string">"随机访问"</span>);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;
				arrayList.get(i);
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			System.out.println(<span class="hljs-string">"顺序访问"</span>);
			<span class="hljs-comment">//实现了迭代器的集合，foreach会使用迭代器</span>
			<span class="hljs-keyword">for</span> (String s : arrayList) &#123;
				<span class="hljs-comment">//取出元素，不做任何操作</span>
			&#125;
		&#125;

		<span class="hljs-keyword">if</span> (linkedList <span class="hljs-keyword">instanceof</span> RandomAccess) &#123;
			System.out.println(<span class="hljs-string">"随机访问"</span>);
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; linkedList.size(); i++) &#123;
				linkedList.get(i);
			&#125;
		&#125; <span class="hljs-keyword">else</span> &#123;
			System.out.println(<span class="hljs-string">"顺序访问"</span>);
			<span class="hljs-comment">//实现了迭代器的集合，foreach会使用迭代器</span>
			<span class="hljs-keyword">for</span> (String s : linkedList) &#123;
				<span class="hljs-comment">//取出元素，不做任何操作</span>
			&#125;
		&#125;

	&#125;
&#125;</code></pre>



<h3 id="4、AbstractList抽象类"><a href="#4、AbstractList抽象类" class="headerlink" title="4、AbstractList抽象类"></a>4、AbstractList抽象类</h3><p>该抽象类含有一个空构造方法，以及一些需要子类去实现的抽象方法</p>
<h2 id="三、ArrayList源码分析"><a href="#三、ArrayList源码分析" class="headerlink" title="三、ArrayList源码分析"></a>三、ArrayList源码分析</h2><h3 id="1、构造方法"><a href="#1、构造方法" class="headerlink" title="1、构造方法"></a>1、构造方法</h3><h4 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span> </span>&#123;
    <span class="hljs-comment">//默认的初始化容量</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;

    
    <span class="hljs-comment">//默认的Object类型的空数组</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;
    
    <span class="hljs-comment">//不可序列化的Object类型数组，用于存储ArrayList元素的数组</span>
    <span class="hljs-keyword">transient</span> Object[] elementData;
    
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">//如果没有指定集合的大小，当第一次向集合中添加元素时，集合容量会扩充为10</span>
        <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    &#125;
&#125;</code></pre>

<p>无参构造函数没有指定集合的大小，所以当<strong>第一次向集合中添加元素的时候，集合的容量会扩充为10</strong></p>
<h4 id="initialCapacity构造方法"><a href="#initialCapacity构造方法" class="headerlink" title="initialCapacity构造方法"></a>initialCapacity构造方法</h4><pre><code class="hljs java"><span class="hljs-comment">//空的Objcet类型数组，区别于DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;
		<span class="hljs-comment">//如果容量大于0</span>
        <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;
        	<span class="hljs-comment">//根据传入的容量大小创建Objcet类型的数组，赋值给elementData</span>
            <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;
        	<span class="hljs-comment">//如果容量等于0，就将elementData赋值为一个Object类型的空数组</span>
            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;
        &#125; <span class="hljs-keyword">else</span> &#123;
        	<span class="hljs-comment">//如果容量小于0，就抛出异常</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+
                                               initialCapacity);
        &#125;
&#125;</code></pre>

<p>initialCapacity构造函数会根据传入的容量大小来创建满足要求的集合</p>
<h4 id="Collection构造方法"><a href="#Collection构造方法" class="headerlink" title="Collection构造方法"></a>Collection构造方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;
    	<span class="hljs-comment">// 将传入的集合转成数组</span>
        elementData = c.toArray();
    	
    	<span class="hljs-comment">//判断传入集合的大小是否为0</span>
        <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;
            <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>
            <span class="hljs-comment">// 存在一个bug，c.toArray方法的返回值可能不是一个Object类型的数组</span>
            <span class="hljs-comment">// 如果elementData的类型不是一个Object类型的数组</span>
            <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class">                // 就再次进行拷贝操作</span>
<span class="hljs-class">                <span class="hljs-title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// replace with empty array.</span>
            <span class="hljs-comment">// 如果传入集合的大小为0，就赋值为一个空数组</span>
            <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;
        &#125;
&#125;

<span class="hljs-comment">// toArray方法</span>
<span class="hljs-keyword">public</span> Object[] toArray() &#123;
    	<span class="hljs-comment">// 调用了copyOf方法</span>
        <span class="hljs-keyword">return</span> Arrays.copyOf(elementData, size);
&#125;

<span class="hljs-comment">// copyOf方法</span>
 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="hljs-keyword">int</span> newLength) &#123;
     	调用了重载后的copyOf方法，对集合进行拷贝操作
        <span class="hljs-keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());
&#125;</code></pre>

<p>Collection构造方法主要是将传入的集合转变为数组类型。在转换后根据elementData的大小再次对elementData进行了赋值操作</p>
<ul>
<li>当size != 0时，要判断 c.toArray() 所返回的结果是不是Objcet类型的数组，如果不是，则还需要elementData该为Object数组</li>
<li>当size == 0时，将其赋值为一个空数组</li>
</ul>
<h3 id="2、添加方法"><a href="#2、添加方法" class="headerlink" title="2、添加方法"></a>2、添加方法</h3><h4 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e)方法"></a>add(E e)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        <span class="hljs-comment">// 向集合中添加一个元素时，会调用add(E e)方法</span>
		list.add(<span class="hljs-string">"Nyima"</span>);
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;
    	<span class="hljs-comment">// 传入需要扩容的最小容量，值为元素个数+1</span>
        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>
    	<span class="hljs-comment">// 扩容后，放入要添加的元素</span>
        elementData[size++] = e;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
&#125;


<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;
    	<span class="hljs-comment">// 调用calculateCapacity方法，计算最小容量</span>
        <span class="hljs-comment">//然后再调用ensureExplicitCapacity方法，来增加数组被修改次数modCount，以及查看是否真正需要扩容</span>
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">calculateCapacity</span><span class="hljs-params">(Object[] elementData, <span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;
    	<span class="hljs-comment">// 如果集合是DEFAULTCAPACITY_EMPTY_ELEMENTDATA，也就是创建集合时没有传入容量大小，并且是第一次进行添加操作</span>
        <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;
            <span class="hljs-comment">// 返回默认容量10，和最小容量的较大者</span>
            <span class="hljs-keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);
        &#125;
    	<span class="hljs-comment">// 返回最小容量</span>
        <span class="hljs-keyword">return</span> minCapacity;
&#125;

 <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;
     	<span class="hljs-comment">// 增加modCount++</span>
        <span class="hljs-comment">// modCount用于保存集合被修改的次数</span>
        modCount++;

        <span class="hljs-comment">// overflow-conscious code</span>
     	<span class="hljs-comment">// 如果容量不够，才扩容</span>
        <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)
            <span class="hljs-comment">// 真正的扩容操作</span>
            grow(minCapacity);
&#125;

<span class="hljs-comment">// 真正的扩容操作</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;
        <span class="hljs-comment">// overflow-conscious code</span>
    	<span class="hljs-comment">// 保存扩容前数组的容量</span>
        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;
    
    	<span class="hljs-comment">// 得到扩容后数组的容量，扩大为原容量的1.5倍数</span>
    	<span class="hljs-comment">// 右移 &gt;&gt; : 右移多少位就是除以2的多少次幂，这里是除以2</span>
    	<span class="hljs-comment">// 左移 &lt;&lt; : 左移多少位就是乘以2的多少次幂</span>
        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);
    
    	<span class="hljs-comment">// 如果扩容1.5倍后的容量小于最小容量</span>
        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)
            <span class="hljs-comment">// 就按照最小容量进行扩容（选取较大的扩容方式）</span>
            newCapacity = minCapacity;
    
    	<span class="hljs-comment">// 如果新容量大于数组的最大容量</span>
        <span class="hljs-comment">// private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)
            <span class="hljs-comment">//就将其令为最大容量</span>
            newCapacity = hugeCapacity(minCapacity);
    
        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span>
    	<span class="hljs-comment">// 将数组根据newCapacity扩容，并将其原来的元素放入到elementData中</span>
        elementData = Arrays.copyOf(elementData, newCapacity);
&#125;

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OutOfMemoryError();
        <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?
            Integer.MAX_VALUE :
            MAX_ARRAY_SIZE;
&#125;</code></pre>

<p><strong>总结</strong></p>
<ul>
<li>向集合中添加元素时，先进行容量检测，在进行添加操作</li>
<li>容量检测操作如下<ul>
<li>最小扩容容量为<strong>当前数组元素个数+1</strong></li>
<li>判断当前数组是否为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，也就是调用了无参构造函数来创建集合<ul>
<li>如果是，最小容量就变为DEFAULT_CAPACITY(10)和最小容量的较大者</li>
<li>如果不是，就返回较小容量</li>
</ul>
</li>
<li>返回得到的最小扩容容量</li>
</ul>
</li>
<li>然后调用方法，<strong>增加集合被修改的次数</strong>（modCount++），然后<strong>再次确定最小扩容容量是否大于数组当前的大小</strong>（也就是放入元素后会不会大于数组的当前长度，<strong>容量不足</strong>），如果满足，则调用<strong>最重要的grow方法</strong>进行数组的扩容，方法执行的操作如下<ul>
<li>用变量<strong>oldCapacity</strong>保存扩容前数组的大小（<strong>数组中元素的个数</strong>）</li>
<li>进行扩容，<strong>扩容大小为原容量的1.5倍</strong>（右移一位，表示除以2）</li>
<li>查看扩容后的容量是否小于最小扩容容量（如果原容量为0，如初始化了集合大小，newCapaticy就还是0，所以需要比较）<ul>
<li>如果是，就以最小扩容容量来进行扩容</li>
<li>如果不是，就扩大为原容量的1.5倍</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>补充：</strong>集合在被操作的时候，都会增加modCount的值，那么这个值到底有什么用呢？</p>
<p>在使用迭代器进行迭代时会用到这个变量。<strong>这个变量是用来保证线程的安全性的</strong>。如果在进行迭代的时候，发现modCount的值被修改了，那么就会抛出ConcurrentModificationException</p>
<p><strong>后面分析迭代器时，还会具体分析modCount</strong></p>
<h4 id="add-int-index-E-element-方法"><a href="#add-int-index-E-element-方法" class="headerlink" title="add(int index, E element)方法"></a>add(int index, E element)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);
		list.add(<span class="hljs-string">"Nyima1"</span>);
		list.add(<span class="hljs-string">"Nyima2"</span>);
		list.add(<span class="hljs-string">"Nyima3"</span>);
		<span class="hljs-comment">//向指定位置插入元素</span>
		list.add(<span class="hljs-number">1</span>, <span class="hljs-string">"Nyima4"</span>);
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;
    	<span class="hljs-comment">// 判断插入的位置是否合法</span>
        rangeCheckForAdd(index);

    	<span class="hljs-comment">// 对数组容量进行检查，查看是否需要进行扩容，并增加数组被修改的次数modCount</span>
        ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span>
    
    	<span class="hljs-comment">/**</span>
<span class="hljs-comment">        * 进行拷贝操作，将插入位置及其后面的所有元素后移一位</span>
<span class="hljs-comment">    	* <span class="hljs-doctag">@param</span>      src      the source array.</span>
<span class="hljs-comment">        * <span class="hljs-doctag">@param</span>      srcPos   starting position in the source array.</span>
<span class="hljs-comment">     	* <span class="hljs-doctag">@param</span>      dest     the destination array.</span>
<span class="hljs-comment">     	* <span class="hljs-doctag">@param</span>      destPos  starting position in the destination data.</span>
<span class="hljs-comment">        * <span class="hljs-doctag">@param</span>      length   the number of array elements to be copied.</span>
<span class="hljs-comment">        */</span>
        System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,
                         size - index);
    
    	<span class="hljs-comment">// 在目标位置插入该元素</span>
        elementData[index] = element;
    	<span class="hljs-comment">// 集合容量加1</span>
        size++;
&#125;


<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
    	<span class="hljs-comment">// 如果插入位置超出了数组的范围，就抛出异常</span>
        <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));
&#125;</code></pre>



<h4 id="addAll-Collection-lt-extends-E-gt-c-方法"><a href="#addAll-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)方法"></a>addAll(Collection&lt;? extends E&gt; c)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);
		ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

		list.add(<span class="hljs-string">"Nyima1"</span>);
		list.add(<span class="hljs-string">"Nyima2"</span>);
		list.add(<span class="hljs-string">"Nyima3"</span>);
        
        <span class="hljs-comment">// 此处调用了addAll方法，将list集合中的所有元素插入到list2集合的末尾</span>
		list2.addAll(list);
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;
    	<span class="hljs-comment">// 将要插入的集合转为Object类型的数组</span>
        Object[] a = c.toArray();
    
    	<span class="hljs-comment">// 得到插入数组的长度</span>
        <span class="hljs-keyword">int</span> numNew = a.length;
    
    	<span class="hljs-comment">// 增加modCount并根据需求进行扩容</span>
        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>
    
    	<span class="hljs-comment">// 调用数组拷贝的方法，将数组a中的所有元素添加到elementData数组的末尾</span>
        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, size, numNew);
    
    	<span class="hljs-comment">// 数组的大小增加，增加大小为被拷贝集合的大小</span>
        size += numNew;
    
    	<span class="hljs-comment">// 返回是否添加成功。如果被添加集合是一个空数组，则添加失败</span>
        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;
&#125;</code></pre>



<h4 id="addAll-int-index-Collection-lt-extends-E-gt-c-方法"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c-方法" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)方法"></a>addAll(int index, Collection&lt;? extends E&gt; c)方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">1</span>);
		ArrayList&lt;String&gt; list2 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
		ArrayList&lt;String&gt; list3 = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

		list.add(<span class="hljs-string">"Nyima1"</span>);
		list.add(<span class="hljs-string">"Nyima2"</span>);
		list.add(<span class="hljs-string">"Nyima3"</span>);

		list2.add(<span class="hljs-string">"Nyima4"</span>);
		list2.add(<span class="hljs-string">"Nyima5"</span>);
	
        <span class="hljs-comment">// 在指定位置插入所有集合</span>
		list2.addAll(<span class="hljs-number">1</span>, list);
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;
    	<span class="hljs-comment">// 进行边界检查，如果超出集合范围，则会抛出异常</span>
        rangeCheckForAdd(index);
		
    	<span class="hljs-comment">// 将要插入的集合转为Object类型的数组</span>
        Object[] a = c.toArray();
    	
    	<span class="hljs-comment">// 得到插入数组的长度</span>
        <span class="hljs-keyword">int</span> numNew = a.length;
       
    	<span class="hljs-comment">// 根据需求进行扩容操作</span>
        ensureCapacityInternal(size + numNew);  <span class="hljs-comment">// Increments modCount</span>
		
    	<span class="hljs-comment">// 计算需要移动的步数</span>
        <span class="hljs-keyword">int</span> numMoved = size - index;
    
    	<span class="hljs-comment">// 如果需要移动的步数大于0， 则进行移动操作</span>
        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)
            <span class="hljs-comment">// 先将被插入数组中在index之后的元素向后移动</span>
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
		
    	<span class="hljs-comment">// 在指定位置插入数组</span>
        System.arraycopy(a, <span class="hljs-number">0</span>, elementData, index, numNew);
    
    	<span class="hljs-comment">// 增加size的大小</span>
        size += numNew;
    
    	<span class="hljs-comment">// 返回是否插入成功</span>
        <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;
&#125;</code></pre>

<p>这里的插入操作和 add(int index, E element) 方法有一些类似。边界判断、集合转数组、数组扩容等。并且<strong>在移动被插入数组中的元素时，都用到了 System.arraycopy() 方法</strong>。只不过 add(int index, E element) 只用插入一个元素，所以直接插入就可以了。而 a<strong>ddAll(int index, Collection&lt;? extends E&gt; c) 方法</strong>因为需要插入多个元素，所以<strong>再次用到了 System.arraycopy()  方法</strong>，来进行多个元素的插入操作</p>
<h3 id="3、移除方法"><a href="#3、移除方法" class="headerlink" title="3、移除方法"></a>3、移除方法</h3><h4 id="remove-int-index-方法"><a href="#remove-int-index-方法" class="headerlink" title="remove(int index)方法"></a>remove(int index)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        <span class="hljs-comment">// 判断是否越界</span>
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);
		
    	<span class="hljs-comment">// 需要移动的元素个数</span>
        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;
    	
    	<span class="hljs-comment">// 从index+1开始，后面的元素全部前移1位</span>
        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)
            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,
                             numMoved);
    
    	<span class="hljs-comment">// 让最后一个元素置空，让GC来清楚它</span>
        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>
		
    	<span class="hljs-comment">// 返回被移除的元素</span>
        <span class="hljs-keyword">return</span> oldValue;
&#125;</code></pre>



<h4 id="remove-Object-o-方法"><a href="#remove-Object-o-方法" class="headerlink" title="remove(Object o)方法"></a>remove(Object o)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;
    <span class="hljs-comment">// 被移除的元素为空</span>
    <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)
            <span class="hljs-comment">// 移除为空的元素</span>
            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;
                fastRemove(index);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)
            <span class="hljs-comment">// 移除指定的元素</span>
            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;
                <span class="hljs-comment">// 每次删除一个元素</span>
                fastRemove(index);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            &#125;
    &#125;
    <span class="hljs-comment">// 移除失败</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
&#125;

<span class="hljs-comment">// 这个方法和remove(int index)方法有些类似，只不过不用返回被删除的元素</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        modCount++;
        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)
            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,
                             numMoved);
    
    	<span class="hljs-comment">// 让最后一个元素置空，让GC来清楚它</span>
        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>
&#125;</code></pre>





<h3 id="4、set-get方法"><a href="#4、set-get方法" class="headerlink" title="4、set/get方法"></a>4、set/get方法</h3><h4 id="set-int-index-E-element-方法"><a href="#set-int-index-E-element-方法" class="headerlink" title="set(int index, E element)方法"></a>set(int index, E element)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;
    	<span class="hljs-comment">// 判断索引是否越界</span>
        rangeCheck(index);
		
    	<span class="hljs-comment">// 用oldValue保存数组中index位置上的元素</span>
        E oldValue = elementData(index);
    
    	<span class="hljs-comment">// 将要插入的元素插入到数组的index位置上</span>
        elementData[index] = element;
    
    	<span class="hljs-comment">// 返回index原来位置上的元素</span>
        <span class="hljs-keyword">return</span> oldValue;
&#125;</code></pre>

<p>set方法在改变数组中指定位置的元素时，<strong>会返回被覆盖的元素</strong></p>
<h4 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index)方法"></a>get(int index)方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
    	<span class="hljs-comment">// 判断索引是否越界</span>
        rangeCheck(index);
 
    	<span class="hljs-comment">// 返回数组中index位置上的元素</span>
        <span class="hljs-keyword">return</span> elementData(index);
&#125;</code></pre>



<h3 id="5、转化方法"><a href="#5、转化方法" class="headerlink" title="5、转化方法"></a>5、转化方法</h3><h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h4><p>ArrayList 的 toString 方法调用的是其祖宗类 AbstractCollection 的toString 方法</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910150556.png" srcset="/img/loading.gif" alt=""></p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Collection</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 获取迭代器</span>
        Iterator&lt;E&gt; it = iterator();
        <span class="hljs-comment">// 如果迭代器为空，就返回"[]"</span>
        <span class="hljs-keyword">if</span> (! it.hasNext())
            <span class="hljs-keyword">return</span> <span class="hljs-string">"[]"</span>;
	
        <span class="hljs-comment">// 使用StringBuilder来进行字符串的拼接</span>
        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
        sb.append(<span class="hljs-string">'['</span>);
        <span class="hljs-keyword">for</span> (;;) &#123;
            <span class="hljs-comment">// 获取一个元素</span>
            E e = it.next();
            
            <span class="hljs-comment">// 进行拼接操作</span>
            sb.append(e == <span class="hljs-keyword">this</span> ? <span class="hljs-string">"(this Collection)"</span> : e);
            
            <span class="hljs-comment">// 看是否还有下一个元素</span>
            <span class="hljs-keyword">if</span> (! it.hasNext())
                <span class="hljs-comment">// 如果没有，就加上']'，并调用toStrng方法转化为String类型</span>
                <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">']'</span>).toString();
            
            <span class="hljs-comment">// 如果还有下一个元素，就加上 ", " 进行分割</span>
            sb.append(<span class="hljs-string">','</span>).append(<span class="hljs-string">' '</span>);
        &#125;
    &#125;
&#125;</code></pre>



<h3 id="6、迭代器"><a href="#6、迭代器" class="headerlink" title="6、迭代器"></a>6、迭代器</h3><h4 id="iterator-普通迭代器"><a href="#iterator-普通迭代器" class="headerlink" title="iterator()普通迭代器"></a>iterator()普通迭代器</h4><p><strong>案例一</strong>：使用迭代器<strong>遍历</strong>获取集合的每一个元素</p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();
&#125;

<span class="hljs-comment">// Itr为ArrayList中的内部类</span>
<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;
    	<span class="hljs-comment">// 光标，用于指向下次被查看的元素。 一开始为0</span>
        <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span>
    	<span class="hljs-comment">// 最后一个元素的索引，如果没有元素就是-1</span>
        <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span>
    
    	<span class="hljs-comment">// 期望的被修改次数 = 开始迭代时被修改的次数。主要是为了检查多线程情况下，是否出现了并发安全性问题</span>
        <span class="hljs-keyword">int</span> expectedModCount = modCount;
	
    	<span class="hljs-comment">// 无参构造函数</span>
        Itr() &#123;&#125;
	
    	<span class="hljs-comment">// 查看是否到了末尾， 如果光标和数组大小相等，则到了末尾</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-keyword">return</span> cursor != size;
		&#125;

        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)
        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-comment">// 检查是否有并发安全性问题</span>
            checkForComodification();
            
            <span class="hljs-comment">// i 用来访问数组中的元素。 把光标的值赋值给i</span>
            <span class="hljs-keyword">int</span> i = cursor;
            
            <span class="hljs-comment">// 如果越界，抛出异常</span>
            <span class="hljs-keyword">if</span> (i &gt;= size)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();
            
            <span class="hljs-comment">// 将被迭代的数组赋值给elementData</span>
            Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;
            
            <span class="hljs-comment">// 是否越界</span>
            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
            
            <span class="hljs-comment">// 光标后移</span>
            cursor = i + <span class="hljs-number">1</span>;
            
            <span class="hljs-comment">// 给lastRet赋值，同时返回 i 指向的元素</span>
            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];
        &#125;

       
        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;
            <span class="hljs-comment">// 看当前的 modCount 和迭代开始前的 modCount (expectedModCount)是否相同</span>
            <span class="hljs-keyword">if</span> (modCount != expectedModCount)
                <span class="hljs-comment">// 如果不同，抛出异常</span>
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
        &#125;
&#125;</code></pre>



<p><strong>案例二</strong>：在使用迭代器遍历元素时，删除<strong>最后一个</strong>元素</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
		arrayList.add(<span class="hljs-string">"Nyima1"</span>);
		arrayList.add(<span class="hljs-string">"Nyima2"</span>);
		arrayList.add(<span class="hljs-string">"Nyima3"</span>);

		Iterator iterator = arrayList.iterator();

		<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
			String tempStr = (String) iterator.next();
            <span class="hljs-comment">// 移除最后一个元素</span>
			<span class="hljs-keyword">if</span>(tempStr.equals(<span class="hljs-string">"Nyima3"</span>)) &#123;
				arrayList.remove(tempStr);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p><strong>运行结果</strong></p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163121.png" srcset="/img/loading.gif" alt=""></p>
<p><strong>问题分析</strong></p>
<ul>
<li><p>每次进行遍历操作调用 next 方法时，在开头都会先调用  方法，<strong>来判断modCount是否和expectedModCount是否一致</strong></p>
<ul>
<li><p>在删除指定元素前的遍历中，可以看到 modCount 和 expectedModCount 相同，都为3</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163407.png" srcset="/img/loading.gif" alt=""></p>
</li>
</ul>
</li>
<li><p>进行删除操作，<strong>删除操作会使得数组的大小-1</strong><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163528.png" srcset="/img/loading.gif" alt=""></p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)
                <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-keyword">null</span>) &#123;
                    fastRemove(index);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>; index &lt; size; index++)
                <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;
                    fastRemove(index);
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    &#125;

    <span class="hljs-comment">/*</span>
<span class="hljs-comment">     * Private remove method that skips bounds checking and does not</span>
<span class="hljs-comment">     * return the value removed.</span>
<span class="hljs-comment">     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fastRemove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;
        modCount++;
        <span class="hljs-keyword">int</span> numMoved = size - index - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)
            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,
                             numMoved);
        
        <span class="hljs-comment">// 这里会使得数组的大小-1</span>
        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// clear to let GC do its work</span>
    &#125;</code></pre>
</li>
<li><p>继续向下执行，会发现在遍历了所有元素之后，<strong>循环并没有第一时间就停下来</strong>！</p>
<ul>
<li>可以看到，hasNext 是<strong>根据光标和数组大小是否一致来判断是否有下一个元素的</strong></li>
</ul>
</li>
</ul>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910163802.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>再次执行next，此时发现<strong>modCount是否和expectedModCount不一致！</strong>便抛出了异常<ul>
<li>modCount的增加是因为<strong>前面进行了删除操作，使得modCount的值+1了</strong></li>
</ul>
</li>
</ul>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910164004.png" srcset="/img/loading.gif" alt=""></p>
<p><strong>结论</strong>：在使用迭代器进行遍历时，如果中途<strong>移除了最后一个元素</strong>，则会出现<strong>并发修改异常</strong>。因为在遍历过程中modCount的值被修改了</p>
<p><strong>案例三</strong>：使用迭代器删除<strong>倒数第二个</strong>元素</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo3</span> </span>&#123;
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		ArrayList&lt;String&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
		arrayList.add(<span class="hljs-string">"Nyima1"</span>);
		arrayList.add(<span class="hljs-string">"Nyima2"</span>);
		arrayList.add(<span class="hljs-string">"Nyima3"</span>);

		Iterator iterator = arrayList.iterator();

		<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;
			String tempStr = (String) iterator.next();
            <span class="hljs-comment">// 移除倒数第二个元素</span>
			<span class="hljs-keyword">if</span>(tempStr.equals(<span class="hljs-string">"Nyima2"</span>)) &#123;
				arrayList.remove(tempStr);
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<p><strong>运行结果</strong>：没有抛出异常</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910165928.png" srcset="/img/loading.gif" alt=""></p>
<p>问题分析：</p>
<ul>
<li><p>在删除第二个元素的时候，modCount确实增加了 3-&gt;4</p>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910170113.png" srcset="/img/loading.gif" alt=""></p>
</li>
<li><p>因为删除了一个元素，<strong>此时的数组大小 size = 2，与光标cursor的大小一致了</strong> ！</p>
</li>
</ul>
<p><img src="https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20200910170139.png" srcset="/img/loading.gif" alt=""></p>
<ul>
<li>所以<strong>还没来得及做下一次 modCount 和 expectedModCount 的检测，就跳出了循环</strong></li>
</ul>
<p>在遍历ArrayList时，不要对集合中的元素进行增加与修改操作。如果要进行元素的<strong>删除</strong>，最好<strong>使用迭代器自身的 remove() 方法</strong></p>
<pre><code class="hljs java">iterator.remove();</code></pre>



<h4 id="迭代器默认remove-方法"><a href="#迭代器默认remove-方法" class="headerlink" title="迭代器默认remove()方法"></a>迭代器默认remove()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();
    
    <span class="hljs-comment">// 调用方法检测 modCount 和 expectedModCount，此时还未进行删除操作，所以两个值相同</span>
    checkForComodification();

    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 调用ArrayList的remove(index)方法进行删除，此操作会修改modCount的值</span>
        ArrayList.<span class="hljs-keyword">this</span>.remove(lastRet);  
        cursor = lastRet;
        lastRet = -<span class="hljs-number">1</span>;
        
        <span class="hljs-comment">// 更新 expectedModCount 的值</span>
        expectedModCount = modCount;
    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();
    &#125;
&#125;</code></pre>

<p>可以看出，<strong>迭代器默认的remove方法，在进行完删除操作后，更新了 expectedModCount 的值，使得其与modCount一致</strong></p>
<h3 id="7、清空方法"><a href="#7、清空方法" class="headerlink" title="7、清空方法"></a>7、清空方法</h3><h4 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear()方法"></a>clear()方法</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;
    modCount++;

    <span class="hljs-comment">// clear to let GC do its work</span>
    <span class="hljs-comment">// 依次将数组中的元素置为null，方便GC来回收内存</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)
        elementData[i] = <span class="hljs-keyword">null</span>;

    <span class="hljs-comment">// 将容量设置为0</span>
    size = <span class="hljs-number">0</span>;
&#125;</code></pre>



<h3 id="8、包含方法"><a href="#8、包含方法" class="headerlink" title="8、包含方法"></a>8、包含方法</h3><h4 id="contains-Object-o-方法"><a href="#contains-Object-o-方法" class="headerlink" title="contains(Object o)方法"></a>contains(Object o)方法</h4><pre><code class="hljs java"><span class="hljs-comment">// 将参数转为了Object类型</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;
    <span class="hljs-comment">// 调用 indexOf 方法，查找o的索引。如果索引值大于等于0，就返回true，反之返回false</span>
    <span class="hljs-keyword">return</span> indexOf(o) &gt;= <span class="hljs-number">0</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;
    	<span class="hljs-comment">// 传入参数是否为 null</span>
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// 依次遍历数组，返回遇到的第一个null的索引</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)
                <span class="hljs-keyword">if</span> (elementData[i]==<span class="hljs-keyword">null</span>)
                    <span class="hljs-keyword">return</span> i;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 遍历数组，返回遇到的第一个o的索引</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)
                <span class="hljs-keyword">if</span> (o.equals(elementData[i]))
                    <span class="hljs-keyword">return</span> i;
        &#125;
    	<span class="hljs-comment">// 如果数组中没有该元素，就返回-1</span>
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
&#125;</code></pre>



<h1 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h1><h2 id="一、LinkedList底层数据结构"><a href="#一、LinkedList底层数据结构" class="headerlink" title="一、LinkedList底层数据结构"></a>一、LinkedList底层数据结构</h2><h3 id="1、LinkedList集合介绍"><a href="#1、LinkedList集合介绍" class="headerlink" title="1、LinkedList集合介绍"></a>1、LinkedList集合介绍</h3><p>LinkedList底层由一个<strong>拥有头、尾指针的双向链表构成</strong></p>
<h3 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、链表</h3><p>链表的<strong>增删插入效率高</strong>，但是<strong>查找效率较低</strong></p>
<p>详细可见<a href="https://nyimac.gitee.io/2020/06/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8">Java数据结构与算法——链表</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/08/16/MySQL%E9%AB%98%E7%BA%A7/">
                        <span class="hidden-mobile">MySQL高级</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      function loadDisqus() {
        var disqus_config = function () {
          this.page.url = 'http://nyimac.gitee.io/2020/09/10/集合源码/';
          this.page.identifier = '/2020/09/10/集合源码/';
        };
        (function () {
          var d = document,
            s = d.createElement('script');
          s.src = '//' + '' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        })();
      }
      createObserver(loadDisqus, 'disqus_thread');
    </script>
    <noscript>Please enable JavaScript to view the
      <a href="https://disqus.com/?ref_noscript" target="_blank" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">蜀ICP备19012576号-1</a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "集合源码&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>

















  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?ba41ec605b9b7320e120275462e4035b";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





</body>
</html>
